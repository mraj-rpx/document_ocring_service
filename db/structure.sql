--
-- PostgreSQL database dump
--

-- Dumped from database version 9.5.7
-- Dumped by pg_dump version 9.6.2

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: acquiflow; Type: SCHEMA; Schema: -; Owner: -
--

create language plperl;
create language plperlu;
-- create tablespace rpx_user_default 'data';
CREATE SCHEMA acquiflow;


--
-- Name: core; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA core;


--
-- Name: docdb; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA docdb;


--
-- Name: document_ocr_service; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA document_ocr_service;


--
-- Name: ptab; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA ptab;


SET search_path = core, pg_catalog;

--
-- Name: cp_core_etl_patent; Type: TYPE; Schema: core; Owner: -
--

CREATE TYPE cp_core_etl_patent AS (
	title text,
	application_date date,
	publication_date date,
	core_db_patent_id text,
	patnum text,
	inventor text,
	is_application boolean,
	core_db_patnum text
);


--
-- Name: queue_msg_type; Type: TYPE; Schema: core; Owner: -
--

CREATE TYPE queue_msg_type AS (
	msg_id integer,
	msg_key character varying,
	msg_body text,
	msg_create_ts timestamp without time zone,
	msg_priority integer,
	msg_client_id integer,
	msg_type integer
);


SET search_path = public, pg_catalog;

--
-- Name: cp_core_etl_patent; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE cp_core_etl_patent AS (
	title text,
	application_date date,
	publication_date date,
	core_db_patent_id text,
	patnum text,
	inventor text,
	application boolean,
	core_db_patnum text
);


--
-- Name: dblink_cp_etlcp_core_etl_patent; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE dblink_cp_etlcp_core_etl_patent AS (
	title text,
	application_date date,
	publication_date date,
	core_db_patent_id text,
	patnum text,
	inventor text,
	application boolean,
	core_db_patnum text
);


--
-- Name: related_views_type; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE related_views_type AS (
	parent_schema character varying,
	parent_view character varying,
	child_schema character varying,
	child_view character varying,
	parent_object_type character varying
);


SET search_path = acquiflow, pg_catalog;

--
-- Name: acquisition_pats_assets_v1(integer, character varying, character varying); Type: FUNCTION; Schema: acquiflow; Owner: -
--

CREATE FUNCTION acquisition_pats_assets_v1(p_acquisition_id integer DEFAULT NULL::integer, p_stripped_patnum character varying DEFAULT NULL::character varying, p_country_code character varying DEFAULT NULL::character varying) RETURNS TABLE(acquisition_id integer, stripped_patnum character varying, country_code character varying, publication_date date, title text, patnum text, issue_date date, expiration_date date, priority_date date, is_application text)
    LANGUAGE plpgsql
    AS $$
      BEGIN
      IF p_acquisition_id IS NULL AND p_stripped_patnum IS NULL THEN
          RAISE EXCEPTION '[acquisition_pats_assets_v1] Either of p_acquisition_id or (p_stripped_patnum and p_country_code) is mandatory input.';
      END IF;

      RETURN QUERY
        SELECT
          pat_dtls.acquisition_id,
          pat_dtls.stripped_patnum,
          pat_dtls.country_code,
          MAX (pat_dtls.publication_date) AS publication_date,
          MAX (pat_dtls.title) AS title,
          MAX (pat_dtls.patnum) AS patnum,
          MAX (pat_dtls.issue_date) AS issue_date,
          MAX (ps.expiration_date) AS expiration_date,
          MAX (ps.priority_date) AS priority_date,
          (
            CASE
            WHEN (
              LENGTH (
                (pat_dtls.stripped_patnum) :: TEXT
              ) > 8
            ) THEN
              'Y'
            ELSE
              'N'
            END
          ) AS is_application
        FROM
          (
            (
              SELECT
                ap.acquisition_id,
                dp.publication_date,
                pt.title,
                dp.patnum,
                dp.stripped_patnum,
                dp.country_code,
                dp.issue_date
              FROM
                (
                  docdb.docdb_pats dp
                  LEFT JOIN docdb.docdb_titles pt ON ((dp. ID = pt.pat_id))
                  INNER JOIN acquiflow.acquisition_patents ap ON (
                    dp.stripped_patnum = ap.stripped_patnum
                    AND dp.country_code = ap.country_code
                    AND ap.acquisition_id = coalesce(p_acquisition_id,ap.acquisition_id)
                    AND dp.stripped_patnum = coalesce(p_stripped_patnum,dp.stripped_patnum)
                    AND dp.country_code = coalesce(p_country_code,dp.country_code)
                  )
                )
              UNION ALL
                SELECT
                  ap.acquisition_id,
                  pats.publication_date,
                  pats.title,
                  pats.patnum,
                  pats.stripped_patnum,
                  pats.country_code,
                  pats.issue_date
                FROM
                  core.pats
                INNER JOIN acquiflow.acquisition_patents ap ON (
                  pats.stripped_patnum = ap.stripped_patnum
                  AND pats.country_code = ap.country_code
                  AND ap.acquisition_id = coalesce(p_acquisition_id,ap.acquisition_id)
                  AND pats.stripped_patnum = coalesce(p_stripped_patnum,pats.stripped_patnum)
                  AND pats.country_code = coalesce(p_country_code,pats.country_code)
                )
            ) pat_dtls
            LEFT JOIN core.pat_stats ps ON (
              (
                pat_dtls.stripped_patnum = ps.stripped_patnum
                AND pat_dtls.country_code = ps.country_code
              )
            )
          )
        GROUP BY
          pat_dtls.acquisition_id,
          pat_dtls.stripped_patnum,
          pat_dtls.country_code;

      EXCEPTION
        WHEN OTHERS THEN
        RAISE;
      END;
      $$;


--
-- Name: acquisition_pats_assets_v2(integer, character varying, character varying, integer, character varying); Type: FUNCTION; Schema: acquiflow; Owner: -
--

CREATE FUNCTION acquisition_pats_assets_v2(p_acquisition_id integer DEFAULT NULL::integer, p_stripped_patnum character varying DEFAULT NULL::character varying, p_country_code character varying DEFAULT NULL::character varying, p_asset_id integer DEFAULT NULL::integer, p_record_source character varying DEFAULT NULL::character varying) RETURNS TABLE(asset_id integer, acquisition_id integer, stripped_patnum character varying, country_code character varying, application_number character varying, publication_date date, title text, patnum text, issue_date date, expiration_date date, priority_date date, is_application text, record_source text)
    LANGUAGE plpgsql
    AS $$
        BEGIN
        /*
        2.0 anarayanan 28-Jan-2015 DS-1096: Added two new fields
        2.1 anarayanan 29-Jan-2015 DS-1096: Added application_number
        */
        IF p_acquisition_id IS NULL
        AND p_stripped_patnum IS NULL THEN
          RAISE EXCEPTION '[acquisition_pats_assets_v2] Either of p_acquisition_id or (p_stripped_patnum and p_country_code) is mandatory input.' ;
        END
        IF ; RETURN QUERY SELECT
          pat_dtls.asset_id,
          pat_dtls.acquisition_id,
          pat_dtls.stripped_patnum,
          pat_dtls.country_code,
          pat_dtls.application_number,
          MAX (pat_dtls.publication_date) AS publication_date,
          MAX (pat_dtls.title) AS title,
          MAX (pat_dtls.patnum) AS patnum,
          MAX (pat_dtls.issue_date) AS issue_date,
          MAX (ps.expiration_date) AS expiration_date,
          MAX (ps.priority_date) AS priority_date,
          (
            CASE
            WHEN (
              LENGTH (
                (pat_dtls.stripped_patnum) :: TEXT
              ) > 8
            ) THEN
              'Y'
            ELSE
              'N'
            END
          ) AS is_application,
          pat_dtls.record_source
        FROM
          (
            (
              SELECT
                dp. ID AS asset_id,
                ap.acquisition_id,
                dp.publication_date,
                pt.title,
                dp.patnum,
                dp.stripped_patnum,
                dp.country_code,
                dp.app_num_intl as application_number,
                dp.issue_date,
                'D' :: TEXT AS record_source
              FROM
                (
                  docdb.docdb_pats dp
                  LEFT JOIN docdb.docdb_titles pt ON (
                    (dp. ID = pt.pat_id)
                    AND dp. ID = COALESCE (p_asset_id, dp. ID)
                    AND 'D' :: CHARACTER VARYING = COALESCE (
                      p_record_source,
                      'D' :: CHARACTER VARYING
                    )
                  )
                  INNER JOIN acquiflow.acquisition_patents ap ON (
                    dp.stripped_patnum = ap.stripped_patnum
                    AND dp.country_code = ap.country_code
                    AND ap.acquisition_id = COALESCE (
                      p_acquisition_id,
                      ap.acquisition_id
                    )
                    AND dp.stripped_patnum = COALESCE (
                      p_stripped_patnum,
                      dp.stripped_patnum
                    )
                    AND dp.country_code = COALESCE (
                      p_country_code,
                      dp.country_code
                    )
                  )
                )
              UNION ALL
                SELECT
                  pats. ID AS asset_id,
                  ap.acquisition_id,
                  pats.publication_date,
                  pats.title,
                  pats.patnum,
                  pats.stripped_patnum,
                  pats.country_code,
                  pats.app_num_country as application_number,
                  pats.issue_date,
                  'C' :: TEXT AS record_source
                FROM
                  core.pats
                INNER JOIN acquiflow.acquisition_patents ap ON (
                  pats.stripped_patnum = ap.stripped_patnum
                  AND pats.country_code = ap.country_code
                  AND ap.acquisition_id = COALESCE (
                    p_acquisition_id,
                    ap.acquisition_id
                  )
                  AND pats.stripped_patnum = COALESCE (
                    p_stripped_patnum,
                    pats.stripped_patnum
                  )
                  AND pats.country_code = COALESCE (
                    p_country_code,
                    pats.country_code
                  )
                  AND pats. ID = COALESCE (p_asset_id, pats. ID)
                  AND 'C' :: CHARACTER VARYING = COALESCE (
                    p_record_source,
                    'C' :: CHARACTER VARYING
                  )
                )
            ) pat_dtls
            LEFT JOIN core.pat_stats ps ON (
              (
                pat_dtls.stripped_patnum = ps.stripped_patnum
                AND pat_dtls.country_code = ps.country_code
              )
            )
          )
        GROUP BY
          pat_dtls.asset_id,
          pat_dtls.acquisition_id,
          pat_dtls.stripped_patnum,
          pat_dtls.country_code,
          pat_dtls.application_number,
          pat_dtls.record_source ; EXCEPTION
        WHEN OTHERS THEN
          RAISE ;
        END ; $$;


--
-- Name: acquisition_pats_assets_v3(integer, character varying, character varying); Type: FUNCTION; Schema: acquiflow; Owner: -
--

CREATE FUNCTION acquisition_pats_assets_v3(p_acquisition_id integer DEFAULT NULL::integer, p_stripped_patnum character varying DEFAULT NULL::character varying, p_country_code character varying DEFAULT NULL::character varying) RETURNS TABLE(acquisition_id integer, stripped_patnum character varying, country_code character varying, application_number character varying, patnum text, publication_date date, title text, issue_date date, expiration_date date, priority_date date, filing_date date, is_application text)
    LANGUAGE plpgsql
    AS $$
DECLARE
v_sql text := '';
BEGIN
/*
1 anarayanan 06-Jun-2014 DS-283: New Function created.
2.0 anarayanan 28-Jan-2015 DS-1096: Added two new fields
2.1 anarayanan 29-Jan-2015 DS-1096: Added application_number
3.0   asett       28-Jan-2015 DS-1100: dropped asset_id, asset_source parameters since we decided (Fli, SReddy, ASett) we don't need it, Modified to take assets from CPI
3.1 asett 12Feb 2015 DS-1141 - modified patnum = country_code || patent_number for cpi_only_assets
3.2 asett 13 Feb 2015 DS-1141 - duplicate entries prevented from coming, made logic at per with v_acquisition_assets
4.0 asett 26 Feb 2014 DS-1278 - fixed the logic for determining is_application - all international assets are patents.
4.1 asett 17th March 2015 DS-1405 - added filing date to the result set.
4.2 asett 20 March 2015 DS-724 is_application logic is changed based on only issue_date.
4.3 asett 21 March 2014 DS-1417 - changed logic to include some asset which were manually entered but have already in docdb the same patnum (different asset)
4.4 tazhagan_c 02 Feb 2016 DS-3070 : No longer used
*/
    IF p_acquisition_id IS NULL AND p_stripped_patnum IS NULL THEN
        RAISE EXCEPTION '[acquiflow.acquisition_pats_assets_v3] Either of p_acquisition_id or (p_stripped_patnum and p_country_code) is mandatory input.';
    END IF;

    RETURN QUERY
        SELECT
pat_dtls.acquisition_id,
pat_dtls.stripped_patnum,
pat_dtls.country_code,
    pat_dtls.application_number,
    pat_dtls.patnum::text AS patnum,
pat_dtls.publication_date AS publication_date,
pat_dtls.title AS title,
pat_dtls.issue_date AS issue_date,
ps.expiration_date AS expiration_date,
ps.priority_date AS priority_date,
pat_dtls.app_filing_date AS app_filing_date,
            CASE WHEN pat_dtls.issue_date IS NOT NULL THEN 'N'::TEXT ELSE 'Y'::TEXT END AS is_application
FROM
(
(
SELECT
ap.acquisition_id,
dp.publication_date,
(SELECT pt.title FROM docdb.docdb_titles pt WHERE pt.pat_id = dp.id AND lang = 'en' limit 1) as title,
dp.patnum,
dp.stripped_patnum,
ap.application_number,
dp.country_code,
dp.issue_date,
dp.app_date as app_filing_date
FROM acquiflow.acquisition_patents ap
INNER JOIN docdb.docdb_pats dp ON (
dp.patnum = ap.patnum
AND dp.country_code = ap.country_code)
WHERE ap.acquisition_id = coalesce(p_acquisition_id,ap.acquisition_id)
AND dp.stripped_patnum = coalesce(p_stripped_patnum,dp.stripped_patnum)
AND dp.country_code = coalesce(p_country_code,dp.country_code)
AND dp.country_code <> 'US'
AND ap.asset_source <> 'M'
UNION ALL
SELECT
ap.acquisition_id,
pats.publication_date,
pats.title,
pats.patnum,
pats.stripped_patnum,
ap.application_number,
pats.country_code,
pats.issue_date,
pats.app_filing_date
FROM acquiflow.acquisition_patents ap
INNER JOIN core.pats ON (
pats.stripped_patnum = ap.stripped_patnum
AND pats.country_code = ap.country_code)
WHERE ap.asset_source <> 'M'
AND ap.acquisition_id = coalesce(p_acquisition_id,ap.acquisition_id)
AND pats.stripped_patnum = coalesce(p_stripped_patnum,pats.stripped_patnum)
AND pats.country_code = coalesce(p_country_code,pats.country_code)
UNION ALL
SELECT
cpi_pats.acquisition_id,
cpi_pats.publication_date,
cpi_pats.title,
cpi_pats.patnum,
cpi_pats.stripped_patnum,
cpi_pats.application_number,
cpi_pats.country_code,
cpi_pats.issue_date,
cpi_pats.app_filing_date
FROM (
SELECT
ap.acquisition_id,
ap.publication_date,
cpi.title,
ap.patnum as patnum,
ap.stripped_patnum as stripped_patnum,
ap.application_number,
ap.country_code as country_code,
cpi.issue_date,
cpi.filing_date as app_filing_date,
ROW_NUMBER() OVER (PARTITION BY ap.application_number, ap.stripped_patnum, ap.country_code, ap.patnum ORDER BY cpi.ISSUE_DATE) AS ROWN
FROM acquiflow.acquisition_patents ap
LEFT JOIN acquiflow.cpi_only_assets cpi ON (
cpi.patent_number = ap.stripped_patnum
AND cpi.wipo = ap.country_code)
WHERE ap.acquisition_id = coalesce(p_acquisition_id, ap.acquisition_id)
AND ap.stripped_patnum = coalesce(p_stripped_patnum, ap.stripped_patnum)
AND ap.country_code = coalesce(p_country_code, ap.country_code)
AND (ap.asset_source ='M' OR (NOT EXISTS (SELECT 1 FROM core.pats where pats.stripped_patnum = ap.stripped_patnum AND pats.country_code = ap.country_code)
    AND NOT EXISTS (SELECT 1 FROM docdb.docdb_pats WHERE docdb_pats.patnum = ap.patnum and docdb_pats.country_code = ap.country_code AND ap.country_code <> 'US')
    )
)
) cpi_pats
WHERE rown = 1
) pat_dtls
LEFT JOIN core.pat_stats ps ON (
(
pat_dtls.stripped_patnum = ps.stripped_patnum
AND pat_dtls.country_code = ps.country_code
)
)
)
;

EXCEPTION
    WHEN OTHERS THEN
        RAISE;
END;
$$;


--
-- Name: asset_exists_core_doc_cpi(character varying, character varying, character varying); Type: FUNCTION; Schema: acquiflow; Owner: -
--

CREATE FUNCTION asset_exists_core_doc_cpi(p_stripped_patnum character varying, p_country_code character varying, p_patnum character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
v_exists boolean := false;

BEGIN
return case (select count(*) FROM acquiflow.v_acquisition_assets v where v.stripped_patnum = p_stripped_patnum AND v.country_code = p_country_code) when 0 then false else true end;

EXCEPTION
    WHEN OTHERS THEN
        RAISE;
END;
$$;


--
-- Name: get_rpx_acquisition_assets_v1(integer, integer); Type: FUNCTION; Schema: acquiflow; Owner: -
--

CREATE FUNCTION get_rpx_acquisition_assets_v1(p_acquisition_id integer DEFAULT NULL::integer, p_portfolio_id integer DEFAULT NULL::integer) RETURNS TABLE(r_acquisition_patent_id integer, r_acquisition_id integer, r_portfolio_id integer, r_acquisition_name character varying, r_acquisition_date date, r_portfolio_name character varying, r_current_assignees text, r_publication_number character varying, r_publication_date date, r_pat_family_id integer, r_expiration_date date, r_rpx_ownership_rights character varying, r_assets_status character varying, r_country_code character varying, r_stripped_patnum character varying, r_patnum character varying, r_application_number text, r_case_number character varying, r_title character varying, r_filedate text, r_issue_date text, r_subcase character varying, r_source text, r_source_asset_id text)
    LANGUAGE plpgsql
    AS $$
DECLARE
v_sql text := '';
BEGIN
/*
1 asett 18Feb 2015 DS-1236: New function created
1.1 asett 25 Feb 2015 DS-1236 - function parameter changed to allow null acquisition id.
1.2 asett March 4 2015 - DS_1236 - Query changed for performance
1.3 asett March 25 - DS-1417 - logic updated to be at per with
1.4 tazhagan_c 02 Feb 2016 DS-3070 : No longer used
*/

RETURN QUERY
SELECT
patents.acquisition_patent_id,
aq. ID AS acquisition_id,
ports. ID AS portfolio_id,
aq.acquisition_name,
aq.acquisition_date,
ports.portfolio_name :: VARCHAR (512),
array_to_string(
patents.current_assignees,
';',
' '
) :: TEXT AS current_assignees,
patents.publication_number :: VARCHAR (32),
patents.publication_date,
patents.pat_family_id,
patents.expiration_date,
rgh. NAME AS rpx_ownership_rights,
st. NAME AS assets_status,
patents.country_code,
patents.stripped_patnum,
patents.patnum :: VARCHAR (32),
patents.application_number :: TEXT,
patents.case_number :: VARCHAR (32),
patents.title :: VARCHAR,
TO_CHAR(TO_DATE(
patents.app_file_date,
'YYYY-MM-DD'
), 'YYYY-MM-DD')::TEXT AS app_file_date,
TO_CHAR(TO_DATE(
patents.issue_date,
'YYYY-MM-DD'
), 'YYYY-MM-DD')::TEXT AS issue_date,
aqpa.subcase :: VARCHAR (8),
patents. SOURCE :: TEXT,
patents.source_asset_id :: TEXT
FROM
(
SELECT
aqp. ID AS acquisition_patent_id,
aqp.acquisition_id,
aqp.portfolio_id,
(
SELECT
ARRAY_AGG (
DISTINCT COALESCE (
assignee_ents. NAME,
assignee_alias. NAME
)
) :: VARCHAR []
FROM
core.pat_stats ps
LEFT JOIN core.pat_stats_current_assignees psca ON psca.pat_stats_id = ps. ID
LEFT JOIN core.aliases assignee_alias ON assignee_alias. ID = psca.alias_id
LEFT JOIN core.ents assignee_ents ON assignee_ents. ID = assignee_alias.ent_id
WHERE
(
vw.stripped_patnum = ps.stripped_patnum
AND vw.country_code = ps.country_code
)
) AS current_assignees,
(
SELECT
ARRAY_AGG (
DISTINCT
assignee_alias.id
):: INTEGER []
FROM
core.pat_stats ps
LEFT JOIN core.pat_stats_current_assignees psca ON psca.pat_stats_id = ps. ID
LEFT JOIN core.aliases assignee_alias ON assignee_alias. ID = psca.alias_id
WHERE
(
vw.stripped_patnum = ps.stripped_patnum
AND vw.country_code = ps.country_code
)
) AS current_assignee_aliases,
COALESCE (
vw.publication_number,
(SELECT MAX(pats_pub.publication_number) FROM core.pats as pats_pub WHERE pats_pub.app_num_country = vw.app_num_country AND pats_pub.issue_date IS NULL AND pats_pub.publication_date IS NOT NULL LIMIT 1)
) AS publication_number,
COALESCE (
vw.publication_date,
(SELECT MAX(pats_pub.publication_date) FROM core.pats as pats_pub WHERE pats_pub.app_num_country = vw.app_num_country AND pats_pub.issue_date IS NULL AND pats_pub.publication_date IS NOT NULL LIMIT 1)
) AS publication_date,
aqp.rpx_ownership_right_id,
aqp.asset_status_type_id,
(SELECT pmp.pat_family_id FROM docdb_families.pat_family_pats pmp WHERE pmp.stripped_patnum = vw.stripped_patnum AND pmp.country_code = vw.country_code LIMIT 1)::INTEGER AS pat_family_id,
aqp.expiration_date,
aqp.country_code,
aqp.stripped_patnum,
vw.patnum,
SUBSTRING (vw.app_num_country FROM 3 FOR 2) || '/' || SUBSTRING (vw.app_num_country FROM 5 FOR 10) AS application_number,
aqp.case_number,
vw.title,
to_char(
vw.app_filing_date,
'YYYY-MM-DD'
) AS app_file_date,
to_char(vw.issue_date, 'YYYY-MM-DD') AS issue_date,
CASE
WHEN (
SELECT
COUNT (*)
FROM
core.lits_pats_map
WHERE
patnum = aqp.stripped_patnum
) > 0 THEN
TRUE
ELSE
FALSE
END AS is_litigated,
COALESCE (
(
SELECT
MAX (1)
FROM
ptab.ptab_cases ipr
WHERE
aqp.stripped_patnum = ipr.stripped_patnum :: TEXT
AND aqp.country_code = ipr.country_code :: TEXT
GROUP BY
ipr.stripped_patnum,
ipr.country_code
),
0
) :: BOOLEAN AS is_ipr_flag,
'CORE_PATS' AS SOURCE,
vw. ID :: TEXT AS source_asset_id
FROM
acquiflow.acquisition_patents aqp
INNER JOIN core.pats vw ON (
vw.stripped_patnum = aqp.stripped_patnum
AND vw.country_code = aqp.country_code
)
WHERE aqp.asset_source <> 'M'
UNION ALL
SELECT
aqp. ID AS acquisition_patent_id,
aqp.acquisition_id,
aqp.portfolio_id,
NULL :: VARCHAR [] AS current_assignees,
NULL :: INTEGER [] AS current_assignee_aliases,
vw.publication_number publication_number,
vw.publication_date AS publication_date,
aqp.rpx_ownership_right_id,
aqp.asset_status_type_id,
(SELECT pmp.pat_family_id FROM docdb_families.pat_family_pats pmp WHERE pmp.patnum = vw.patnum AND pmp.country_code = vw.country_code LIMIT 1)::INTEGER AS pat_family_id,
aqp.expiration_date,
aqp.country_code,
aqp.stripped_patnum,
vw.patnum,
vw.app_num_intl AS application_number,
aqp.case_number,
(SELECT pt.title FROM docdb.docdb_titles pt WHERE pt.pat_id = vw.id AND pt.lang = 'en' limit 1) as title,
to_char(
vw.app_date,
'YYYY-MM-DD'
) AS filedate,
to_char(vw.issue_date, 'YYYY-MM-DD') AS issue_date,
NULL :: BOOLEAN AS is_litigated,
NULL :: BOOLEAN AS is_ipr_flag,
'DOCDB_PATS' AS SOURCE,
vw. ID :: TEXT AS source_asset_id
FROM
acquiflow.acquisition_patents aqp
INNER JOIN docdb.docdb_pats vw ON (vw.patnum = aqp.patnum AND aqp.country_code = vw.country_code)
WHERE
NOT EXISTS (
SELECT
1
FROM
core.pats
WHERE
pats.stripped_patnum = aqp.stripped_patnum
AND pats.country_code = aqp.country_code
)
AND aqp.asset_source <> 'M'
AND aqp.country_code <> 'US'
UNION ALL
SELECT
acquisition_patent_id::INTEGER,
acquisition_id::INTEGER,
portfolio_id::INTEGER,
current_assignees::VARCHAR[],
current_assignee_aliases::INTEGER[],
publication_number::VARCHAR,
publication_date::DATE,
rpx_ownership_right_id::INTEGER,
asset_status_type_id::INTEGER,
pat_family_id::INTEGER,
expiration_date::DATE,
country_code::VARCHAR,
stripped_patnum::VARCHAR,
patnum::VARCHAR,
application_number::VARCHAR,
case_number::VARCHAR,
TITLE::VARCHAR,
filedate::VARCHAR,
issue_date::VARCHAR,
is_litigated::BOOLEAN,
is_ipr_flag::BOOLEAN,
SOURCE::VARCHAR,
source_asset_id::TEXT
FROM (
SELECT
aqp. ID AS acquisition_patent_id,
aqp.acquisition_id AS acquisition_id,
aqp.portfolio_id,
NULL :: VARCHAR [] AS current_assignees,
NULL :: INTEGER [] AS current_assignee_aliases,
cpi.publication_number AS publication_number,
cpi.publication_date AS publication_date,
aqp.rpx_ownership_right_id,
aqp.asset_status_type_id,
NULL :: INTEGER pat_family_id,
aqp.expiration_date,
aqp.country_code,
aqp.stripped_patnum,
aqp.patnum,
aqp.application_number,
aqp.case_number,
cpi.title AS TITLE,
to_char(cpi.filing_date, 'YYYY-MM-DD') AS filedate,
to_char(cpi.issue_date, 'YYYY-MM-DD') AS issue_date,
CASE
WHEN (
SELECT
COUNT (*)
FROM
core.lits_pats_map
WHERE
patnum = aqp.stripped_patnum
) > 0 THEN
TRUE
ELSE
FALSE
END AS is_litigated,
COALESCE (
(
SELECT
MAX (1)
FROM
ptab.ptab_cases ipr
WHERE
aqp.stripped_patnum = ipr.stripped_patnum :: TEXT
AND aqp.country_code = ipr.country_code :: TEXT
GROUP BY
ipr.stripped_patnum,
ipr.country_code
),
0
) :: BOOLEAN AS is_ipr_flag,
'CPI_PATS'::VARCHAR AS SOURCE,
aqp. ID || '-' || COALESCE (cpi. ID, - 1) :: TEXT AS source_asset_id,
ROW_NUMBER() OVER (PARTITION BY aqp.application_number, aqp.stripped_patnum, aqp.country_code, aqp.patnum ORDER BY ISSUE_DATE) AS ROWN
FROM
acquiflow.acquisition_patents aqp
LEFT JOIN acquiflow.cpi_only_assets cpi ON (
cpi.patent_number = aqp.stripped_patnum
AND cpi.wipo = aqp.country_code
)
WHERE
1 = 1
AND (aqp.asset_source = 'M' OR
(NOT EXISTS (
SELECT
1
FROM
core.pats cdr
WHERE
cdr.stripped_patnum = COALESCE (aqp.stripped_patnum, '-1')
AND cdr.country_code = aqp.country_code
)
AND NOT EXISTS (
SELECT
1
FROM
docdb.docdb_pats cdr
WHERE
cdr.patnum = COALESCE (aqp.patnum, '-1')
AND cdr.country_code = aqp.country_code
AND aqp.country_code <> 'US'
)
)
)
) CPI_PATS WHERE rown = 1
) AS patents
INNER JOIN acquiflow.acquisitions aq ON patents.acquisition_id = aq. ID
INNER JOIN acquiflow.acquisition_patent_attributes aqpa ON aqpa.acquisition_patent_id = patents.acquisition_patent_id
LEFT JOIN acquiflow.rpx_ownership_rights rgh ON rgh. ID = patents.rpx_ownership_right_id
LEFT JOIN acquiflow.asset_status_types st ON st. ID = patents.asset_status_type_id
LEFT JOIN (SELECT * FROM acquiflow.portfolios ports WHERE ports.id = COALESCE (p_portfolio_id, ports. ID)) ports ON  ports.id = patents.portfolio_id
WHERE aq. ID = COALESCE (p_acquisition_id, aq. ID);

EXCEPTION
WHEN OTHERS THEN
RAISE;
END;
$$;


SET search_path = core, pg_catalog;

--
-- Name: add_lit_family(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION add_lit_family() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_family_id     INTEGER;

BEGIN
	INSERT INTO core.lit_families
		(is_obsolete, new_family_id, updated_at, created_at)
	VALUES
		(FALSE, NULL::INTEGER[], CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
	RETURNING id INTO v_family_id;

	IF v_family_id IS NULL THEN
		RAISE EXCEPTION '[core.add_lit_family] Unable to create a lit_families record.';
	END IF;

    RETURN v_family_id;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core.add_lit_family] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core.add_lit_family] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
    WHEN OTHERS THEN
        RAISE;

END;
$$;


--
-- Name: after_lit_add(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION after_lit_add() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_rel_count INTEGER;
BEGIN
    IF (TG_OP = 'INSERT') THEN
        --If we're creating a new litigation, then it should get a self-pointing relationship
        --and it's own family until someone decides it's linked to another case.
        PERFORM core.find_or_create_lit_family(NEW.id);
        RETURN NEW;

    ELSIF (TG_OP = 'UPDATE') THEN
        --This should never be called since the trigger calling this is for inserts only
        RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        --This should never be called since the trigger calling this is for inserts only
        RETURN OLD;
    END IF;

END;
$$;


--
-- Name: after_lit_relationship_added(integer, integer, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION after_lit_relationship_added(p_lit_rel_id integer, p_lit_from integer, p_lit_to integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_rel_count     INTEGER;

BEGIN
    --Update family information for from_lit
    PERFORM core.find_or_create_lit_family(p_lit_from);
    IF p_lit_from != p_lit_to THEN
        --To make sure the from_lit and to_lit families are properly combined, we need to check the to_lit
        PERFORM core.find_or_create_lit_family(p_lit_to);

        --We need to remove any self-pointing relationships for either lit in the new relationship
        DELETE FROM core.lit_relationships
        WHERE from_lit_id = to_lit_id
            AND id != p_lit_rel_id
            AND from_lit_id IN (p_lit_from, p_lit_to);
    END IF;

    --Make sure that any relationship types affected by the new relationship are updated.
    PERFORM core.set_lit_relationship_type(lr.id)
    FROM core.lit_relationships lr
    WHERE (from_lit_id IN (p_lit_from, p_lit_to)
           OR to_lit_id IN (p_lit_from, p_lit_to))
        AND (lr.lit_relationship_type_id != core.set_lit_relationship_type(lr.id) OR lr.lit_relationship_type_id IS NULL)
    ;

    RETURN p_lit_rel_id;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core.after_lit_relationship_added] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core.after_lit_relationship_added] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
    WHEN OTHERS THEN
        RAISE;

END;
$$;


--
-- Name: after_lit_relationship_change(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION after_lit_relationship_change() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
v_is_campaign_follower_id integer:= (select id from core.lit_relationship_types where name = 'is_campaign_follower');
v_campaign_id integer;
BEGIN
/*
1.0 10-Jun-2015 anarayanan DS-1434 ignoring is_campaign_follower changes
*/
    --*** Parent trigger function to call all the sub-functions that update family/type info after a relationship change

    IF (TG_OP = 'DELETE') THEN
        IF (OLD.lit_relationship_type_id != v_is_campaign_follower_id) THEN
            PERFORM core.after_lit_relationship_deleted(OLD.id, OLD.from_lit_id, OLD.to_lit_id, OLD.lit_family_id);
    ELSIF (OLD.lit_relationship_type_id = v_is_campaign_follower_id) THEN
    SELECT campaign_id INTO v_campaign_id from lit_campaigns.campaign_lits where lit_id = OLD.from_lit_id;
      IF v_campaign_id IS NOT NULL THEN
        PERFORM lit_campaigns.delete_lit_from_campaign(OLD.from_lit_id, v_campaign_id);
        UPDATE core.lits
        SET updated_at = now()
        WHERE id = OLD.from_lit_id;
      END IF;
        END IF;
        RETURN OLD;

    ELSIF (TG_OP = 'UPDATE') THEN
        IF (NEW.lit_relationship_type_id != v_is_campaign_follower_id) THEN
            IF (NEW.from_lit_id != OLD.from_lit_id) OR (NEW.to_lit_id != OLD.to_lit_id) THEN
                --If one of the litigations in the relationship changed,
                --it's like deleting the old relationship and adding a new one.
                PERFORM core.after_lit_relationship_deleted(OLD.id, OLD.from_lit_id, OLD.to_lit_id, OLD.lit_family_id);
                PERFORM core.after_lit_relationship_added(NEW.id, NEW.from_lit_id, NEW.to_lit_id);
            END IF;
        END IF;
    IF ((OLD.lit_relationship_type_id = v_is_campaign_follower_id) AND (NEW.lit_relationship_type_id != v_is_campaign_follower_id)) THEN
      IF v_campaign_id IS NOT NULL THEN
        PERFORM lit_campaigns.delete_lit_from_campaign(OLD.from_lit_id, v_campaign_id);
        UPDATE core.lits
        SET updated_at = now()
        WHERE id = OLD.from_lit_id;
      END IF;
    END IF;
        RETURN NEW;

    ELSIF (TG_OP = 'INSERT') THEN
        IF (NEW.lit_relationship_type_id != v_is_campaign_follower_id) THEN
            PERFORM core.after_lit_relationship_added(NEW.id, NEW.from_lit_id, NEW.to_lit_id);
        END IF;
        RETURN NEW;

    END IF;
END;
$$;


--
-- Name: after_lit_relationship_deleted(integer, integer, integer, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION after_lit_relationship_deleted(p_lit_rel_id integer, p_lit_from integer, p_lit_to integer, p_lit_family integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_del_lit_from      INTEGER;
    v_del_lit_to        INTEGER;

    v_start_lits_from   INTEGER[];
    v_lit_fam_list_from INTEGER[];
    v_family_id_from    INTEGER;
    v_rel_count_from    INTEGER;

    v_start_lits_to     INTEGER[];
    v_lit_fam_list_to   INTEGER[];
    v_family_id_to      INTEGER;
    v_rel_count_to      INTEGER;

    v_new_family_list   INTEGER[] := ARRAY[]::INTEGER[];

BEGIN
    v_del_lit_from := p_lit_from;
    v_del_lit_to := p_lit_to;

    -- ***************************
    -- check the family in case it needs to split
    -- ***************************
    --Find the family from the from_lit_id of the relationship being deleted
    WITH RECURSIVE my_tree1(from_lit_id, to_lit_id) AS
        (SELECT lit_relationships.from_lit_id, lit_relationships.to_lit_id
         FROM core.lit_relationships
         WHERE lit_relationships.to_lit_id = v_del_lit_from
       UNION
         SELECT lr.from_lit_id, lr.to_lit_id
         FROM core.lit_relationships  lr
         INNER JOIN my_tree1          mt1 ON mt1.from_lit_id = lr.to_lit_id
        )
        SELECT array_agg(mt1.from_lit_id)
        INTO v_start_lits_from
        FROM my_tree1 mt1
        WHERE mt1.from_lit_id NOT IN (SELECT lr2.to_lit_id FROM core.lit_relationships lr2);

    --If there are no litgations before the from_lit_id, set our starting set to that one lit id
    IF v_start_lits_from IS NULL THEN
        v_start_lits_from := ARRAY[v_del_lit_from];
    END IF;

    --Trace up the tree to find the rest of the family
  WITH RECURSIVE my_tree2(from_lit_id, to_lit_id, viewed_lits) AS
    (SELECT lit_relationships.from_lit_id, lit_relationships.to_lit_id, ARRAY[]::INTEGER[] AS viewed_lits
     FROM core.lit_relationships
     WHERE lit_relationships.from_lit_id = ANY(v_start_lits_from)
     UNION
     SELECT lr.from_lit_id, lr.to_lit_id, array_append(mt2.viewed_lits, lr.from_lit_id) AS viewed_lits
     FROM core.lit_relationships lr
     INNER JOIN my_tree2         mt2 ON mt2.to_lit_id = lr.from_lit_id
         WHERE lr.to_lit_id != ALL (mt2.viewed_lits)
    )
        SELECT array_agg(DISTINCT zz.lit_id)
        INTO v_lit_fam_list_from
        FROM (SELECT mt2.from_lit_id AS lit_id
          FROM my_tree2 mt2
            UNION
          SELECT mt2.to_lit_id AS lit_id
          FROM my_tree2 mt2) zz
  ;

    --Find the family of the to_lit_id of the relationships being deleted
    WITH RECURSIVE my_tree1(from_lit_id, to_lit_id) AS
        (SELECT lit_relationships.from_lit_id, lit_relationships.to_lit_id
         FROM core.lit_relationships
         WHERE lit_relationships.to_lit_id = v_del_lit_to
       UNION
         SELECT lr.from_lit_id, lr.to_lit_id
         FROM core.lit_relationships  lr
         INNER JOIN my_tree1          mt1 ON mt1.from_lit_id = lr.to_lit_id
        )
        SELECT array_agg(mt1.from_lit_id)
        INTO v_start_lits_to
        FROM my_tree1 mt1
        WHERE mt1.from_lit_id NOT IN (SELECT lr2.to_lit_id FROM core.lit_relationships lr2);

    --If there are no litgations before the to_lit_id, set our starting set to that one lit id
    IF v_start_lits_to IS NULL THEN
        v_start_lits_to := ARRAY[v_del_lit_to];
    END IF;

    --Trace up the tree to find the rest of the family
  WITH RECURSIVE my_tree2(from_lit_id, to_lit_id, viewed_lits) AS
    (SELECT lit_relationships.from_lit_id, lit_relationships.to_lit_id, ARRAY[]::INTEGER[] AS viewed_lits
     FROM core.lit_relationships
     WHERE lit_relationships.from_lit_id = ANY(v_start_lits_to)
     UNION
     SELECT lr.from_lit_id, lr.to_lit_id, array_append(mt2.viewed_lits, lr.from_lit_id) AS viewed_lits
     FROM core.lit_relationships lr
     INNER JOIN my_tree2                     mt2 ON mt2.to_lit_id = lr.from_lit_id
         WHERE lr.to_lit_id != ALL (mt2.viewed_lits)
    )
        SELECT array_agg(DISTINCT zz.lit_id)
        INTO v_lit_fam_list_to
        FROM (SELECT mt2.from_lit_id AS lit_id
          FROM my_tree2 mt2
            UNION
          SELECT mt2.to_lit_id AS lit_id
          FROM my_tree2 mt2) zz
    ;

    IF (v_lit_fam_list_from && v_lit_fam_list_to)
        AND v_lit_fam_list_from IS NOT NULL
        AND v_lit_fam_list_to IS NOT NULL THEN
        --The family for the from_lit and the family for the to_lit still overlap, so no need to separate, they are still in the same family.
    ELSE
        --The two lits do not belong to the same family with the deleted relationship gone.
        --We need to create two new lit_family ids, reassign the members correctly, and redirect old family id to two new ones.

        --Create a family for the from_lit_id of the deleted relationship
        IF v_lit_fam_list_from IS NOT NULL AND array_length(v_lit_fam_list_from, 1) > 0 THEN
            v_family_id_from := core.add_lit_family();

      UPDATE core.lit_relationships
      SET lit_family_id = v_family_id_from
      WHERE from_lit_id = ANY(v_lit_fam_list_from) OR to_lit_id = ANY(v_lit_fam_list_from);
        END IF;

        --Create a family for the to_lit_id of the deleted relationship
        IF v_lit_fam_list_to IS NOT NULL AND array_length(v_lit_fam_list_to, 1) > 0 THEN
            v_family_id_to := core.add_lit_family();

      UPDATE core.lit_relationships
      SET lit_family_id = v_family_id_to
      WHERE from_lit_id = ANY(v_lit_fam_list_to) OR to_lit_id = ANY(v_lit_fam_list_to);
        END IF;

    --Check if the lits involved in the delete relationship have any other relationship, if not, create a self-pointing relationship for them
    SELECT count(*)
    INTO v_rel_count_from
    FROM core.lit_relationships
    WHERE from_lit_id = v_del_lit_from OR to_lit_id = v_del_lit_from;

    IF v_rel_count_from = 0 THEN
            v_family_id_from := core.add_lit_family();

      INSERT INTO core.lit_relationships
        (from_lit_id, to_lit_id, lit_relationship_type_id, lit_family_id)
      SELECT
        v_del_lit_from, v_del_lit_from, 2, v_family_id_from
            FROM core.lits
            WHERE id = v_del_lit_from;

    END IF;

    SELECT count(*)
    INTO v_rel_count_to
    FROM core.lit_relationships
    WHERE from_lit_id = v_del_lit_to OR to_lit_id = v_del_lit_to;

    IF v_rel_count_to = 0 THEN
            v_family_id_to := core.add_lit_family();

      INSERT INTO core.lit_relationships
        (from_lit_id, to_lit_id, lit_relationship_type_id, lit_family_id)
      SELECT
                v_del_lit_to, v_del_lit_to, 2, v_family_id_to
            FROM core.lits
            WHERE id = v_del_lit_to;


    END IF;

        IF v_family_id_from IS NOT NULL THEN
            v_new_family_list := array_append(v_new_family_list, v_family_id_from);
        END IF;

        IF v_family_id_to IS NOT NULL THEN
            v_new_family_list := array_append(v_new_family_list, v_family_id_to);
        END IF;

        --Mark the old lit_family obsolete
    UPDATE core.lit_families
    SET is_obsolete = TRUE,
            new_family_id = v_new_family_list
    WHERE id = p_lit_family;
    END IF;

    -- ***************************
    -- check / update the types of the other relationships involving the two lits in this relationship
    -- ***************************
    PERFORM core.set_lit_relationship_type(lr.id)
    FROM core.lit_relationships lr
    WHERE (from_lit_id IN (v_del_lit_from, v_del_lit_to)
           OR to_lit_id IN (v_del_lit_from, v_del_lit_to))
        AND (lr.lit_relationship_type_id != core.set_lit_relationship_type(lr.id) OR lr.lit_relationship_type_id IS NULL)
        AND id != p_lit_rel_id;

    RETURN p_lit_rel_id;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core.after_lit_relationship_deleted] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core.after_lit_relationship_deleted] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
    WHEN OTHERS THEN
        RAISE;

END;
$$;


--
-- Name: alerts_testing_load_itc_docket_entries_for_events(integer, character varying, integer, character varying, character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION alerts_testing_load_itc_docket_entries_for_events(p_document_id integer DEFAULT NULL::integer, p_investigation_number character varying DEFAULT NULL::character varying, p_investigation_id integer DEFAULT NULL::integer, p_title character varying DEFAULT 'Test Document Added'::character varying, p_document_type character varying DEFAULT 'Order, Commission'::character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
i_source_pk_val integer:=NULL;
i_attachment_id integer:=NULL;
p_official_received_date timestamp:=NOW();
p_document_date DATE:=NOW();
BEGIN
/*
	1.0 spasunkili_c 23-May-2016  DS-3670 Alerts Events Capture restructure
	
	select * from core.alerts_testing_load_itc_docket_entries_for_events(p_document_id:=12345
		,p_investigation_id:=1023)

*/
IF ((p_investigation_number IS NOT NULL OR p_investigation_number <> '') AND (p_investigation_id IS NULL)) THEN
	SELECT ID INTO p_investigation_id FROM itc_investigations.itc_investigations WHERE investigation_number = p_investigation_number;
	IF p_investigation_id IS NULL THEN 
	RAISE EXCEPTION 'Invalid Input: investigation_id not exists';
	END IF;
ELSIF p_investigation_number IS NULL AND p_investigation_id IS NULL THEN
	RAISE EXCEPTION 'Invalid Input: investigation_number/investigation_id cannot be NULL or Empty';
END IF;
	

	SELECT MAX(itc_document_id)+1 FROM itc_investigations.itc_investigation_documents INTO p_document_id;


	INSERT INTO itc_investigations.itc_investigation_documents (investigation_id, itc_document_id, document_title, document_date, official_received_date, document_type)
			 SELECT p_investigation_id, p_document_id, p_title , p_document_date, p_official_received_date, p_document_type
			 WHERE NOT EXISTS (SELECT 1 FROM itc_investigations.itc_investigation_documents WHERE investigation_id = p_investigation_id AND itc_document_id = p_document_id)
			 RETURNING ID INTO i_source_pk_val;
	
	INSERT INTO itc_investigations.itc_investigation_attachments (id, document_id, itc_attachment_id, s3_document_path)
			SELECT nextval('itc_investigations.itc_investigation_attachments_id_seq'::regclass), i_source_pk_val, 500000+nextval('itc_investigations.itc_investigation_attachments_id_seq'::regclass), 'rpx-itc/documents/337-TA-936_571312_1054655.pdf';
			 
	IF i_source_pk_val IS NULL THEN
		RAISE EXCEPTION 'DATA ERROR: Duplicate records found in itc_investigations.itc_investigation_documents table';
	END IF;
	
		UPDATE itc_investigations_audit.itc_investigation_documents_aud
		SET user_name = 'itc_etl_app'
		WHERE _id = i_source_pk_val and action = 'I';
	
	RETURN 1;


	EXCEPTION
	    WHEN OTHERS THEN
	        RAISE;
END;
$$;


--
-- Name: alerts_testing_load_itc_investigation_parties_for_events(integer, character varying, character varying, integer, date, date); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION alerts_testing_load_itc_investigation_parties_for_events(p_alias_id integer, p_event_type character varying, p_investigation_number character varying DEFAULT NULL::character varying, p_investigation_id integer DEFAULT NULL::integer, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
d_start_date date;
d_end_date date;
i_source_pk_val integer:=NULL;

BEGIN
/*
	1.0 spasunkili_c 20-May-2016 DS-3670 Alerts Events Capture restructure

  select * from core.alerts_testing_load_itc_investigation_parties_for_events(
			p_investigation_id := '333-TEST-003', 
			p_alias_id := 172744, 
			p_event_type := 'Complainant Added');

  select * from core.alerts_testing_load_itc_investigation_parties_for_events(
   		p_investigation_number := '333-TEST-003', 
   		p_alias_id := 172744, 
   		p_event_type := 'Complainant Terminated', 
   		p_end_date := '2016-05-31'::DATE) --IF not given current date will be taken

  select * from core.alerts_testing_load_itc_investigation_parties_for_events(
			p_investigation_id := '333-TEST-003', 
			p_alias_id := 6617494, 
			p_event_type := 'Respondent Added');

  select * from core.alerts_testing_load_itc_investigation_parties_for_events(
  	 	p_investigation_number := '333-TEST-003', 
   		p_alias_id := 6617494, 
   		p_event_type := 'Respondent Terminated',
   		p_end_date := '2016-05-31'::DATE) --IF not given current date will be taken
*/

IF ((p_investigation_number IS NOT NULL OR p_investigation_number <> '') AND (p_investigation_id IS NULL)) THEN
	SELECT ID INTO p_investigation_id FROM itc_investigations.itc_investigations WHERE investigation_number = p_investigation_number;
	IF p_investigation_id IS NULL THEN 
	RAISE EXCEPTION 'Invalid Input: ITC case not exists';
	END IF;
ELSIF p_investigation_number IS NULL AND p_investigation_id IS NULL THEN
	RAISE EXCEPTION 'Invalid Input: Investigation number/investigation_id cannot be NULL or Empty';
END IF;


IF (p_event_type IS NULL OR p_event_type = '') THEN 
	RAISE EXCEPTION 'Invalid Input: Event type cannot be NULL or Empty';
	
ELSIF (p_event_type ~ 'Added') THEN
	d_start_date := COALESCE(p_start_date,current_date::date);
	d_end_date := p_end_date;
	
	IF p_event_type ~ 'Respondent' THEN
	
		INSERT INTO  itc_investigations.itc_respondent (investigation_id, respondent_party_alias_id, respondent_active_date, respondent_inactive_date)
			 SELECT p_investigation_id, p_alias_id, d_start_date, d_end_date
			 WHERE NOT EXISTS (SELECT 1 FROM itc_investigations.itc_respondent WHERE investigation_id=p_investigation_id AND respondent_party_alias_id = p_alias_id)
			 RETURNING ID INTO i_source_pk_val;
			 
		IF i_source_pk_val IS NULL THEN
			RAISE EXCEPTION 'DATA ERROR: The input party alias is already exists for the litigation';
		END IF;
	
	
			UPDATE itc_investigations_audit.itc_respondent_aud
			SET user_name = 'itc_etl_app'
			where _id= i_source_pk_val and action = 'I';

	
	ELSIF p_event_type ~ 'Complainant' THEN
			
		INSERT INTO  itc_investigations.itc_complainant (investigation_id, complainant_party_alias_id, complainant_active_date, complainant_inactive_date)
			 SELECT p_investigation_id, p_alias_id, d_start_date, d_end_date
			 WHERE NOT EXISTS (SELECT 1 FROM itc_investigations.itc_complainant WHERE investigation_id=p_investigation_id AND complainant_party_alias_id = p_alias_id)
			 RETURNING ID INTO i_source_pk_val;
			 
		IF i_source_pk_val IS NULL THEN
			RAISE EXCEPTION 'DATA ERROR: The input party alias is already exists for the litigation';
		END IF;
	
			UPDATE itc_investigations_audit.itc_complainant_aud
			SET user_name = 'itc_etl_app'
			where _id= i_source_pk_val and action = 'I';
		
	END IF;

ELSIF (p_event_type ~ 'Terminated') THEN
	d_end_date := COALESCE(p_end_date,current_date::date);
	d_start_date := p_start_date;
	
	IF p_event_type ~ 'Respondent' THEN

		UPDATE itc_investigations.itc_respondent
		SET respondent_inactive_date =  d_end_date
		WHERE investigation_id =  p_investigation_id  AND respondent_party_alias_id = p_alias_id 
		RETURNING ID INTO i_source_pk_val;
	
		UPDATE itc_investigations_audit.itc_respondent_aud
		SET user_name = 'itc_etl_app'
		where _id= i_source_pk_val and action = 'U' and __respondent_inactive_date;
	
	ELSIF p_event_type ~ 'Complainant' THEN

		UPDATE itc_investigations.itc_complainant
		SET complainant_inactive_date =  d_end_date
		WHERE investigation_id =  p_investigation_id  AND complainant_party_alias_id = p_alias_id 
		RETURNING ID INTO i_source_pk_val;
	
		
		UPDATE itc_investigations_audit.itc_complainant_aud
		SET user_name = 'itc_etl_app'
		where _id= i_source_pk_val and action = 'U' and __complainant_inactive_date;

	END IF;
	
	
END IF;

	EXCEPTION
	    WHEN OTHERS THEN
	        RAISE;
END;
$$;


--
-- Name: alerts_testing_load_itc_investigations_for_events(character varying, character varying, date, date, character varying, integer, integer, character varying, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION alerts_testing_load_itc_investigations_for_events(p_investigation_number character varying, p_event_type character varying, p_complaint_filed_date date DEFAULT (now())::date, p_termination_date date DEFAULT NULL::date, p_title character varying DEFAULT NULL::character varying, p_complainant_alias_id integer DEFAULT NULL::integer, p_respondent_alias_id integer DEFAULT NULL::integer, p_patnum character varying DEFAULT NULL::character varying, p_document_id integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
i_source_pk_val integer;
i_pat_pk_val integer;
i_campaign_id integer;

BEGIN
/*
	1.0 spasunkili_c 23-May-2016  DS-3670 Alerts Events Capture restructure
	
	select * from core.alerts_testing_load_itc_investigations_for_events(p_investigation_number:='333-TEST-003'
		,p_event_type:='ITC Investigation Filed'
		,p_complainant_alias_id:='172744'
		,p_respondent_alias_id:='6617494'
		,p_patnum:='US3457470A1')
		
	
*/


IF (p_event_type IS NULL OR p_event_type = '') THEN 
	RAISE EXCEPTION 'Invalid Input: Event type cannot be NULL or Empty';
	
ELSIF (p_event_type ~ 'Filed') THEN
	
	INSERT INTO itc_investigations.itc_investigations (investigation_number, investigation_title, complaint_filed_date)
			 SELECT p_investigation_number,  COALESCE(p_title,'Case Title For '||p_investigation_number), p_complaint_filed_date
			 			 RETURNING ID INTO i_source_pk_val;
						 
	UPDATE itc_investigations_audit.itc_investigations_aud
	SET user_name = 'itc_etl_app'	
	WHERE _id= i_source_pk_val AND action = 'I';
	
	IF p_complainant_alias_id IS NOT NULL THEN
		PERFORM core.alerts_testing_load_itc_investigation_parties_for_events(
			p_investigation_id := i_source_pk_val, 
			p_alias_id := p_complainant_alias_id, 
			p_event_type := 'Complainant Added', 
			p_start_date := p_complaint_filed_date,
			p_end_date := p_termination_date);
	END IF;
	
	IF p_respondent_alias_id IS NOT NULL THEN
		PERFORM core.alerts_testing_load_itc_investigation_parties_for_events(
			p_investigation_id := i_source_pk_val, 
			p_alias_id := p_respondent_alias_id, 
			p_event_type := 'Respondent Added', 
			p_start_date := p_complaint_filed_date,
			p_end_date := p_termination_date);
	END IF;	

	if p_patnum IS NOT NULL THEN
		PERFORM core.alerts_testing_load_itc_patent_numbers_for_events(
			p_investigation_id := i_source_pk_val,
			p_patnum := p_patnum,
			p_patent_number_active_date := p_complaint_filed_date);
	END IF;
	
	IF p_document_id IS NOT NULL THEN
		PERFORM core.alerts_testing_load_itc_docket_entries_for_events(
			p_document_id:=p_document_id,
			p_investigation_id:=i_source_pk_val,
			p_document_type:='Complaint'
		);
	END IF;
	
	DROP TABLE IF EXISTS temp_campaign_metrics ;
	
	select lit_campaigns.find_or_create_campaign_for_itc(i_source_pk_val) into i_campaign_id;
	
	RETURN 1;
	
ELSIF (p_event_type ~ 'Closed') THEN

	if p_termination_date is null then
		p_termination_date = NOW();
	end if;
	
	UPDATE itc_investigations.itc_investigations
	SET termination_date = p_termination_date
	WHERE investigation_number =  p_investigation_number
	 RETURNING ID INTO i_source_pk_val;
	
	UPDATE itc_investigations_audit.itc_investigations_aud
	SET user_name = 'itc_etl_app'
	where _id= i_source_pk_val and action = 'U' and  __termination_date;

	RETURN 1;
	
END IF;


	EXCEPTION
	    WHEN OTHERS THEN
	        RAISE;
END;
$$;


--
-- Name: alerts_testing_load_itc_judges_for_events(integer, character varying, character varying, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION alerts_testing_load_itc_judges_for_events(p_alias_id integer, p_event_type character varying, p_investigation_number character varying DEFAULT NULL::character varying, p_investigation_id integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
i_source_pk_val integer;
b_alj_assigned_active boolean := True;

BEGIN
/*
	1.0 spasunkili_c 20-May-2015 DS-3670 Alerts Events Capture restructure
	
	select * from core.alerts_testing_load_itc_judges_for_events(p_alias_id:=320
		,p_event_type:='Judge Added'
		,p_investigation_id:=1023)
	
	select * from core.alerts_testing_load_itc_judges_for_events(p_alias_id:=320
		,p_event_type:='Judge Terminated'
		,p_investigation_id:=1022)
		
*/

IF ((p_investigation_number IS NOT NULL OR p_investigation_number <> '') AND (p_investigation_id IS NULL)) THEN
	SELECT ID INTO p_investigation_id FROM itc_investigations.itc_investigations WHERE investigation_number = p_investigation_number;
	IF p_investigation_id IS NULL THEN 
	RAISE EXCEPTION 'Invalid Input: investigation_number not exists';
	END IF;
ELSIF p_investigation_number IS NULL AND p_investigation_id IS NULL THEN
	RAISE EXCEPTION 'Invalid Input: investigation_number/investigation_id cannot be NULL or Empty';
END IF;

IF (p_event_type IS NULL OR p_event_type = '') THEN 
	RAISE EXCEPTION 'Invalid Input: Event type cannot be NULL or Empty';
	
ELSIF (p_event_type ~ 'Added') THEN
	
	INSERT INTO itc_investigations.itc_alj_assigned (investigation_id, alj_assigned_alias_id, alj_assigned_active)
			 SELECT p_investigation_id, p_alias_id, b_alj_assigned_active
			 			 RETURNING ID INTO i_source_pk_val;
	
	UPDATE itc_investigations_audit.itc_alj_assigned_aud
	SET user_name = 'itc_etl_app'
	where _id= i_source_pk_val and action = 'I';

	RETURN 1;

ELSIF (p_event_type ~ 'Terminated') THEN

	UPDATE itc_investigations.itc_alj_assigned
	SET alj_assigned_active =  false
	WHERE investigation_id =  p_investigation_id  AND alj_assigned_alias_id = p_alias_id 
	RETURNING ID INTO i_source_pk_val;
	
	UPDATE itc_investigations_audit.itc_alj_assigned_aud
	SET user_name = 'itc_etl_app'
	where _id= i_source_pk_val and action = 'U' and  __alj_assigned_active;

	RETURN 1;
END IF;


	EXCEPTION
	    WHEN OTHERS THEN
	        RAISE;
END;
$$;


--
-- Name: alerts_testing_load_itc_patent_numbers_for_events(character varying, character varying, integer, date); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION alerts_testing_load_itc_patent_numbers_for_events(p_patnum character varying, p_investigation_number character varying DEFAULT NULL::character varying, p_investigation_id integer DEFAULT NULL::integer, p_patent_number_active_date date DEFAULT (now())::date) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
i_source_pk_val integer:=NULL;
p_stripped_patnum character varying:= NULL;

BEGIN
/*
	1.0 spasunkili_c 23-May-2016  DS-3670 Alerts Events Capture restructure
	select * from core.alerts_testing_itc_patent_numbers_for_events(
			p_investigation_id := '333-TEST-003',
			p_patnum := 'US3457470A1');
*/
IF ((p_investigation_number IS NOT NULL OR p_investigation_number <> '') AND (p_investigation_id IS NULL)) THEN
	SELECT ID INTO p_investigation_id FROM itc_investigations.itc_investigations WHERE investigation_number = p_investigation_number;
	IF p_investigation_id IS NULL THEN 
	RAISE EXCEPTION 'Invalid Input: investigation_id not exists';
	END IF;
ELSIF p_investigation_number IS NULL AND p_investigation_id IS NULL THEN
	RAISE EXCEPTION 'Invalid Input: investigation_number/investigation_id cannot be NULL or Empty';
END IF;

	IF p_patnum is not null then 
		SELECT stripped_patnum into p_stripped_patnum from core.pats where patnum = p_patnum;
	ELSIF p_patnum is null then
		RAISE EXCEPTION 'Patnum cannot be null';
	END IF;

	INSERT INTO itc_investigations.itc_patent_numbers (investigation_id, patent_number, patent_number_active_date)
			 SELECT p_investigation_id, p_stripped_patnum, p_patent_number_active_date
			 WHERE NOT EXISTS (SELECT 1 FROM itc_investigations.itc_patent_numbers WHERE investigation_id = p_investigation_id AND patent_number = p_patnum)
			 RETURNING ID INTO i_source_pk_val;
			 
	IF i_source_pk_val IS NULL THEN
		RAISE EXCEPTION 'DATA ERROR: Duplicate records found in itc_investigations.itc_investigations_documents table';
	END IF;
	
	UPDATE itc_investigations_audit.itc_patent_numbers_aud
	SET user_name = 'itc_etl_app'
	where _id= i_source_pk_val and action = 'I';
	
	RETURN 1;


	EXCEPTION
	    WHEN OTHERS THEN
	        RAISE;
END;
$$;


--
-- Name: alerts_testing_load_itc_status_for_events(character varying, integer, character varying, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION alerts_testing_load_itc_status_for_events(p_investigation_status character varying, p_document_id integer DEFAULT NULL::integer, p_investigation_number character varying DEFAULT NULL::character varying, p_investigation_id integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
i_source_pk_val integer;

BEGIN
/*
	1.0 spasunkili_c 23-May-2016  DS-3670 Alerts Events Capture restructure

	select * from  core.alerts_testing_load_itc_status_for_events(p_investigation_number:= '333-TEST-003', p_investigation_status:='Pending');

*/
IF ((p_investigation_number IS NOT NULL OR p_investigation_number <> '') AND (p_investigation_id IS NULL)) THEN
	SELECT ID INTO p_investigation_id FROM itc_investigations.itc_investigations WHERE investigation_number = p_investigation_number;
	IF p_investigation_id IS NULL THEN 
	RAISE EXCEPTION 'Invalid Input: Investigation number not exists';
	END IF;
ELSIF p_investigation_number IS NULL AND p_investigation_id IS NULL THEN
	RAISE EXCEPTION 'Invalid Input: Investigation number/Investigation id cannot be NULL or Empty';
END IF;


	UPDATE itc_investigations.itc_investigations
	SET investigation_status =  p_investigation_status
	WHERE id =  p_investigation_id
	RETURNING ID INTO i_source_pk_val;
	
	IF p_document_id IS NOT NULL THEN
		PERFORM core.alerts_testing_load_itc_docket_entries_for_events(
			p_document_id:=p_document_id,
			p_investigation_id:=i_source_pk_val
		);
	END IF;
	
		UPDATE itc_investigations_audit.itc_investigations_aud
		SET user_name = 'itc_etl_app'
		WHERE _id = i_source_pk_val and action = 'U' and  __investigation_status;
	
	RETURN 1;


	EXCEPTION
	    WHEN OTHERS THEN
	        RAISE;
END;
$$;


--
-- Name: alerts_testing_load_lit_docket_entries_for_events(character varying, character varying, integer, date, character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION alerts_testing_load_lit_docket_entries_for_events(p_docketx_id character varying, p_case_key character varying DEFAULT NULL::character varying, p_lit_id integer DEFAULT NULL::integer, p_date_filed date DEFAULT (now())::date, p_docket_text character varying DEFAULT 'Test Document Added'::character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
	i_source_pk_val integer:=NULL;
	i_row_number integer;

	BEGIN
	/*
		1.0 aprakash_c 26-Nov-2015  DS-2860: New API created
		1.1 aprakash_c 07-Dec-2015 DS-2891: added case_key as input param

		Sample Executions:
		select * from core.alerts_testing_load_lit_docket_entries_for_events(p_case_key:='ordce-120544', p_docketx_id:='test docket', p_date_filed:= current_date, p_force_aud_update:=true);
	*/
	IF ((p_case_key IS NOT NULL OR p_case_key <> '') AND (p_lit_id IS NULL)) THEN
		SELECT ID INTO p_lit_id FROM core.lits WHERE case_key = p_case_key;
		IF p_lit_id IS NULL THEN
		RAISE EXCEPTION 'Invalid Input: case key not exists';
		END IF;
	ELSIF p_case_key IS NULL AND p_lit_id IS NULL THEN
		RAISE EXCEPTION 'Invalid Input: case key/lit_id cannot be NULL or Empty';
	END IF;

		select (count(*)+1) into i_row_number from core.docket_entries where lit_id = p_lit_id;
		INSERT INTO core.docket_entries (lit_id, docketx_id, docket_text, date_filed, entry_number, row_number)
				 SELECT p_lit_id, p_docketx_id, p_docket_text, p_date_filed, COALESCE(i_row_number,1),COALESCE(i_row_number,1)
				 WHERE NOT EXISTS (SELECT 1 FROM core.docket_entries WHERE lit_id = p_lit_id AND docketx_id = p_docketx_id AND date_filed = p_date_filed)
				 RETURNING ID INTO i_source_pk_val;

		INSERT INTO core.docket_entry_documents_map (docket_entry_id,lit_document_id,is_main,created_at,updated_at)
				 SELECT i_source_pk_val, 11488035, TRUE, now()::TIMESTAMP, now()::TIMESTAMP;

		INSERT INTO core.docket_entry_documents_map (docket_entry_id,lit_document_id,is_main,created_at,updated_at)
				 SELECT i_source_pk_val, 11488038, FALSE, now()::TIMESTAMP, now()::TIMESTAMP;

		IF i_source_pk_val IS NULL THEN
			RAISE EXCEPTION 'DATA ERROR: Duplicate records found in core.docket_entries table';
		END IF;

		UPDATE core_audit.docket_entries_aud
		SET user_name = 'pacer_data_service'
		where _id= i_source_pk_val and action = 'I';

		RETURN 1;


		EXCEPTION
		    WHEN OTHERS THEN
		        RAISE;
	END;
	$$;


--
-- Name: alerts_testing_load_lit_judges_for_events(integer, character varying, character varying, integer, date, date); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION alerts_testing_load_lit_judges_for_events(p_alias_id integer, p_event_type character varying, p_case_key character varying DEFAULT NULL::character varying, p_lit_id integer DEFAULT NULL::integer, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
d_start_date date;
d_end_date date;
i_assignment_type_id integer := 2;
c_assignment_role_as_filed  character varying := 'Judge';
i_source_pk_val integer;

BEGIN
/*
	1.0 aprakash_c 26-Nov-2015  DS-2860: New API created
	1.1 aprakash_c 07-Dec-2015 DS-2891: added case_key as input param
	
	Sample Executions:
	select * from core.alerts_testing_load_lit_judges_for_events(p_case_key:='ilndce-305090', p_alias_id:=621, p_event_type:='Judge Added', p_start_date:=NULL, p_end_date:=NULL);
	select * from core.alerts_testing_load_lit_judges_for_events(p_case_key:='ilndce-305090', p_alias_id:=621, p_event_type:='Judge Terminated');
*/

IF ((p_case_key IS NOT NULL OR p_case_key <> '') AND (p_lit_id IS NULL)) THEN
	SELECT ID INTO p_lit_id FROM core.lits WHERE case_key = p_case_key;
	IF p_lit_id IS NULL THEN 
	RAISE EXCEPTION 'Invalid Input: case key not exists';
	END IF;
ELSIF p_case_key IS NULL AND p_lit_id IS NULL THEN
	RAISE EXCEPTION 'Invalid Input: case key/lit_id cannot be NULL or Empty';
END IF;

IF (p_event_type IS NULL OR p_event_type = '') THEN 
	RAISE EXCEPTION 'Invalid Input: Event type cannot be NULL or Empty';
	
ELSIF (p_event_type ~ 'Added') THEN
	d_start_date := COALESCE(p_start_date,current_date::date);
	d_end_date := p_end_date;
	
	INSERT INTO core.lit_judges_map (lit_id, alias_id, start_date, end_date, assignment_type_id, assignment_role_as_filed)
			 SELECT p_lit_id, p_alias_id, d_start_date, d_end_date, i_assignment_type_id, c_assignment_role_as_filed
			 			 RETURNING ID INTO i_source_pk_val;
	
	UPDATE core_audit.lit_judges_map_aud
	SET user_name = 'pacer_data_service'
	where _id= i_source_pk_val and action = 'I';
	
	RETURN 1;

ELSIF (p_event_type ~ 'Terminated') THEN
	d_end_date := COALESCE(p_end_date,current_date::date);
	d_start_date := p_start_date;
	

	UPDATE core.lit_judges_map
	SET end_date =  d_end_date
	WHERE lit_id =  p_lit_id  AND alias_id = p_alias_id AND assignment_type_id = i_assignment_type_id AND assignment_role_as_filed = c_assignment_role_as_filed AND start_date = d_start_date
	 RETURNING ID INTO i_source_pk_val;
	
	UPDATE core_audit.lit_judges_map_aud
	SET user_name = 'pacer_data_service'
	where _id= i_source_pk_val and action = 'U' and  __end_date;
	
	RETURN 1;
END IF;


	EXCEPTION
	    WHEN OTHERS THEN
	        RAISE;
END;
$$;


--
-- Name: alerts_testing_load_lit_lawyer_for_events(character varying, integer, integer, integer, character varying, integer, date, date); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION alerts_testing_load_lit_lawyer_for_events(p_case_key character varying, p_party_alias_id integer, p_lawyer_alias_id integer, p_lawfirm_alias_id integer, p_event_type character varying, p_lit_parties_id integer DEFAULT NULL::integer, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
d_start_date date;
d_end_date date;
i_source_pk_val integer:=NULL;

BEGIN
/*
	1.0 aprakash_c 26-Nov-2015  DS-2860: New API created
	1.1 aprakash_c 07-Dec-2015 DS-2891: added case_key as input param
	
	Sample Executions:
	select * from core.alerts_testing_load_lit_lawyer_for_events(p_case_key:='cacdce-608091', p_party_alias_id:=10369106, p_lawyer_alias_id:=52069, p_lawfirm_alias_id:= 16064, p_event_type:='Lawyer Added', p_start_date:=NULL, p_end_date:=NULL);
	select * from core.alerts_testing_load_lit_lawyer_for_events(p_case_key:='cacdce-608091', p_party_alias_id:=10369106, p_lawyer_alias_id:=52069, p_lawfirm_alias_id:= 16064, p_event_type:='Lawyer Terminated');
*/

IF (p_case_key IS NOT NULL OR p_case_key <> '') OR (p_party_alias_id IS NOT NULL) THEN
	SELECT lp. ID INTO p_lit_parties_id FROM core.lit_parties lp INNER JOIN core.lits ON lits. ID = lp.lit_id WHERE lits.case_key = p_case_key AND lp.alias_id = p_party_alias_id;
	IF p_lit_parties_id IS NULL THEN 
	RAISE EXCEPTION 'Invalid Input: lit party not exists';
	END IF;
ELSE
	RAISE EXCEPTION 'Invalid Input: case key/party alias id cannot be NULL or Empty';
END IF;

IF (p_event_type IS NULL OR p_event_type = '') THEN 
	RAISE EXCEPTION 'Invalid Input: Event type cannot be NULL or Empty';
	
ELSIF (p_event_type ~ 'Added') THEN
	d_start_date := COALESCE(p_start_date,current_date::date);
	d_end_date := p_end_date;
	
	INSERT INTO core.lit_parties_representations (lit_parties_id, lawyer_alias_id, lawfirm_alias_id, start_date, end_date)
			 SELECT p_lit_parties_id, p_lawyer_alias_id, p_lawfirm_alias_id, d_start_date, d_end_date
			 WHERE NOT EXISTS (SELECT 1 FROM core.lit_parties_representations WHERE lit_parties_id = p_lit_parties_id AND lawfirm_alias_id = p_lawfirm_alias_id AND lawyer_alias_id = p_lawyer_alias_id AND start_date = d_start_date AND end_date = d_end_date)
			 RETURNING ID INTO i_source_pk_val;
	
	IF i_source_pk_val IS NULL THEN
		RAISE EXCEPTION 'DATA ERROR: Duplicate records found in core.lit_parties_representations table';
	END IF;
	
	UPDATE core_audit.lit_parties_representations_aud
	SET user_name = 'pacer_data_service'
	where _id= i_source_pk_val and action = 'I';
	
	RETURN 1;

ELSIF (p_event_type ~ 'Terminated') THEN
	d_end_date := COALESCE(p_end_date,current_date::date);
	d_start_date := p_start_date;
	

	UPDATE core.lit_parties_representations
	SET end_date =  d_end_date
	WHERE lit_parties_id =  p_lit_parties_id  AND lawyer_alias_id = p_lawyer_alias_id AND lawfirm_alias_id = p_lawfirm_alias_id 
	RETURNING ID INTO i_source_pk_val;
	
	UPDATE core_audit.lit_parties_representations_aud
	SET user_name = 'pacer_data_service'
	where _id= i_source_pk_val and action = 'U' and __end_date;
	
	RETURN 1;

END IF;


	EXCEPTION
	    WHEN OTHERS THEN
	        RAISE;
END;
$$;


--
-- Name: alerts_testing_load_lit_parties_for_events(integer, character varying, character varying, integer, date, date); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION alerts_testing_load_lit_parties_for_events(p_alias_id integer, p_event_type character varying, p_case_key character varying DEFAULT NULL::character varying, p_lit_id integer DEFAULT NULL::integer, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
d_start_date date;
d_end_date date;
i_lit_party_type_id integer;
c_dj_party_normalized_type character varying;
i_source_pk_val integer:=NULL;

BEGIN
/*
	1.0 aprakash_c 26-Nov-2015  DS-2860: New API created
	1.1 aprakash_c 07-Dec-2015 DS-2891: added case_key as input param
	
	Sample Executions:
	select * from core.alerts_testing_load_lit_parties_for_events(p_case_key:='cacdce-608091', p_alias_id:=98980, p_event_type:='Defendant Added', p_start_date:=NULL, p_end_date:=NULL);
	select * from core.alerts_testing_load_lit_parties_for_events(p_case_key:='cacdce-608091', p_alias_id:=98980, p_event_type:='Defendant Terminated', p_start_date:=NULL, p_end_date:=NULL);
	select * from core.alerts_testing_load_lit_parties_for_events(p_case_key:='cacdce-608091', p_alias_id:=113964, p_event_type:='Plaintiff Added', p_start_date:=NULL, p_end_date:=NULL);
	select * from core.alerts_testing_load_lit_parties_for_events(p_case_key:='cacdce-608091', p_alias_id:=113964, p_event_type:='Plaintiff Terminated', p_start_date:=NULL, p_end_date:=NULL);
	select * from core.alerts_testing_load_lit_parties_for_events(p_case_key:='cacdce-608091', p_alias_id:=12608934, p_event_type:='Defendant Added', p_start_date:=NULL, p_end_date:=NULL);
	select * from core.alerts_testing_load_lit_parties_for_events(p_case_key:='cacdce-608091', p_alias_id:=12608934, p_event_type:='Defendant Terminated', p_start_date:=NULL, p_end_date:=NULL);
*/
IF ((p_case_key IS NOT NULL OR p_case_key <> '') AND (p_lit_id IS NULL)) THEN
	SELECT ID INTO p_lit_id FROM core.lits WHERE case_key = p_case_key;
	IF p_lit_id IS NULL THEN 
	RAISE EXCEPTION 'Invalid Input: case key not exists';
	END IF;
ELSIF p_case_key IS NULL AND p_lit_id IS NULL THEN
	RAISE EXCEPTION 'Invalid Input: case key/lit_id cannot be NULL or Empty';
END IF;

IF p_event_type ~ 'Defendant' THEN
	i_lit_party_type_id = 74;
	c_dj_party_normalized_type = 'defendant';
ELSIF p_event_type ~ 'Plaintiff' THEN
	i_lit_party_type_id = 75;
	c_dj_party_normalized_type = 'plaintiff';
END IF;

IF (p_event_type IS NULL OR p_event_type = '') THEN 
	RAISE EXCEPTION 'Invalid Input: Event type cannot be NULL or Empty';
	
ELSIF (p_event_type ~ 'Added') THEN
	d_start_date := COALESCE(p_start_date,current_date::date);
	d_end_date := p_end_date;
	
	INSERT INTO core.lit_parties (lit_id, alias_id, start_date, end_date, lit_party_type_id, dj_party_normalized_type)
			 SELECT p_lit_id, p_alias_id, d_start_date, d_end_date, i_lit_party_type_id, c_dj_party_normalized_type 
			 WHERE NOT EXISTS (SELECT 1 FROM core.lit_parties WHERE lit_id=p_lit_id AND alias_id = p_alias_id AND lit_party_type_id = i_lit_party_type_id AND dj_party_normalized_type = c_dj_party_normalized_type)
			 RETURNING ID INTO i_source_pk_val;
			 
	IF i_source_pk_val IS NULL THEN
		RAISE EXCEPTION 'DATA ERROR: The input party alias is already exists for the litigation';
	END IF;
	
		UPDATE core_audit.lit_parties_aud
		SET user_name = 'pacer_data_service'
		where _id= i_source_pk_val and action = 'I';

	RETURN 1;

ELSIF (p_event_type ~ 'Terminated') THEN
	d_end_date := COALESCE(p_end_date,current_date::date);
	d_start_date := p_start_date;
	

	UPDATE core.lit_parties
	SET end_date =  d_end_date
	WHERE lit_id =  p_lit_id  AND alias_id = p_alias_id AND lit_party_type_id = i_lit_party_type_id  AND dj_party_normalized_type = c_dj_party_normalized_type RETURNING ID INTO i_source_pk_val;
	
	
		UPDATE core_audit.lit_parties_aud
		SET user_name = 'pacer_data_service'
		where _id= i_source_pk_val and action = 'U' and __end_date;
	
	RETURN 1;
END IF;


	EXCEPTION
	    WHEN OTHERS THEN
	        RAISE;
END;
$$;


--
-- Name: alerts_testing_load_lit_patents_for_events(character varying, character varying, integer, date, date); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION alerts_testing_load_lit_patents_for_events(p_patnum character varying, p_case_key character varying DEFAULT NULL::character varying, p_lit_id integer DEFAULT NULL::integer, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
i_source_pk_val integer:=NULL;
p_stripped_patnum character varying:=NULL;
p_filed_date DATE:=NULL;

BEGIN
/*
	1.0 spasunkili_c 23-May-2016  DS-3670 Alerts Events Capture restructure
	select * from core.alerts_testing_load_lit_patents_for_events(p_case_key:='dedce-59463',p_patnum:='US3457470A1')
*/
IF ((p_case_key IS NOT NULL OR p_case_key <> '') AND (p_lit_id IS NULL)) THEN
	SELECT ID INTO p_lit_id FROM core.lits WHERE case_key = p_case_key;
	IF p_lit_id IS NULL THEN 
	RAISE EXCEPTION 'Invalid Input: case key not exists';
	END IF;
ELSIF p_case_key IS NULL AND p_lit_id IS NULL THEN
	RAISE EXCEPTION 'Invalid Input: case key/lit_id cannot be NULL or Empty';
END IF;

	SELECT filed_date into p_filed_date from core.lits where id = p_lit_id;
	
	p_start_date:=p_filed_date-14;

	IF p_patnum is not null then 
		SELECT stripped_patnum into p_stripped_patnum from core.pats where patnum = p_patnum;
	ELSIF p_patnum is null then
		RAISE EXCEPTION 'Patnum cannot be null';
	END IF;

	INSERT INTO core.lits_pats_map (patnum, lit_id, start_date, end_date, created_by )
			 SELECT p_stripped_patnum,p_lit_id, p_start_date, p_end_date, 'docs_app'
			 WHERE NOT EXISTS (SELECT 1 FROM core.lits_pats_map WHERE lit_id = p_lit_id AND patnum = p_patnum AND start_date = p_start_date AND end_date = p_end_date)
			 RETURNING ID INTO i_source_pk_val;
			 
	IF i_source_pk_val IS NULL THEN
		RAISE EXCEPTION 'DATA ERROR: Duplicate records found in core.lits_pats_map table';
	END IF;
	

	UPDATE core_audit.lits_pats_map_aud
	SET user_name = 'pacer_data_service'
	where _id= i_source_pk_val and action = 'I';
	
	RETURN 1;


	EXCEPTION
	    WHEN OTHERS THEN
	        RAISE;
END;
$$;


--
-- Name: alerts_testing_load_lit_relationship_for_events(integer, character varying, character varying, integer, integer, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION alerts_testing_load_lit_relationship_for_events(p_lit_relationship_type_id integer, p_from_case_key character varying DEFAULT NULL::character varying, p_to_case_key character varying DEFAULT NULL::character varying, p_from_lit_id integer DEFAULT NULL::integer, p_to_lit_id integer DEFAULT NULL::integer, p_lit_family_id integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
i_source_pk_val integer;

BEGIN
/*
	1.0 aprakash_c 26-Nov-2015  DS-2860: New API created
	1.1 aprakash_c 07-Dec-2015 DS-2891: added case_key as input param
	
	Sample Executions:
	select * from core.alerts_testing_load_lit_relationship_for_events(p_from_case_key:='dedce-56301', p_to_case_key:='txedce-106578', p_lit_relationship_type_id:= 2, p_lit_family_id:=51772);
*/
IF ((p_from_case_key IS NOT NULL OR p_from_case_key <> '') AND (p_from_lit_id IS NULL)) THEN
	SELECT ID INTO p_from_lit_id FROM core.lits WHERE case_key = p_from_case_key;
	IF p_from_lit_id IS NULL THEN 
	RAISE EXCEPTION 'Invalid Input: case key in p_from_case_key param not exists';
	END IF;
ELSIF (p_from_case_key IS NULL AND p_from_lit_id IS NULL) THEN
	RAISE EXCEPTION 'Invalid Input: case key/lit_id cannot be NULL or Empty';
END IF;

IF ((p_to_case_key IS NOT NULL OR p_to_case_key <> '') AND (p_to_lit_id IS NULL)) THEN
	SELECT ID INTO p_to_lit_id FROM core.lits WHERE case_key = p_to_case_key;
	IF p_to_lit_id IS NULL THEN 
	RAISE EXCEPTION 'Invalid Input: case key in p_to_case_key param not exists';
	END IF;
ELSIF (p_to_case_key IS NULL AND p_to_lit_id IS NULL) THEN
	RAISE EXCEPTION 'Invalid Input: case key/lit_id cannot be NULL or Empty';
END IF;

	INSERT INTO core.lit_relationships (from_lit_id, to_lit_id, lit_relationship_type_id, lit_family_id)
			 SELECT p_from_lit_id, p_to_lit_id, p_lit_relationship_type_id, p_lit_family_id 
			 RETURNING ID INTO i_source_pk_val;
	
	UPDATE core_audit.lit_relationships_aud
	SET user_name = 'pacer_data_service'
	where _id= i_source_pk_val and action = 'I';
	
	RETURN 1;


	EXCEPTION
	    WHEN OTHERS THEN
	        RAISE;
END;
$$;


--
-- Name: alerts_testing_load_lits_for_events(character varying, character varying, date, date, character varying, integer, integer, integer, character varying, character varying, integer, integer, integer, boolean); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION alerts_testing_load_lits_for_events(p_case_key character varying, p_event_type character varying, p_filed_date date DEFAULT (now())::date, p_closed_date date DEFAULT NULL::date, p_title character varying DEFAULT NULL::character varying, p_nos integer DEFAULT 1, p_plaintiff_alias_id integer DEFAULT NULL::integer, p_defendant_alias_id integer DEFAULT NULL::integer, p_patent character varying DEFAULT NULL::character varying, p_docketx_id character varying DEFAULT NULL::character varying, p_lit_type integer DEFAULT 11, p_market_sector_type integer DEFAULT 9, p_lit_curated_cause_type integer DEFAULT 8, p_is_main boolean DEFAULT false) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
i_source_pk_val integer;
i_campaign_id integer;

BEGIN
/*
	1.0 aprakash_c 26-Nov-2015  DS-2860: New API created
	2.0 spasunkili_c 17-Jul-2017 Added docket_entry for closed event if docketx_id is given
	3.0 tazhagan_c 20-Jul-2017 : Remove lit_stage_id reference

	Sample Executions:
	select * from core.alerts_testing_load_lits_for_events(p_case_key:='testing', p_filed_date:=current_date, p_title:='testing', p_event_type:='New Case Filed');
	select * from core.alerts_testing_load_lits_for_events(p_case_key:='testing', p_filed_date:=current_date, p_title:='testing', p_event_type:='Case Closed',p_docketx_id:='Closed Lit');
*/


IF (p_event_type IS NULL OR p_event_type = '') THEN
	RAISE EXCEPTION 'Invalid Input: Event type cannot be NULL or Empty';

ELSIF (p_event_type ~ 'New') THEN

	INSERT INTO core.lits (case_key, filed_date, title, original_filed_date, nos, is_open,docket_info_id)
			 SELECT p_case_key, p_filed_date, COALESCE(p_title,'Case Title For '||p_case_key), p_filed_date, p_nos, true, 521165
			 			 RETURNING ID INTO i_source_pk_val;

	IF i_source_pk_val IS NOT NULL THEN
	--lit_annotations is being populated for lits with default values
		INSERT INTO core.lit_annotations (lit_id,lit_type_id,is_npe_suit,is_dj,updated_at,created_at,is_abandon,is_ncl_suit,lit_curated_cause_type_id,market_sector_type_id)
		SELECT i_source_pk_val,p_lit_type, FALSE, FALSE, now(), now(), FALSE, FALSE,p_lit_curated_cause_type,p_market_sector_type;
	END IF;

	--adding lit_courts entry to fetch values for court_short_name column in event_detail_json
		INSERT INTO core.lit_courts (lit_id, alias_id, updated_at, created_at)
			SELECT i_source_pk_val, 175326, now(), now();

	IF p_plaintiff_alias_id IS NOT NULL THEN
		PERFORM core.alerts_testing_load_lit_parties_for_events(
			p_lit_id := i_source_pk_val,
			p_alias_id := p_plaintiff_alias_id,
			p_event_type := 'Plaintiff Added',
			p_start_date := p_filed_date,
			p_end_date := p_closed_date);
	END IF;

	IF p_defendant_alias_id IS NOT NULL THEN
		PERFORM core.alerts_testing_load_lit_parties_for_events(
			p_lit_id := i_source_pk_val,
			p_alias_id := p_defendant_alias_id,
			p_event_type := 'Defendant Added',
			p_start_date := p_filed_date,
			p_end_date := p_closed_date);
	END IF;

	IF p_patent IS NOT NULL THEN
		PERFORM core.alerts_testing_load_lit_patents_for_events(
			p_lit_id:=i_source_pk_val,
			p_patnum:=p_patent);
	END IF;

	IF p_docketx_id IS NOT NULL THEN
		PERFORM core.alerts_testing_load_lit_docket_entries_for_events(
			p_docketx_id:=p_docketx_id,
			p_lit_id:=i_source_pk_val,
			p_is_main:=p_is_main
		);
	END IF;

	UPDATE core_audit.lits_aud
	SET user_name = 'pacer_data_service'
	where _id= i_source_pk_val and action = 'I';

	DROP TABLE IF EXISTS temp_campaign_metrics ;

	select lit_campaigns.find_or_create_campaign_id_for_lit(i_source_pk_val) into i_campaign_id;

	RETURN 1;

ELSIF (p_event_type ~ 'Closed') THEN

	UPDATE core.lits
	SET is_open =  FALSE,
		closed_date = p_closed_date
	WHERE case_key =  p_case_key
	 RETURNING ID INTO i_source_pk_val;

	IF p_docketx_id IS NOT NULL THEN
		PERFORM core.alerts_testing_load_lit_docket_entries_for_events(
			p_docketx_id:=p_docketx_id,
			p_lit_id:=i_source_pk_val,
			p_is_main:=p_is_main
		);
	END IF;

	UPDATE core_audit.lits_aud
	SET user_name = 'pacer_data_service'
	where _id= i_source_pk_val and action = 'U' and  __is_open;

	RETURN 1;
END IF;


	EXCEPTION
	    WHEN OTHERS THEN
	        RAISE;
END;
$$;


--
-- Name: alerts_testing_load_pat_current_assignee_for_events(integer, integer, character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION alerts_testing_load_pat_current_assignee_for_events(p_alias_id integer, p_pat_id integer DEFAULT NULL::integer, p_patnum character varying DEFAULT NULL::character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
i_source_pk_val integer:=NULL;
p_pat_stats_id integer:=NULL;
p_stripped_patnum character varying:=NULL;
BEGIN
/*
	1.0 spasunkili_c 23-May-2016  DS-3670 Alerts Events Capture restructure
	select * from alerts_testing_load_pat_current_assignee_for_events(p_patnum:='US20110050575A1', p_alias_id:=6617494)
*/
	IF (p_pat_id IS NOT NULL) THEN
		SELECT stripped_patnum into p_stripped_patnum from core.pats where id = p_pat_id;
		ELSIF ((p_patnum IS NOT NULL OR p_patnum <> '') AND (p_pat_id IS NULL)) THEN
			SELECT ID, stripped_patnum INTO p_pat_id, p_stripped_patnum FROM core.pats WHERE patnum = p_patnum ;
			IF p_pat_id IS NULL THEN 
				RAISE EXCEPTION 'Invalid Input: pat_id not exists or patent is not application true';
			END IF;
		ELSIF p_pat_id IS NULL AND p_patnum IS NULL THEN
			RAISE EXCEPTION 'Invalid Input: pat_id/patnum cannot be NULL or Empty';
	END IF;

	SELECT ID into p_pat_stats_id FROM core.pat_stats WHERE pat_id = p_pat_id;
	IF p_pat_stats_id IS NULL THEN
		INSERT INTO core.pat_stats(stripped_patnum)
			SELECT p_stripped_patnum 
			RETURNING ID INTO p_pat_stats_id;
	END IF;

	INSERT INTO core.pat_stats_current_assignees (pat_stats_id, alias_id)
		 SELECT p_pat_stats_id, p_alias_id
			WHERE NOT EXISTS (SELECT 1 FROM core.pat_stats_current_assignees WHERE pat_stats_id = p_pat_stats_id AND alias_id = p_alias_id)
		 RETURNING ID INTO i_source_pk_val;
				 
	IF i_source_pk_val IS NULL THEN
		RAISE EXCEPTION 'DATA ERROR: Duplicate records found in core.pat_stats_current_assignees table';
	END IF;
		

	UPDATE core_audit.pat_stats_current_assignees_aud
	SET user_name = 'pacer_data_service'
	where _id= i_source_pk_val and action = 'I';

	RETURN 1;


	EXCEPTION
	    WHEN OTHERS THEN
	        RAISE;
END;
$$;


--
-- Name: alerts_testing_load_patent_granted_for_events(character varying, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION alerts_testing_load_patent_granted_for_events(p_patnum character varying DEFAULT NULL::character varying, p_pat_id integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
i_source_pk_val integer:=NULL;
p_app_num_country character varying:=NULL;
p_invention_id integer:=NULL;
p_grant_pat_id integer:=NULL;


BEGIN
/*
	1.0 spasunkili_c 26-May-2016  DS-3670 Alerts Events Capture restructure
	 select * from core.alerts_testing_load_patent_granted_for_events(p_patnum:='US20110050575A1') - Give Only Application Patents
*/

/* Fetch parameters p_pat_id, p_app_num_country from core.pats table if patnum given as parameter else if pat_id given fetch app_num_country for p_app_num_country */
	IF (p_pat_id IS NOT NULL) THEN
		SELECT app_num_country into p_app_num_country from core.pats where id = p_pat_id;
		ELSIF ((p_patnum IS NOT NULL OR p_patnum <> '') AND (p_pat_id IS NULL)) THEN
			SELECT ID, app_num_country INTO p_pat_id, p_app_num_country FROM core.pats WHERE patnum = p_patnum and is_application = true;
			IF p_pat_id IS NULL THEN 
				RAISE EXCEPTION 'Invalid Input: pat_id not exists or patent is not application true';
			END IF;
		ELSIF p_pat_id IS NULL AND p_patnum IS NULL THEN
			RAISE EXCEPTION 'Invalid Input: pat_id/patnum cannot be NULL or Empty';
	END IF;

	/* Fetch Invention id from core.pats_invention table for the app_num_country , If app_num_country not present create a new one*/
	SELECT ID INTO p_invention_id FROM core.pats_invention where app_num_country = p_app_num_country;
	IF p_invention_id IS NULL THEN
		INSERT INTO core.pats_invention (app_num_country, created_at, updated_at)
			SELECT p_app_num_country, current_timestamp, current_timestamp
			RETURNING ID into p_invention_id;
	END IF;
	
	/*Get new Pat id for which the Patent need to be Granted to */
	SELECT id INTO p_grant_pat_id FROM core.pats
    WHERE NOT EXISTS(SELECT pat_id FROM core.pats_invention_link WHERE pats.id = pats_invention_link.pat_id) limit 1;
	
	/*Insert the record in pat_invention_link table using the p_invention_id and p_grant_pat_id*/
	INSERT INTO core.pats_invention_link (invention_id, pat_id, is_original, is_current, rnk, document_type, updated_at, created_at)
			 SELECT  p_invention_id, p_grant_pat_id, TRUE, TRUE, 2, 'issued patent', current_timestamp, current_timestamp 
			 WHERE NOT EXISTS (SELECT 1 FROM core.pats_invention_link WHERE invention_id = p_invention_id AND pat_id = p_grant_pat_id AND is_original = TRUE AND is_current = TRUE AND rnk = 2 AND document_type = 'issued patent')
			 RETURNING ID INTO i_source_pk_val;
			 
	IF i_source_pk_val IS NULL THEN
		RAISE EXCEPTION 'DATA ERROR: Duplicate records found in core.pats_invention_link table';
	END IF;
	
	
	UPDATE core_audit.pats_invention_link_aud
	SET user_name = 'pacer_data_service'
	where _id= i_source_pk_val and action = 'I';
	
	RETURN 1;


	EXCEPTION
	    WHEN OTHERS THEN
	        RAISE;
END;
$$;


--
-- Name: alerts_testing_load_ptab_docket_entries_for_events(integer, character varying, date, character varying, character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION alerts_testing_load_ptab_docket_entries_for_events(p_ptab_id integer DEFAULT NULL::integer, p_case_num character varying DEFAULT NULL::character varying, p_filed_date date DEFAULT (now())::date, p_title character varying DEFAULT 'Test Document Added'::character varying, p_document_type character varying DEFAULT 'Order'::character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
i_source_pk_val integer:=NULL;
p_exhibit_num integer:=NULL;

BEGIN
/*
	1.0 mvollumkondu_c 23-May-2016  DS-3670 Alerts Events Capture restructure
	
	select * from core.alerts_testing_load_ptab_docket_entries_for_events(p_case_num:='IPRTEST-001')
*/
IF ((p_case_num IS NOT NULL OR p_case_num <> '') AND (p_ptab_id IS NULL)) THEN
		SELECT ID INTO p_ptab_id FROM ptab.ptab_cases WHERE case_num = p_case_num;
	IF p_ptab_id IS NULL THEN 
		RAISE EXCEPTION 'Invalid Input: ptab_id not exists';
	END IF;
ELSIF p_ptab_id IS NULL THEN
	RAISE EXCEPTION 'Invalid Input: ptab_id cannot be NULL or Empty';
END IF;

	select (count(*)+1) into p_exhibit_num from ptab.ptab_case_details where ptab_case_id = p_ptab_id;
	
	INSERT INTO ptab.ptab_case_details (ptab_case_id, ptab_case_detail_party_type_id, doc_name, doc_type, exhibit_num, filing_date, availability, document_path, created_by, updated_by )
			 SELECT p_ptab_id, 2 , p_title, p_document_type, p_exhibit_num, p_filed_date, 'Public', 'rpx-ptab/IPR2015-00100/PM-73573_20151110T024458_003_20GMT.pdf' ,'ptab_app', 'ptab_app'; 
			 
	SELECT id INTO i_source_pk_val FROM ptab.ptab_case_details WHERE ptab_case_id = p_ptab_id AND exhibit_num = p_exhibit_num;
			 
	IF i_source_pk_val IS NULL THEN
		RAISE EXCEPTION 'DATA ERROR: Duplicate records found in ptab.ptab_case_details table';
	END IF;
	
		UPDATE ptab_audit.ptab_case_details_aud
		SET user_name = 'ptab_app'
		where _id= i_source_pk_val and action = 'I';

	
	RETURN 1;

	EXCEPTION
	    WHEN OTHERS THEN
	        RAISE;
END;
$$;


--
-- Name: alerts_testing_load_ptab_for_events(character varying, character varying, integer, character varying, date, date, integer, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION alerts_testing_load_ptab_for_events(p_event_type character varying, p_case_num character varying, p_pat_id integer DEFAULT NULL::integer, p_patnum character varying DEFAULT NULL::character varying, p_filed_date date DEFAULT (now())::date, p_closed_date date DEFAULT NULL::date, p_petitioner_alias_id integer DEFAULT NULL::integer, p_patent_owner_alias_id integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
i_source_pk_val integer;
i_campaign_id integer;
p_stripped_patnum character varying:=NULL;
p_country_code character varying:=NULL;

BEGIN
/*
	1.0 mvollumkondu_c 23-May-2016  DS-3670 : Alerts Events Capture restructure
	2.0 tazhagan_c 17-Jul-2017 DS-5499 : Include insertion in ldc.lit_docs_ptab_cases

	select * from core.alerts_testing_load_ptab_for_events(p_event_type:='PTAB Proceeding Filed'
		,p_case_num:='IPRTEST-001'
		,p_patnum:='US0000001A1'
		,p_petitioner_alias_id:=172744
		,p_patent_owner_alias_id:=6617494)
*/

IF (p_event_type IS NULL OR p_event_type = '') THEN
	RAISE EXCEPTION 'Invalid Input: Event type cannot be NULL or Empty';

ELSIF (p_event_type ~ 'Filed') THEN

	IF (p_pat_id IS NOT NULL) THEN
		SELECT stripped_patnum, country_code into p_stripped_patnum, p_country_code from core.pats where id = p_pat_id;
	ELSIF ((p_patnum IS NOT NULL OR p_patnum <> '') AND (p_pat_id IS NULL)) THEN
		SELECT ID, stripped_patnum, country_code INTO p_pat_id, p_stripped_patnum, p_country_code FROM core.pats WHERE patnum = p_patnum ;
		IF p_pat_id IS NULL THEN
			RAISE EXCEPTION 'Invalid Input: pat_id not exists';
		END IF;
	ELSIF p_pat_id IS NULL AND p_patnum IS NULL THEN
			RAISE EXCEPTION 'Invalid Input: pat_id/patnum cannot be NULL or Empty';
	END IF;

	INSERT INTO ptab.ptab_cases(case_num, filing_date, stripped_patnum, country_code, status, tech_center, ptab_case_type_id, created_by, updated_by)
			 SELECT p_case_num, p_filed_date, p_stripped_patnum, p_country_code, 'Pending', '2400', 1, 'ptab app', 'ptab app'
			 			 RETURNING ID INTO i_source_pk_val;


	INSERT INTO ldc.lit_docs_ptab_cases(case_key,ptab_case_id) VALUES (p_case_num,i_source_pk_val);

	UPDATE ptab_audit.ptab_cases_aud
	SET user_name = 'ptab_app'
	where _id= i_source_pk_val and action = 'I';

	IF p_petitioner_alias_id IS NOT NULL THEN
		PERFORM core.alerts_testing_load_ptab_parties_for_events(
			p_ptab_id := i_source_pk_val,
			p_alias_id := p_petitioner_alias_id,
			p_event_type := 'Petitioner'::CHARACTER VARYING,
			p_is_primary := TRUE
			);
	END IF;

	IF p_patent_owner_alias_id IS NOT NULL THEN
		PERFORM core.alerts_testing_load_ptab_parties_for_events(
			p_ptab_id := i_source_pk_val,
			p_alias_id := p_patent_owner_alias_id,
			p_event_type := 'Patent Owner'::CHARACTER VARYING,
			p_is_primary := TRUE
			);
	END IF;

	DROP TABLE IF EXISTS temp_campaign_metrics ;

	select lit_campaigns.find_or_create_campaign_for_ptab(i_source_pk_val) into i_campaign_id;

	RETURN 1;

ELSIF (p_event_type ~ 'Closed') THEN

	IF p_closed_date is NULL THEN
		p_closed_date:=NOW();
	END IF;

	UPDATE ptab.ptab_cases
	SET institution_decision_date = p_closed_date
	where case_num = p_case_num
	  RETURNING ID INTO i_source_pk_val;

	UPDATE ptab_audit.ptab_cases_aud
	SET user_name = 'ptab_app'
	where _id= i_source_pk_val and action = 'U' and  __institution_decision_date;

	RETURN 1;
END IF;

	EXCEPTION
	    WHEN OTHERS THEN
	        RAISE;
END;
$$;


--
-- Name: alerts_testing_load_ptab_parties_for_events(integer, character varying, character varying, integer, boolean); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION alerts_testing_load_ptab_parties_for_events(p_alias_id integer, p_event_type character varying, p_case_num character varying DEFAULT NULL::character varying, p_ptab_id integer DEFAULT NULL::integer, p_is_primary boolean DEFAULT false) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
i_ptab_party_type_id integer;
i_source_pk_val integer:=NULL;

BEGIN
/*
	1.0 mvollumkondu_c 23-May-2016  DS-3670 Alerts Events Capture restructure
	select * from core.alerts_testing_load_ptab_parties_for_events(
   		p_ptab_id := 'IPR-TES01', 
   		p_alias_id := 10315723, 
   		p_event_type := 'Patent Owner',
   		p_is_primary := TRUE
   );

   	select * from core.alerts_testing_load_ptab_parties_for_events(
   		p_ptab_id := 'IPR-TES01', 
   		p_alias_id := 3743065, 
   		p_event_type := 'Petitioner',
   		p_is_primary := TRUE
   );

    select * from core.alerts_testing_load_ptab_parties_for_events(
   		p_ptab_id := 'IPR-TES01', 
   		p_alias_id := 172744, 
   		p_event_type := 'Real Party in Interest',
   		p_is_primary := TRUE
   );


*/
IF ((p_case_num IS NOT NULL OR p_case_num <> '') AND (p_ptab_id IS NULL)) THEN
	SELECT ID INTO p_ptab_id FROM ptab.ptab_cases WHERE case_num = p_case_num;
	IF p_ptab_id IS NULL THEN 
	RAISE EXCEPTION 'Invalid Input: ptab case number not exists';
	END IF;
ELSIF p_case_num IS NULL AND p_ptab_id IS NULL THEN
	RAISE EXCEPTION 'Invalid Input: case number/ptab_id cannot be NULL or Empty';
END IF;

IF p_event_type ~ 'Petitioner' THEN
	i_ptab_party_type_id = 1;

ELSIF p_event_type ~ 'Patent Owner' THEN
	i_ptab_party_type_id = 2;
	
ELSIF p_event_type ~ 'Real Party in Interest' THEN
	i_ptab_party_type_id = 3;
	
END IF;

IF (p_event_type IS NULL OR p_event_type = '') THEN 
	RAISE EXCEPTION 'Invalid Input: Event type cannot be NULL or Empty';
	
ELSE	
	INSERT INTO ptab.ptab_parties (ptab_case_id, alias_id, ptab_party_type_id, is_primary, created_by, updated_by)
			 SELECT p_ptab_id, p_alias_id, i_ptab_party_type_id, p_is_primary, 'ptab_app', 'ptab_app'
			 WHERE NOT EXISTS (SELECT 1 FROM ptab.ptab_parties WHERE ptab_case_id=p_ptab_id AND alias_id = p_alias_id AND ptab_party_type_id = i_ptab_party_type_id )
			 RETURNING ID INTO i_source_pk_val;
			 
	IF i_source_pk_val IS NULL THEN
		RAISE EXCEPTION 'DATA ERROR: The input party alias is already exists for the ptab';
	END IF;
	
	UPDATE ptab_audit.ptab_parties_aud
	SET user_name = 'ptab_app'
	where _id= i_source_pk_val and action = 'I';

	RETURN 1;

END IF;

	EXCEPTION
	    WHEN OTHERS THEN
	        RAISE;
END;
$$;


--
-- Name: alerts_testing_load_ptab_status_for_events(character varying, character varying, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION alerts_testing_load_ptab_status_for_events(p_status character varying, p_case_num character varying DEFAULT NULL::character varying, p_ptab_id integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
i_source_pk_val integer;

BEGIN
/*
	1.0 mvollumkondu_c 23-May-2016  DS-3670 Alerts Events Capture restructure
	
	select * from core.alerts_testing_load_ptab_status_for_events(p_case_num:='IPRTEST-001'
		,p_status:='Pending')
*/
IF ((p_case_num IS NOT NULL OR p_case_num <> '') AND (p_ptab_id IS NULL)) THEN
	SELECT ID INTO p_ptab_id FROM ptab.ptab_cases WHERE case_num = p_case_num;
	IF p_ptab_id IS NULL THEN 
	RAISE EXCEPTION 'Invalid Input: Case number not exists';
	END IF;
ELSIF p_case_num IS NULL AND p_ptab_id IS NULL THEN
	RAISE EXCEPTION 'Invalid Input: Case number/Ptab id cannot be NULL or Empty';
END IF;


	UPDATE ptab.ptab_cases
	SET status =  p_status
	WHERE id =  p_ptab_id
	RETURNING ID INTO i_source_pk_val;
	
	UPDATE ptab_audit.ptab_cases_aud
	SET user_name = 'ptab_app'
	where _id= i_source_pk_val and action = 'U' and __status;

	RETURN 1;

	EXCEPTION
	    WHEN OTHERS THEN
	        RAISE;
END;
$$;


--
-- Name: alias_contacts_md5_trig_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION alias_contacts_md5_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
    IF (TG_OP = 'UPDATE') THEN
         NEW.address_md5 :=  md5(lower(coalesce(case when UPPER(trim(NEW.line1))='N/A' THEN NULL ELSE UPPER(trim(NEW.line1)) END, ''::text)) ||
                    lower(coalesce(case when UPPER(trim(NEW.line2))='N/A' THEN NULL ELSE UPPER(trim(NEW.line2)) END, ''::text)) ||
                    lower(coalesce(case when UPPER(trim(NEW.line3))='N/A' THEN NULL ELSE UPPER(trim(NEW.line3)) END, ''::text)) ||
                    lower(coalesce(case when UPPER(trim(NEW.city))='N/A' THEN NULL ELSE UPPER(trim(NEW.city)) END, ''::text)) ||
                    lower(coalesce(case when UPPER(trim(NEW.state_or_province))='N/A' THEN NULL ELSE UPPER(trim(NEW.state_or_province)) END, ''::text)) ||
                    lower(coalesce(case when UPPER(trim(NEW.postal_code))='N/A' THEN NULL ELSE UPPER(trim(NEW.postal_code)) END, ''::text)) ||
                    lower(coalesce(case when UPPER(trim(NEW.country))='N/A' THEN NULL ELSE UPPER(trim(NEW.country)) END, ''::text)) ||
                    lower(coalesce(case when UPPER(trim(NEW.url))='N/A' THEN NULL ELSE UPPER(trim(NEW.url)) END, ''::text)) ||
                    lower(coalesce(case when UPPER(trim(NEW.phone))='N/A' THEN NULL ELSE UPPER(trim(NEW.phone)) END, ''::text)) ||
                    lower(coalesce(case when UPPER(trim(NEW.fax))='N/A' THEN NULL ELSE UPPER(trim(NEW.fax)) END, ''::text)) ||
                    lower(coalesce(case when UPPER(trim(NEW.cell))='N/A' THEN NULL ELSE UPPER(trim(NEW.cell)) END, ''::text)) ||
                    lower(coalesce(case when UPPER(trim(NEW.email))='N/A' THEN NULL ELSE UPPER(trim(NEW.email)) END, ''::text)) ||
                    lower(coalesce(case when UPPER(trim(NEW.notes))='N/A' THEN NULL ELSE UPPER(trim(NEW.notes)) END, ''::text)) ||
                    lower(coalesce(case when UPPER(trim(NEW.lat::text))='N/A' THEN NULL ELSE UPPER(trim(NEW.lat::text)) END, ''::text)) ||
                    lower(coalesce(case when UPPER(trim(NEW.lon::text))='N/A' THEN NULL ELSE UPPER(trim(NEW.lon::text)) END, ''::text)) ||
                    lower(coalesce(case when UPPER(trim(NEW.line4))='N/A' THEN NULL ELSE UPPER(trim(NEW.line4)) END, ''::text) ));
      RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
       NEW.address_md5 :=  md5(lower(coalesce(case when UPPER(trim(NEW.line1))='N/A' THEN NULL ELSE UPPER(trim(NEW.line1)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(NEW.line2))='N/A' THEN NULL ELSE UPPER(trim(NEW.line2)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(NEW.line3))='N/A' THEN NULL ELSE UPPER(trim(NEW.line3)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(NEW.city))='N/A' THEN NULL ELSE UPPER(trim(NEW.city)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(NEW.state_or_province))='N/A' THEN NULL ELSE UPPER(trim(NEW.state_or_province)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(NEW.postal_code))='N/A' THEN NULL ELSE UPPER(trim(NEW.postal_code)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(NEW.country))='N/A' THEN NULL ELSE UPPER(trim(NEW.country)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(NEW.url))='N/A' THEN NULL ELSE UPPER(trim(NEW.url)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(NEW.phone))='N/A' THEN NULL ELSE UPPER(trim(NEW.phone)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(NEW.fax))='N/A' THEN NULL ELSE UPPER(trim(NEW.fax)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(NEW.cell))='N/A' THEN NULL ELSE UPPER(trim(NEW.cell)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(NEW.email))='N/A' THEN NULL ELSE UPPER(trim(NEW.email)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(NEW.notes))='N/A' THEN NULL ELSE UPPER(trim(NEW.notes)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(NEW.lat::text))='N/A' THEN NULL ELSE UPPER(trim(NEW.lat::text)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(NEW.lon::text))='N/A' THEN NULL ELSE UPPER(trim(NEW.lon::text)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(NEW.line4))='N/A' THEN NULL ELSE UPPER(trim(NEW.line4)) END, ''::text) ));



        RETURN NEW;
    ELSE
        RAISE EXCEPTION '[core..alias_contacts_md5_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core..alias_contacts_md5_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core..alias_contacts_md5_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core..alias_contacts_md5_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: aliases_alias_ent_details_trig_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION aliases_alias_ent_details_trig_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
 v_id int;
BEGIN
    IF (TG_OP = 'UPDATE') THEN
      IF (NEW.name <> OLD.name) THEN
        UPDATE core.alias_ent_details
        SET alias_name = NEW.name, is_non_human = code_nerd.is_non_human(NEW.name), clean_name = NEW.clean_name
        WHERE alias_id = NEW.id;
      END IF;
      IF (NEW.clean_name <> OLD.clean_name) THEN
        UPDATE core.alias_ent_details
        SET clean_name = NEW.clean_name
        WHERE alias_id = NEW.id;
      END IF;
      IF (coalesce(NEW.ent_id, -1) <> coalesce(OLD.ent_id,-1)) THEN
        UPDATE core.alias_ent_details
        SET ent_id = NEW.ent_id,
            ultimate_parent_id = (SELECT ents.ultimate_parent_id FROM  core.ents ents WHERE ents.id = NEW.ent_id),
            ent_name = (SELECT ents.name FROM  core.ents ents WHERE ents.id = NEW.ent_id),
            soft_ent_id = NULL,
            ent_type_id = (SELECT ents.ent_type_id FROM  core.ents ents WHERE ents.id = NEW.ent_id),
            ent_created_at = (SELECT ents.created_at FROM  core.ents ents WHERE ents.id = NEW.ent_id),
            ultimate_parent_name = (SELECT ents1.name FROM  core.ents ents inner join core.ents ents1 on ents1.id = ents.ultimate_parent_id WHERE ents.id = NEW.ent_id)
        WHERE alias_id = NEW.id;

        UPDATE alias_ent_map.non_human_aliases nha
        SET ent_id =NEW.ent_id,
            verified_ent_id = NULL,
            rep_alias_id = NULL,
            process_flag = 'N'
        WHERE alias_id = NEW.id;

      END IF;
      RETURN NEW;
    END IF;

    IF (TG_OP = 'DELETE') THEN
        DELETE FROM core.alias_ent_details WHERE alias_id = OLD.id;
        RETURN OLD;
    END IF;

    IF (TG_OP = 'INSERT') THEN
            INSERT INTO core.alias_ent_details
            (alias_id, ent_id, ultimate_parent_id, alias_name, ent_name, ultimate_parent_name, ent_type_id, clean_name, is_non_human, ent_created_at, alias_created_at)
            VALUES
            ( NEW.id, NEW.ent_id,
             (SELECT ents.ultimate_parent_id FROM  core.ents ents WHERE ents.id = NEW.ent_id),
             NEW.name,
             (SELECT ents.name FROM  core.ents ents WHERE ents.id = NEW.ent_id),
             (SELECT ents1.name FROM  core.ents ents inner join core.ents ents1 on ents1.id = ents.ultimate_parent_id WHERE ents.id = NEW.ent_id),
             (SELECT ents.ent_type_id FROM  core.ents ents WHERE ents.id = NEW.ent_id),
             NEW.clean_name,
             code_nerd.is_non_human(NEW.name),
             (SELECT ents.created_at FROM core.ents ents WHERE ents.id = NEW.ent_id),
             now()
            );
        RETURN NEW;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core..aliases_alias_ent_details_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core..aliases_alias_ent_details_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core..aliases_alias_ent_details_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: before_lit_relationship_change(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION before_lit_relationship_change() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_rel_count INTEGER;
BEGIN
/*
1.0 10-Jun-2015 anarayanan DS-1434 ignoring is_campaign_follower changes
*/
    IF (TG_OP = 'DELETE') THEN
        RETURN OLD;

    ELSIF (TG_OP = 'UPDATE') THEN
        IF NEW.lit_relationship_type_id != (select id from core.lit_relationship_types where name = 'is_campaign_follower') AND NEW.from_lit_id = NEW.to_lit_id
            AND (NEW.from_lit_id != OLD.from_lit_id OR NEW.to_lit_id != OLD.to_lit_id) THEN

      --If we're changing it to create a self-pointing relationship, we don't want to create it if the lit is already in another relationship
      SELECT count(*)
      INTO v_rel_count
      FROM core.lit_relationships
      WHERE from_lit_id = NEW.from_lit_id OR to_lit_id = NEW.from_lit_id
                AND id != NEW.id;

      IF v_rel_count > 0 THEN
                RAISE EXCEPTION '[core.before_lit_relationship_change] - Did not update the relationship to a selp-pointing relationship for lit_id % as it is already in a relationship. Perhaps the relationship should be deleted, not updated.', NEW.from_lit_id;
                RETURN NULL;
            ELSE
                RETURN NEW;
            END IF;
        ELSE
            RETURN NEW;
        END IF;

    ELSIF (TG_OP = 'INSERT') THEN
        IF NEW.lit_relationship_type_id != (select id from core.lit_relationship_types where name = 'is_campaign_follower') AND NEW.from_lit_id = NEW.to_lit_id THEN
      --If we're about to create a self-pointing relationship, we don't want to create it if the lit is already in another relationship
      SELECT count(*)
      INTO v_rel_count
      FROM core.lit_relationships
      WHERE from_lit_id = NEW.from_lit_id OR to_lit_id = NEW.from_lit_id
                AND id != NEW.id;

      IF v_rel_count > 0 THEN
                RAISE NOTICE '[core.before_lit_relationship_change] - Did not create a selp-pointing relationship for lit_id % as it is already in a relationship.', NEW.from_lit_id;
                RETURN NULL;
            ELSE
                RETURN NEW;
            END IF;
        ELSE
            RETURN NEW;
        END IF;

    END IF;
END;
$$;


--
-- Name: clean_name(character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION clean_name(name character varying) RETURNS character varying
    LANGUAGE plpgsql STRICT
    AS $$

BEGIN
    RAISE NOTICE 'This function has been deprecated, please use code_nerd.clean_name_for';
    RETURN code_nerd.clean_name_for(name);

END
$$;


--
-- Name: clean_name_for_attorney(character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION clean_name_for_attorney(attorney_name character varying) RETURNS character varying
    LANGUAGE plpgsql STRICT
    AS $$

BEGIN
    RAISE NOTICE 'This function has been deprecated, please use code_nerd.clean_name_for_attorney';
    RETURN code_nerd.clean_name_for_attorney(attorney_name);

END
$$;


--
-- Name: clean_name_for_judge(character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION clean_name_for_judge(judge_name character varying) RETURNS character varying
    LANGUAGE plpgsql STRICT
    AS $$

BEGIN
    RAISE NOTICE 'This function has been deprecated, please use code_nerd.clean_name_for_judge';
    RETURN code_nerd.clean_name_for_judge(judge_name);

END
$$;


--
-- Name: combine_lit_families(integer[]); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION combine_lit_families(p_family_id_list integer[]) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_new_family_id    INTEGER;

BEGIN
    --Create a new family for the old ones to combine into
    v_new_family_id := core.add_lit_family();

    --Update any pointers to the obsolete lit families to point to the new family
    UPDATE core.lit_relationships
    SET lit_family_id = v_new_family_id
    WHERE lit_family_id = ANY(p_family_id_list);

    --Mark the previous family records obsolete and point them to the new family
    UPDATE core.lit_families
    SET is_obsolete = TRUE,
        new_family_id = ARRAY[v_new_family_id],
        updated_at = CURRENT_TIMESTAMP,
        created_at = CURRENT_TIMESTAMP
    WHERE id = ANY(p_family_id_list);

    RETURN v_new_family_id;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core.combine_lit_families] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core.combine_lit_families] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
    WHEN OTHERS THEN
        RAISE;

END;
$$;


--
-- Name: core_audit(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION core_audit() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_old_data TEXT;
    v_new_data TEXT;
	v_to_audit boolean :=true;
BEGIN
/**
  Here is an example of recovery of data:
    select (cast(new_data as core.aliases)).ent_id from core.core_aud
**/
	if (lower(TG_TABLE_NAME::TEXT) in ('lits','docket_entries')) then
		v_to_audit:=true;
	else
		v_to_audit:=false;
	end if;
    IF (TG_OP = 'UPDATE') THEN
        if (v_to_audit=true) THEN
			v_old_data := ROW(OLD.*);
			v_new_data := ROW(NEW.*);
			INSERT INTO core.core_aud (schema_name,table_name,user_name,action,original_data,new_data,query)
		  VALUES (TG_TABLE_SCHEMA::TEXT,TG_TABLE_NAME::TEXT,session_user::TEXT,substring(TG_OP,1,1),v_old_data,v_new_data, current_query());
		end if;
        NEW.updated_at := timezone('UTC'::text, now());
        RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
		if (v_to_audit=true) THEN
			v_old_data := ROW(OLD.*);
			INSERT INTO core.core_aud (schema_name,table_name,user_name,action,original_data,query)
		  VALUES (TG_TABLE_SCHEMA::TEXT,TG_TABLE_NAME::TEXT,session_user::TEXT,substring(TG_OP,1,1),v_old_data, current_query());
		end if;
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
       if (v_to_audit=true) THEN
			v_new_data := ROW(NEW.*);
			INSERT INTO core.core_aud (schema_name,table_name,user_name,action,new_data,query)
		  VALUES (TG_TABLE_SCHEMA::TEXT,TG_TABLE_NAME::TEXT,session_user::TEXT,substring(TG_OP,1,1),v_new_data, current_query());
		end if;
		NEW.created_at := current_timestamp;
		NEW.updated_at := current_timestamp;
        RETURN NEW;
    ELSE
        RAISE WARNING '[core.core_aud] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE WARNING '[core.core_aud] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE WARNING '[core.core_aud] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE WARNING '[core.core_aud] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: core_name_for(text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION core_name_for(name_as_seen text) RETURNS character varying
    LANGUAGE plpgsql STRICT
    AS $$

BEGIN
    RAISE NOTICE 'This function has been deprecated, please use code_nerd.core_name_for';
    RETURN code_nerd.core_name_for(name_as_seen::varchar);

END
$$;


--
-- Name: core_name_for_corp(character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION core_name_for_corp(company_name character varying) RETURNS character varying
    LANGUAGE plpgsql STRICT
    AS $$

BEGIN
    RAISE NOTICE 'This function has been deprecated, please use code_nerd.core_name_for_non_human';
    RETURN code_nerd.core_name_for_non_human(company_name);

END
$$;


--
-- Name: core_name_for_person(character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION core_name_for_person(person_name character varying) RETURNS character varying
    LANGUAGE plpgsql STRICT
    AS $$

BEGIN
    RAISE NOTICE 'This function has been deprecated, please use code_nerd.core_name_for_human';
    RETURN code_nerd.core_name_for_human(person_name);

END
$$;


--
-- Name: create_alias_sequential(text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION create_alias_sequential(p_alias_name text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_alias_id INTEGER;
    v_sequential_flag INTEGER;
BEGIN
---this function won't check if the alias name already exits in db.
---it will do insert blindly. Don't use this function to insert alias.

    SELECT flag into v_sequential_flag
    FROM core.tx_sequential_control
    WHERE function_name = 'find_or_create_alias' for update;

    SELECT min(id) into v_alias_id FROM core.aliases WHERE name = p_alias_name;

    IF v_alias_id is NULL THEN

     INSERT INTO core.aliases (
            name,
            lower_stripped,
            core_name,
            fingerprint,
            clean_name
     )
     VALUES (
            p_alias_name,
            code_nerd.lower_strip(p_alias_name),
            code_nerd.core_name_for(p_alias_name),
            code_nerd.fingerprint(p_alias_name),
            code_nerd.clean_name_for(p_alias_name)
     ) returning id into v_alias_id;

    END IF;
    RETURN v_alias_id;
EXCEPTION
 WHEN OTHERS THEN
  RAISE;
END;
$$;


--
-- Name: create_all_triggers(text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION create_all_triggers(schema_name text) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN SELECT table_name FROM information_schema.tables WHERE table_schema = schema_name
    LOOP
        EXECUTE 'CREATE TRIGGER ' || r.table_name ||  '_insert_timestamps BEFORE INSERT ON ' || schema_name || '.' || r.table_name ||
                    ' FOR EACH ROW EXECUTE PROCEDURE core.insert_timestamps();';
        EXECUTE 'CREATE TRIGGER ' || r.table_name ||  '_update_timestamp BEFORE UPDATE ON ' || schema_name || '.' || r.table_name ||
                    ' FOR EACH ROW EXECUTE PROCEDURE core.update_timestamp();';
    END LOOP;
END;
$$;


--
-- Name: create_lit_court(integer, integer, date, date); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION create_lit_court(p_lit_id integer, p_alias_id integer, p_start_date date, p_end_date date) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_lit_court_id INTEGER := NULL;
BEGIN

 SELECT id
 INTO v_lit_court_id
 FROM core.lit_courts
 WHERE lit_id = p_lit_id AND
       coalesce(alias_id, -1) = coalesce(p_alias_id, -1) AND
       (start_date = p_start_date OR p_start_date is NULL) AND
       coalesce(end_date, '3001-01-01') = coalesce(p_end_date, '3001-01-01');

 ---No changes, then return id
 IF v_lit_court_id is not NULL THEN
  RETURN v_lit_court_id;
 END IF;


 SELECT id
 INTO v_lit_court_id
 FROM core.lit_courts
 WHERE lit_id = p_lit_id AND
       alias_id = p_alias_id;

 IF NOT FOUND THEN

  INSERT INTO core.lit_courts
  (lit_id, alias_id, start_date, end_date, created_at, updated_at)
  VALUES
  (p_lit_id, p_alias_id,  p_start_date, p_end_date, now(), now())
  RETURNING id INTO v_lit_court_id;

 ELSE

  UPDATE core.lit_courts
  SET
    start_date = COALESCE(p_start_date, start_date),
    end_date = p_end_date,
    updated_at = now()
  WHERE lit_id = p_lit_id AND
        alias_id = p_alias_id;

 END IF;

 RETURN v_lit_court_id;
END;
$$;


--
-- Name: create_lit_judges_map(integer, integer, integer, character varying, date, date, date); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION create_lit_judges_map(p_lit_id integer, p_alias_id integer, p_assignment_type_id integer, p_assignment_role_as_filed character varying, p_start_date date, p_end_date date, p_missing_from_source_date date) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_lit_judges_map_id INTEGER := NULL;
BEGIN

 ---since judge start_date and end_date are from docket craeted_at timestamp
 ---we need to make sure a new record has to have a later start_date than end_date
 ---certainly if start_date, end_date both same, then same record too
 SELECT id
 INTO v_lit_judges_map_id
 FROM core.lit_judges_map
 WHERE alias_id = p_alias_id AND
       lit_id = p_lit_id AND
       assignment_type_id = p_assignment_type_id AND
       assignment_role_as_filed = p_assignment_role_as_filed AND
       (
        coalesce(end_date, '3001-01-01') > coalesce(p_start_date, '3001-01-01')
        OR
        coalesce(start_date, '1970-01-01') = coalesce(p_start_date, '1970-01-01')
       );

 ---No changes, then return id
 ---Also make sure not to update data to create duplicates
 IF v_lit_judges_map_id is not NULL THEN
     UPDATE core.lit_judges_map
     SET
      is_terminated = (CASE WHEN p_end_date is not NULL THEN TRUE ELSE FALSE END),
      assignment_role_as_filed = p_assignment_role_as_filed,
      start_date = p_start_date,
      missing_from_source_date = p_missing_from_source_date,
      end_date = p_end_date
     WHERE id = v_lit_judges_map_id;

     RETURN v_lit_judges_map_id;
 END IF;

 IF p_end_date is NULL AND p_missing_from_source_date is NULL THEN

   SELECT id
   INTO v_lit_judges_map_id
   FROM core.lit_judges_map
   WHERE alias_id = p_alias_id AND
         lit_id = p_lit_id AND
         assignment_type_id = p_assignment_type_id AND
         end_date is NULL AND
         missing_from_source_date is NULL;

   ---Need to make sure active attorney/firm are uniq
   IF v_lit_judges_map_id is not NULL THEN
     RAISE NOTICE 'This judge is already existed (id %). Do update if there is data change.', v_lit_judges_map_id;
     RETURN v_lit_judges_map_id;
   END IF;
 END IF;
 ---missing_from_source_date is always null for new record
 INSERT INTO core.lit_judges_map
 (lit_id ,alias_id ,assignment_type_id ,is_terminated ,assignment_role_as_filed ,start_date ,end_date, created_at, updated_at)
 VALUES
 (p_lit_id ,p_alias_id ,p_assignment_type_id ,(CASE WHEN p_end_date is not NULL THEN TRUE ELSE FALSE END),p_assignment_role_as_filed ,p_start_date ,p_end_date, now(), now())
 RETURNING id INTO v_lit_judges_map_id;

 RETURN v_Lit_judges_map_id;
END;
$$;


--
-- Name: create_lit_parties(integer, integer, integer, integer, date, date, date); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION create_lit_parties(p_lit_id integer, p_alias_id integer, p_lit_party_type_id integer, p_alias_contact_id integer, p_start_date date, p_end_date date, p_missing_from_source_date date) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_lit_parties_id INTEGER := NULL;
 v_dj_party_normalized_type VARCHAR(255) := NULL;
BEGIN

 SELECT id
 INTO v_lit_parties_id
 FROM core.lit_parties
 WHERE lit_id = p_lit_id AND
       alias_id = p_alias_id AND
       coalesce(alias_contact_id, -1) = coalesce(p_alias_contact_id, -1) AND
       lit_party_type_id = p_lit_party_type_id AND
       coalesce(start_date, '3001-01-01') = coalesce(p_start_date, '3001-01-01') AND
       coalesce(end_date, '3001-01-01') = coalesce(p_end_date, '3001-01-01') AND
       coalesce(missing_from_source_date, '3001-01-01') = coalesce(p_missing_from_source_date, '3001-01-01');

 ---No changes, then return id
 ---Also make sure not to update data to create duplicates
 IF v_lit_parties_id is not NULL THEN
  RAISE NOTICE 'Another lit_party record (id %) has the same information. No duplicates allowed.', v_lit_parties_id;
  RETURN v_lit_parties_id;
 END IF;

 IF p_end_date is NULL AND p_missing_from_source_date is NULL THEN

   SELECT id
   INTO v_lit_parties_id
   FROM core.lit_parties
   WHERE lit_id = p_lit_id AND
         alias_id = p_alias_id AND
         lit_party_type_id = p_lit_party_type_id AND
         end_date is NULL AND
         missing_from_source_date is NULL;

   ---Need to make sure active parties/role are uniq
   IF v_lit_parties_id is not NULL THEN
    RAISE NOTICE 'This party/role pair is already existed (id %). Do update if there is data change.', v_lit_parties_id;
    RETURN v_lit_parties_id;
   END IF;
 END IF;

 SELECT ( CASE WHEN lpt.lit_party_normalized_type IN ('defendant', 'plaintiff') THEN ( CASE WHEN la.is_dj THEN ( CASE WHEN lpt.lit_party_normalized_type = 'defendant' THEN 'plaintiff' ELSE 'defendant' END ) ELSE lpt.lit_party_normalized_type END ) ELSE NULL END )
 INTO v_dj_party_normalized_type
 FROM core.lit_annotations la, core.lit_party_types lpt WHERE la.lit_id = p_lit_id AND lpt.ID = p_lit_party_type_id;

   ---missing_from_source_date is always null for new record
 INSERT INTO core.lit_parties
 (lit_id, lit_party_type_id, alias_id, alias_contact_id, dj_party_normalized_type, start_date, end_date, missing_from_source_date, is_removed_from_pacer, created_at, updated_at)
 VALUES
 (p_lit_id, p_lit_party_type_id,  p_alias_id, p_alias_contact_id, v_dj_party_normalized_type, p_start_date, p_end_date, p_missing_from_source_date,
  (CASE WHEN p_missing_from_source_date is NOT NULL THEN TRUE ELSE FALSE END)::BOOLEAN,
  now(), now())
 RETURNING id INTO v_lit_parties_id;

 RETURN v_Lit_parties_id;
END;
$$;


--
-- Name: create_lit_parties_representations(integer, integer, integer, boolean, boolean, integer, integer, boolean, date, date, date); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION create_lit_parties_representations(p_lit_parties_id integer, p_lawfirm_alias_id integer, p_lawyer_alias_id integer, p_is_lead_lawyer boolean, p_is_notify_lawyer boolean, p_lawyer_alias_contact_id integer, p_lawfirm_alias_contact_id integer, p_is_local_lawyer boolean, p_start_date date, p_end_date date, p_missing_from_source_date date) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_lit_parties_representations_id INTEGER := NULL;
BEGIN

 ---two cases:
 ---1. party got unterminated then, it has a new start_date
 ---2. party got missed from pacer and come back
 SELECT id
 INTO v_lit_parties_representations_id
 FROM core.lit_parties_representations
 WHERE lit_parties_id = p_lit_parties_id AND
       lawyer_alias_id = p_lawyer_alias_id AND
       lawfirm_alias_id = p_lawfirm_alias_id AND
       is_lead_lawyer = p_is_lead_lawyer AND
       is_notify_lawyer = p_is_notify_lawyer AND
       coalesce(lawyer_alias_contact_id, -1) = coalesce(p_lawyer_alias_contact_id, -1) AND
       coalesce(lawfirm_alias_contact_id, -1) = coalesce(p_lawfirm_alias_contact_id, -1) AND
       is_local_lawyer = p_is_local_lawyer AND
       coalesce(start_date, '3001-01-01') = coalesce(p_start_date, '3001-01-01') AND
       coalesce(end_date, '3001-01-01') = coalesce(p_end_date, '3001-01-01') AND
       coalesce(missing_from_source_date, '3001-01-01') = coalesce(p_missing_from_source_date, '3001-01-01');


 ---No changes, then return id
 ---Also make sure not to update data to create duplicates
 IF v_lit_parties_representations_id is not NULL THEN
     RAISE NOTICE 'Another  lit_party_representation record (id %) has the same information. No duplicates allowed.', v_lit_parties_representations_id;
     RETURN v_lit_parties_representations_id;
 END IF;

 IF p_end_date is NULL AND p_missing_from_source_date is NULL THEN

   SELECT id
   INTO v_lit_parties_representations_id
   FROM core.lit_parties_representations
   WHERE lit_parties_id = p_lit_parties_id AND
         lawyer_alias_id = p_lawyer_alias_id AND
         lawfirm_alias_id = p_lawfirm_alias_id AND
         end_date is NULL AND
         missing_from_source_date is NULL;

   ---Need to make sure active attorney/firm are uniq
   IF v_lit_parties_representations_id is not NULL THEN
     RAISE NOTICE 'This lawyer/lawfirm pair is already existed (id %). Do update if there is data change.', v_lit_parties_representations_id;
     RETURN v_lit_parties_representations_id;
   END IF;
 END IF;
   ---missing_from_source_date is always null for new record
 INSERT INTO core.lit_parties_representations
 (lit_parties_id ,lawfirm_alias_id ,lawyer_alias_id ,is_lead_lawyer ,is_notify_lawyer ,lawyer_alias_contact_id ,lawfirm_alias_contact_id ,is_local_lawyer ,start_date, end_date, created_at, updated_at)
 VALUES
 (p_lit_parties_id ,p_lawfirm_alias_id ,p_lawyer_alias_id ,p_is_lead_lawyer ,p_is_notify_lawyer ,p_lawyer_alias_contact_id ,p_lawfirm_alias_contact_id ,p_is_local_lawyer ,p_start_date, p_end_date, now(), now())
 RETURNING id INTO v_lit_parties_representations_id;

 RETURN v_Lit_parties_representations_id;
END;
$$;


--
-- Name: create_or_update_dma_lit_annotation(integer, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION create_or_update_dma_lit_annotation(p_lit_id integer, p_lit_stage_id integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/*
1.0 tazhagan_c DS-3474 23-Mar-2016 : Modify case copier API to insert/update data to new DMA table core.dma_lit_annotations
*/
DECLARE
 v_dma_lit_annotation_id INTEGER := NULL;
BEGIN
 SELECT id
 INTO v_dma_lit_annotation_id
 FROM core.dma_lit_annotations
 WHERE lit_id = p_lit_id AND
       lit_stage_id = p_lit_stage_id;

 IF FOUND THEN
   RETURN v_dma_lit_annotation_id;
 END IF;

 SELECT id
 INTO v_dma_lit_annotation_id
 FROM core.dma_lit_annotations
 WHERE lit_id = p_lit_id;

 IF NOT FOUND THEN

  INSERT INTO core.dma_lit_annotations
  (lit_id, lit_stage_id, lit_type_id, lit_classification_type_id, market_sector_type_id, lit_curated_cause_type_id, is_dj)
  VALUES
  (p_lit_id, p_lit_stage_id,
   (SELECT id FROM core.lit_types WHERE name = 'Pending Review' limit 1),
   (SELECT id FROM core.lit_classification_types WHERE name = 'undefined' limit 1),
   (SELECT id FROM core.market_sector_types WHERE name = 'Undefined' limit 1),
   (SELECT id FROM core.lit_curated_cause_types WHERE name = 'Unknown' limit 1),
   FALSE
  );

 ELSE

  UPDATE core.dma_lit_annotations
  SET lit_stage_id = p_lit_stage_id
  WHERE lit_id = p_lit_id;

 END IF;

 RETURN v_dma_lit_annotation_id;
END;
$$;


--
-- Name: create_or_update_lit_annotation(integer, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION create_or_update_lit_annotation(p_lit_id integer, p_lit_stage_id integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/*
1.1 tazhagan_c 23-Sep-2015 DS-1990: Change undefined to Undefined
*/
DECLARE
 v_lit_annotation_id INTEGER := NULL;
BEGIN
 SELECT id
 INTO v_lit_annotation_id
 FROM core.lit_annotations
 WHERE lit_id = p_lit_id AND
       lit_stage_id = p_lit_stage_id;

 IF FOUND THEN
   RETURN v_lit_annotation_id;
 END IF;

 SELECT id
 INTO v_lit_annotation_id
 FROM core.lit_annotations
 WHERE lit_id = p_lit_id;

 IF NOT FOUND THEN

  INSERT INTO core.lit_annotations
  (lit_id, lit_stage_id, lit_type_id, lit_classification_type_id, market_sector_type_id, lit_curated_cause_type_id, is_dj)
  VALUES
  (p_lit_id, p_lit_stage_id,
   (SELECT id FROM core.lit_types WHERE name = 'Pending Review' limit 1),
   (SELECT id FROM core.lit_classification_types WHERE name = 'undefined' limit 1),
   (SELECT id FROM core.market_sector_types WHERE name = 'Undefined' limit 1),
   (SELECT id FROM core.lit_curated_cause_types WHERE name = 'Unknown' limit 1),
   FALSE
  );

 ELSE

  UPDATE core.lit_annotations
  SET lit_stage_id = p_lit_stage_id
  WHERE lit_id = p_lit_id;

 END IF;
 RETURN v_lit_annotation_id;
END;
$$;


--
-- Name: create_or_update_lit_case_stage(integer, integer, boolean, date, integer, date, integer, text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION create_or_update_lit_case_stage(p_lit_id integer, p_lit_stage_id integer, p_is_current boolean, p_start_date date, p_start_entry_index integer, p_end_date date, p_end_entry_index integer, p_comment text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_lit_case_stage_id INTEGER := NULL;
BEGIN

 SELECT id
 INTO v_lit_case_stage_id
 FROM core.lit_case_stages
 WHERE lit_id = p_lit_id AND
       lit_stage_id = p_lit_stage_id AND
       coalesce(start_entry_index, -1) = coalesce(p_start_entry_index, -1) AND
       coalesce(end_entry_index, -1) = coalesce(p_end_entry_index, -1) AND
       coalesce(start_date, '1970-01-01') = coalesce(p_start_date, '1970-01-01') AND
       coalesce(end_date, '3001-01-01') = coalesce(p_end_date, '3001-01-01') AND
       coalesce(comment, 'NA') = coalesce(p_comment, 'NA') AND
       coalesce(is_current, false) = coalesce(p_is_current, false);

 ---No changes, then return id
 ---Also make sure not to update data to create duplicates
 IF v_lit_case_stage_id is not NULL THEN
  RETURN v_lit_case_stage_id;
 END IF;


 SELECT id
 INTO v_lit_case_stage_id
 FROM core.lit_case_stages
 WHERE lit_id = p_lit_id AND
       lit_stage_id = p_lit_stage_id;

 IF NOT FOUND THEN

  INSERT INTO core.lit_case_stages
  (lit_id, lit_stage_id, comment, start_entry_index, end_entry_index, is_current, start_date, end_date, created_at, updated_at)
  VALUES
  (p_lit_id, p_lit_stage_id,  p_comment, p_start_entry_index,  p_end_entry_index, p_is_current, p_start_date, p_end_date, now(), now())
  RETURNING id INTO v_lit_case_stage_id;

 ELSE

  UPDATE core.lit_case_stages
  SET
    lit_stage_id = p_lit_stage_id,
    comment = p_comment,
    start_entry_index = p_start_entry_index,
    end_entry_index = p_end_entry_index,
    is_current = p_is_current,
    start_date = p_start_date,
    end_date = p_end_date,
    updated_at = now()
  WHERE lit_id = p_lit_id AND
        lit_stage_id = p_lit_stage_id;

 END IF;

 RETURN v_lit_case_stage_id;
END;
$$;


--
-- Name: create_or_update_lits(character varying, integer, integer, numeric, character varying, character varying, character varying, character varying, date, date, boolean, character varying, character varying, timestamp without time zone, timestamp without time zone, timestamp without time zone, boolean, boolean, boolean, timestamp without time zone, integer, boolean); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION create_or_update_lits(p_case_key character varying, p_lit_cause_id integer, p_nos integer, p_demand numeric, p_docket_number_long character varying, p_docket_number character varying, p_jurisdiction character varying, p_jury_demand character varying, p_filed_date date, p_closed_date date, p_is_open boolean, p_title character varying, p_case_type character varying, p_last_pacer_retrieval_for_summary timestamp without time zone, p_last_pacer_retrieval_for_docket timestamp without time zone, p_last_pacer_retrieval_for_parties timestamp without time zone, p_has_spammy_parties boolean, p_has_spammy_patents boolean, p_has_complaint boolean, p_added_at timestamp without time zone, p_docket_info_id integer, p_is_administratively_closed boolean) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_lit_id	INTEGER := NULL;
BEGIN

 IF p_title is NULL THEN
   RAISE EXCEPTION 'No title for lit: %', p_title;
 END IF;

 SELECT id
 INTO v_lit_id
 FROM core.lits
 WHERE case_key = p_case_key AND
      COALESCE(lit_cause_id, -1) = COALESCE(p_lit_cause_id, -1) AND
      COALESCE(nos, -1) = COALESCE(p_nos, -1) AND
      COALESCE(demand, -1) = COALESCE(p_demand, -1) AND
      COALESCE(docket_number_long, 'NA') = COALESCE(p_docket_number_long, 'NA') AND
      COALESCE(docket_number, 'NA') = COALESCE(p_docket_number, 'NA') AND
      COALESCE(jurisdiction, 'NA') = COALESCE(p_jurisdiction, 'NA') AND
      COALESCE(jury_demand, 'NA') = COALESCE(p_jury_demand, 'NA') AND
      COALESCE(filed_date, '1970-01-01') = COALESCE(p_filed_date, '1970-01-01') AND
      COALESCE(closed_date, '1970-01-01') = COALESCE(p_closed_date, '1970-01-01') AND
      COALESCE(is_open, false) = COALESCE(p_is_open, false) AND
      COALESCE(title, 'NA') = COALESCE(p_title, 'NA') AND
      COALESCE(case_type, 'NA') = COALESCE(p_case_type, 'NA') AND
      COALESCE(last_pacer_retrieval_for_summary, '1970-01-01'::timestamp) = COALESCE(p_last_pacer_retrieval_for_summary, '1970-01-01'::timestamp) AND
      COALESCE(last_pacer_retrieval_for_docket, '1970-01-01'::timestamp) = COALESCE(p_last_pacer_retrieval_for_docket, '1970-01-01'::timestamp) AND
      COALESCE(last_pacer_retrieval_for_parties, '1970-01-01'::timestamp) = COALESCE(p_last_pacer_retrieval_for_parties, '1970-01-01'::timestamp) AND
      COALESCE(has_spammy_parties, false) = COALESCE(p_has_spammy_parties, false) AND
      COALESCE(has_spammy_patents, false) = COALESCE(p_has_spammy_patents, false) AND
      COALESCE(has_complaint, false) = COALESCE(p_has_complaint, false) AND
      COALESCE(added_at, '1970-01-01'::timestamp) = COALESCE(p_added_at, '1970-01-01'::timestamp) AND
      COALESCE(docket_info_id, -1) = COALESCE(p_docket_info_id, -1) AND
      COALESCE(is_administratively_closed, false) = COALESCE(p_is_administratively_closed, false);

 ---if such record exists and no different from souce, return
 IF FOUND THEN
   RETURN v_lit_id;
 END IF;

 ---check if case_key exists
 SELECT id
 INTO v_lit_id
 FROM core.lits
 WHERE case_key = p_case_key;


 IF NOT FOUND THEN

   INSERT INTO core.lits
   (case_key ,lit_cause_id ,nos ,demand ,docket_number_long ,docket_number ,jurisdiction ,jury_demand ,filed_date ,closed_date ,is_open ,title ,case_type ,last_pacer_retrieval_for_summary ,last_pacer_retrieval_for_docket ,last_pacer_retrieval_for_parties ,has_spammy_parties ,has_spammy_patents ,has_complaint ,added_at ,docket_info_id ,is_administratively_closed
   )
   VALUES
   (p_case_key ,p_lit_cause_id ,p_nos ,p_demand ,p_docket_number_long ,p_docket_number ,p_jurisdiction ,p_jury_demand ,p_filed_date ,p_closed_date ,p_is_open ,p_title ,p_case_type ,p_last_pacer_retrieval_for_summary ,p_last_pacer_retrieval_for_docket ,p_last_pacer_retrieval_for_parties ,p_has_spammy_parties ,p_has_spammy_patents ,p_has_complaint ,p_added_at ,p_docket_info_id ,p_is_administratively_closed)
   RETURNING id INTO v_lit_id;

 ELSE
   UPDATE core.lits
   SET
       lit_cause_id = COALESCE(p_lit_cause_id, lit_cause_id),
       nos = COALESCE(p_nos, nos),
       demand = COALESCE(p_demand, demand),
       docket_number_long = COALESCE(p_docket_number_long, docket_number_long),
       docket_number = COALESCE(p_docket_number, docket_number),
       jurisdiction = COALESCE(p_jurisdiction, jurisdiction),
       jury_demand = COALESCE(p_jury_demand, jury_demand),
       filed_date = COALESCE(p_filed_date, filed_date),
       closed_date = p_closed_date,
       is_open = p_is_open,
       title = COALESCE(p_title, title),
       case_type = COALESCE(p_case_type, case_type),
       last_pacer_retrieval_for_summary = COALESCE(p_last_pacer_retrieval_for_summary, last_pacer_retrieval_for_summary),
       last_pacer_retrieval_for_docket = COALESCE(p_last_pacer_retrieval_for_docket, last_pacer_retrieval_for_docket),
       last_pacer_retrieval_for_parties = COALESCE(p_last_pacer_retrieval_for_parties, last_pacer_retrieval_for_parties),
       has_spammy_parties = COALESCE(p_has_spammy_parties, has_spammy_parties),
       has_spammy_patents = COALESCE(p_has_spammy_patents, has_spammy_patents),
       has_complaint = COALESCE(p_has_complaint, has_complaint),
       added_at = COALESCE(p_added_at, added_at),
       docket_info_id = p_docket_info_id,
       is_administratively_closed = COALESCE(p_is_administratively_closed, is_administratively_closed)
   WHERE id = v_lit_id;

 END IF;

 RETURN v_Lit_id;
END;
$$;


--
-- Name: create_or_update_lits(character varying, integer, integer, numeric, character varying, character varying, character varying, character varying, date, date, boolean, character varying, character varying, timestamp without time zone, timestamp without time zone, timestamp without time zone, boolean, boolean, boolean, timestamp without time zone, integer, boolean, date); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION create_or_update_lits(p_case_key character varying, p_lit_cause_id integer, p_nos integer, p_demand numeric, p_docket_number_long character varying, p_docket_number character varying, p_jurisdiction character varying, p_jury_demand character varying, p_filed_date date, p_closed_date date, p_is_open boolean, p_title character varying, p_case_type character varying, p_last_pacer_retrieval_for_summary timestamp without time zone, p_last_pacer_retrieval_for_docket timestamp without time zone, p_last_pacer_retrieval_for_parties timestamp without time zone, p_has_spammy_parties boolean, p_has_spammy_patents boolean, p_has_complaint boolean, p_added_at timestamp without time zone, p_docket_info_id integer, p_is_administratively_closed boolean, p_reopened_date date) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_lit_id   INTEGER := NULL;
 v_case_office_changed INTEGER :=NULL;
 v_continue_flag integer :=0;
 v_dummy integer :=0;
BEGIN

 IF p_title is NULL THEN
   RAISE EXCEPTION 'No title for lit: %', p_title;
 END IF;

 ----Removed has_complaint
 ----COALESCE(has_complaint, false) = COALESCE(p_has_complaint, false) AND
/* 02-09-2016 ateja_c
  Removed following code as it is updating stale data
  COALESCE(has_spammy_parties, false) = COALESCE(p_has_spammy_parties, false) AND
  COALESCE(has_spammy_patents, false) = COALESCE(p_has_spammy_patents, false) AND
  COALESCE(added_at, '1970-01-01'::timestamp) = COALESCE(p_added_at, '1970-01-01'::timestamp) AND

  4-11-2016 ateja_c
  DS-4185 Not to make any duplicate entry for the existinc case in core_lit_case aliases and a new docket is added in pacer

*/

 SELECT id
 INTO v_lit_id
 FROM core.lits
 WHERE case_key = p_case_key AND
      COALESCE(lit_cause_id, -1) = COALESCE(p_lit_cause_id, -1) AND
      COALESCE(nos, -1) = COALESCE(p_nos, -1) AND
      COALESCE(demand, -1) = COALESCE(p_demand, -1) AND
      COALESCE(docket_number_long, 'NA') = COALESCE(p_docket_number_long, 'NA') AND
      COALESCE(docket_number, 'NA') = COALESCE(p_docket_number, 'NA') AND
      COALESCE(jurisdiction, 'NA') = COALESCE(p_jurisdiction, 'NA') AND
      COALESCE(jury_demand, 'NA') = COALESCE(p_jury_demand, 'NA') AND
      COALESCE(filed_date, '1970-01-01') = COALESCE(p_filed_date, '1970-01-01') AND
      COALESCE(closed_date, '1970-01-01') = COALESCE(p_closed_date, '1970-01-01') AND
      COALESCE(is_open, false) = COALESCE(p_is_open, false) AND
      COALESCE(title, 'NA') = COALESCE(p_title, 'NA') AND
      COALESCE(case_type, 'NA') = COALESCE(p_case_type, 'NA') AND
      COALESCE(last_pacer_retrieval_for_summary, '1970-01-01'::timestamp) = COALESCE(p_last_pacer_retrieval_for_summary, '1970-01-01'::timestamp) AND
      COALESCE(last_pacer_retrieval_for_docket, '1970-01-01'::timestamp) = COALESCE(p_last_pacer_retrieval_for_docket, '1970-01-01'::timestamp) AND
      COALESCE(last_pacer_retrieval_for_parties, '1970-01-01'::timestamp) = COALESCE(p_last_pacer_retrieval_for_parties, '1970-01-01'::timestamp) AND
      COALESCE(docket_info_id, -1) = COALESCE(p_docket_info_id, -1) AND
      COALESCE(is_administratively_closed, false) = COALESCE(p_is_administratively_closed, false) AND
      COALESCE(reopened_date, '1970-01-01'::DATE) = COALESCE(p_reopened_date, '1970-01-01'::DATE);

 ---if such record exists and no different from souce, return
 IF FOUND THEN
 RAISE NOTICE 'Found exact match. Case key=% lit_id=%',p_case_key,v_lit_id;
   RETURN v_lit_id;
 ELSE
 END IF;

 ---check if case_key exists
 SELECT id
 INTO v_lit_id
 FROM core.lits
 WHERE case_key = p_case_key;

 /*

       Once merge is compelted. we do not further process the data from old docket info_id, unless it has more docket rows than the docket info id
       present in core.lits

        During the case merge:
        if the new case docket row count matches with docket row count in existing old case in core. then we just capture the mapping and exit.
        we not process the new case.

 */
  If FOUND THEN

     SELECT
        CASE WHEN
        (SELECT count(*) FROM core.docket_entries WHERE lit_id = v_lit_id) >
        (SELECT count(*) FROM pacer_data_service.docket_rows WHERE docket_info_id = p_docket_info_id)
        THEN 0 ELSE 1 END
    INTO v_continue_flag
    FROM core.lits l
    WHERE l.id = v_lit_id;

     IF v_continue_flag=0 THEN

      INSERT INTO pacer_data_service.pacer_etl_skipped_cases_docket_row_count (docket_info_id , lit_id ,pacer_cnt , core_cnt , notes )
      SELECT  p_docket_info_id , v_lit_id ,
              (select count(*) FROM pacer_data_service.docket_rows WHERE docket_info_id = p_docket_info_id) ,
              (SELECT count(*) FROM core.docket_entries WHERE lit_id = v_lit_id) ,
              'Skipped with case key found in core.lits but has less pacer dockets when compared to core'::varchar;

       RETURN -1;   --we are not processing since the docket info id we received belongs to old case( case with less docket rows)
                            --if we do not exit here. it will go to the end of this funciton and core will be updated  with old data and hence resulting in deleting new data.
     END IF;

ELSE

    /* Check is this a existing merge case ( Chance of title being changed can create a new entry  in core.lits
     with same docket_info_id for multiple lits which can cause issue )
    If existing merge case treat as a merged case else check the lit id basing on the title and filed_date , substring of docket_number
  */

    SELECT lit_id INTO v_lit_id  FROM core.lit_case_aliases WHERE  old_docket_info_id = p_docket_info_id OR new_docket_info_id = p_docket_info_id LIMIT 1;

    IF NOT FOUND THEN

      --title and filed_date have to be not null
      SELECT id INTO v_lit_Id FROM core.lits WHERE title = p_title AND filed_date = p_filed_date AND substring(docket_number, 2, length(docket_number)) = substring(p_docket_number, 2, length(p_docket_number));

    END IF;

    IF v_lit_id is NULL THEN

    INSERT INTO core.lits
    (case_key ,lit_cause_id ,nos ,demand ,docket_number_long ,docket_number ,jurisdiction ,jury_demand ,filed_date ,closed_date ,is_open ,title ,case_type ,last_pacer_retrieval_for_summary ,last_pacer_retrieval_for_docket ,last_pacer_retrieval_for_parties ,has_spammy_parties ,has_spammy_patents ,has_complaint ,added_at ,docket_info_id ,is_administratively_closed, reopened_date)
    VALUES
    (p_case_key ,p_lit_cause_id ,p_nos ,p_demand ,p_docket_number_long ,p_docket_number ,p_jurisdiction ,p_jury_demand ,p_filed_date ,p_closed_date ,p_is_open ,p_title ,p_case_type ,p_last_pacer_retrieval_for_summary ,p_last_pacer_retrieval_for_docket ,p_last_pacer_retrieval_for_parties ,p_has_spammy_parties ,p_has_spammy_patents ,p_has_complaint ,p_added_at ,p_docket_info_id ,p_is_administratively_closed, p_reopened_date)
    RETURNING id INTO v_lit_id;

    RETURN v_Lit_id;
   ELSE
    --- Here is the scenario we try to manage:
    --- if a case moved office the same day it is created, then we have two cases coming at the same time.
    --- in this way, there is no idea which case is the newer one by the timestamp.
    --- we have to use count of docket entries to tell if the case is the new one.
    --- if the older case happens to come later, we need to record the info in core.lit_case_aliases table
    --- then we return -1 without any update
    SELECT
        CASE WHEN
        (SELECT count(*) FROM core.docket_entries WHERE lit_id = v_lit_id) >=
        (SELECT count(*) FROM pacer_data_service.docket_rows WHERE docket_info_id = p_docket_info_id)
        THEN 0 ELSE 1 END
    INTO v_continue_flag
    FROM core.lits l
    WHERE l.id = v_lit_id;

    --capture the information in the mapping table.
    IF v_continue_flag = 0 THEN
     INSERT INTO core.lit_case_aliases (lit_id, old_case_key,new_case_key,old_docket_number,new_docket_number,old_docket_info_id,new_docket_info_id)
  SELECT v_lit_id, p_case_key, l.case_key, p_docket_number, l.docket_number, p_docket_info_id as old_docket_info_id,
   l.docket_info_id as new_docket_info_id
  FROM core.lits l WHERE l.id = v_lit_id
    AND NOT EXISTS (SELECT 1 FROM core.lit_case_aliases WHERE lit_id = v_lit_id AND /*new_case_key = l.case_key */
    new_docket_info_id = l.docket_info_id
     )
   and l.docket_info_id <> p_docket_info_id;
         IF  p_docket_info_id <> (select docket_info_id from core.lits where id=v_lit_id) then

               INSERT INTO pacer_data_service.pacer_etl_skipped_cases_docket_row_count (docket_info_id , lit_id ,pacer_cnt , core_cnt , notes )
                SELECT  p_docket_info_id , v_lit_id ,
                (select count(*) FROM pacer_data_service.docket_rows WHERE docket_info_id = p_docket_info_id) ,
                (SELECT count(*) FROM core.docket_entries WHERE lit_id = v_lit_id) ,
                'Skipped with case key not found in core.lits (merged case ) but has less pacer dockets when compared to core'::varchar;
                RETURN -1;

         END IF;

   ELSE
                        with dat as (select * from core.lit_case_aliases where old_docket_info_id=p_docket_info_id),
                                        ins as (
                                        INSERT INTO core.lit_case_aliases (lit_id, old_case_key,new_case_key,old_docket_number,new_docket_number,old_docket_info_id,new_docket_info_id)
                                                SELECT v_lit_id, l.case_key, p_case_key, l.docket_number, p_docket_number,l.docket_info_id as old_docket_info_id,p_docket_info_id as new_docket_info_id
                                                FROM core.lits l
                                                WHERE l.id = v_lit_id  AND NOT EXISTS (SELECT 1 FROM core.lit_case_aliases WHERE lit_id = v_lit_id AND new_case_key = l.case_key)
                                                returning id
                                        ),
                                        upd as (
                                        update  core.lit_case_aliases lca
                                        set old_docket_info_id=dat.new_docket_info_id,
                                                old_docket_number=dat.new_docket_number,
                                                new_docket_info_id=dat.old_docket_info_id,
                                                new_docket_number=dat.old_docket_number
                                                from dat
                                        where lca.old_docket_info_id=dat.old_docket_info_id and (select count(1) from ins)>0
                                        )
                                    select 1 into v_dummy;

    END IF;

   END IF;
 END IF;

/*
when a case changes office.
core will have old case key but new docket_number and docket_info_id
pacer will  have bothe versions of the records.
*/
 UPDATE core.lits
 SET
       lit_cause_id = COALESCE(p_lit_cause_id, lit_cause_id),
       nos = COALESCE(p_nos, nos),
       demand = COALESCE(p_demand, demand),
       docket_number_long = COALESCE(p_docket_number_long, docket_number_long),
       docket_number = COALESCE(p_docket_number, docket_number),
       jurisdiction = COALESCE(p_jurisdiction, jurisdiction),
       jury_demand = COALESCE(p_jury_demand, jury_demand),
       filed_date = COALESCE(p_filed_date, filed_date),
       closed_date = p_closed_date,
       is_open = p_is_open,
       title = COALESCE(p_title, title),
       case_type = COALESCE(p_case_type, case_type),
       last_pacer_retrieval_for_summary = COALESCE(p_last_pacer_retrieval_for_summary, last_pacer_retrieval_for_summary),
       last_pacer_retrieval_for_docket = COALESCE(p_last_pacer_retrieval_for_docket, last_pacer_retrieval_for_docket),
       last_pacer_retrieval_for_parties = COALESCE(p_last_pacer_retrieval_for_parties, last_pacer_retrieval_for_parties),
       docket_info_id = p_docket_info_id,
       is_administratively_closed = COALESCE(p_is_administratively_closed, is_administratively_closed),
       reopened_date = COALESCE(p_reopened_date, reopened_date)
 WHERE id = v_lit_id;

 RETURN v_Lit_id;
END;
$$;


--
-- Name: del_lit_parties(integer, boolean); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION del_lit_parties(p_lit_party_id integer, p_create_backup boolean DEFAULT true) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
t_sql text := '';
t_select text:='';
BEGIN
/*
1.0 14-Jul-2016 DS-3614 Delete lit parties and child tables and create backup based on flag
2.0 18-Oct-2016 N/A : Dynamic selection of target columns during insertion in _deleted tables
*/


  IF p_create_backup THEN

select core.get_select_string_all('core.lit_party_outcomes') into t_select;

    t_sql := '
      INSERT INTO core.lit_party_outcomes_deleted ('||t_select||') SELECT '||t_select||' FROM core.lit_party_outcomes WHERE lit_parties_id = $1;
  ';

select core.get_select_string_all('core.lit_parties_representations') into t_select;

t_sql := t_sql || '
      INSERT INTO core.lit_parties_representations_deleted ('||t_select||') SELECT '||t_select||' FROM core.lit_parties_representations WHERE lit_parties_id = $1;
  ';

select core.get_select_string_all('core.lit_parties') into t_select;

    t_sql := t_sql || '
      INSERT INTO core.lit_parties_deleted ('||t_select||') SELECT '||t_select||' FROM core.lit_parties WHERE ID = $1;
  ';

  END IF;

  t_sql := t_sql || '
      DELETE FROM core.lit_party_outcomes WHERE lit_parties_id = $1;
      DELETE FROM core.lit_parties_representations WHERE lit_parties_id = $1;
      DELETE FROM core.lit_parties WHERE ID = $1;
  ';

  EXECUTE t_sql USING p_lit_party_id;

  RETURN 1;

END;
$_$;


--
-- Name: delete_docket_entry(integer, integer[], integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION delete_docket_entry(p_docket_entry_id integer, p_old_document_ids integer[], p_old_main_document_id integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_orphan_candidates INT[];
 v_old_original_docket_text TEXT;
 v_entry_number INTEGER;
 v_date_filed DATE;
 v_lit_id INTEGER;
BEGIN

 ----gather information for orphaned documents
 SELECT lit_id, date_filed, entry_number, original_docket_text
 INTO v_lit_id, v_date_filed, v_entry_number, v_old_original_docket_text
 FROM core.docket_entries
 WHERE id = p_docket_entry_id;

 ---delete mapping with documents first
 DELETE FROM core.docket_entry_documents_map
 WHERE docket_entry_id = p_docket_entry_id AND
       lit_document_id in (
         SELECT p_old_main_document_id
         UNION ALL
         SELECT UNNEST(p_old_document_ids)
       );

 DELETE FROM core.docket_entries
 WHERE id = p_docket_entry_id;

 ---make input for orpahn document handling
 v_orphan_candidates := v_orphan_candidates || p_old_document_ids;
 v_orphan_candidates := v_orphan_candidates || p_old_main_document_id;

 ---handle orphan documents
 PERFORM core.handle_orphan_documents(
   v_orphan_candidates,
   v_lit_id,
   v_entry_number,
   v_date_filed,
   v_old_original_docket_text
 );

 RETURN p_docket_entry_id;
END;
$$;


--
-- Name: delete_ent_advanced_relationship_types(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION delete_ent_advanced_relationship_types(p_ent_advanced_relationship_types_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
deleted_rows INTEGER := 0 ;
BEGIN
/*
1.0 2015-02-06 user DS-809: New Function Created by core.generate_dml_func
*/
DELETE
FROM
core.ent_advanced_relationship_types
WHERE
ID = p_ent_advanced_relationship_types_id ;

GET DIAGNOSTICS deleted_rows = ROW_COUNT ;
IF deleted_rows > 0 THEN
RETURN p_ent_advanced_relationship_types_id ;
ELSE
RETURN - 1 ;
END IF ;

EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE '% %',SQLSTATE, sqlerrm ;
RETURN - 1 ;
END ;
$$;


--
-- Name: delete_ent_subtypes_map(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION delete_ent_subtypes_map(p_ent_subtypes_map_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
deleted_rows INTEGER := 0 ;
BEGIN
/*
1.0 rverma 23-FEB-2015 DS-809: New Function Created
*/
DELETE
FROM
core.ent_subtypes_map
WHERE
ID = p_ent_subtypes_map_id ;

GET DIAGNOSTICS deleted_rows = ROW_COUNT ;
IF deleted_rows > 0 THEN
RETURN p_ent_subtypes_map_id ;
ELSE
RETURN - 1 ;
END
IF ;

EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE '% %',SQLSTATE, sqlerrm ;
RETURN - 1 ;
END ;
$$;


--
-- Name: delete_ent_types(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION delete_ent_types(p_ent_types_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
deleted_rows INTEGER := 0 ;
BEGIN
/*
1.0 2015-02-06 user DS-809: New Function Created by core.generate_dml_func
*/
DELETE
FROM
core.ent_types
WHERE
ID = p_ent_types_id ;

GET DIAGNOSTICS deleted_rows = ROW_COUNT ;
IF deleted_rows > 0 THEN
RETURN p_ent_types_id ;
ELSE
RETURN - 1 ;
END
IF ;

EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE '% %',SQLSTATE, sqlerrm ;
RETURN - 1 ;
END ;
$$;


--
-- Name: delete_lit_relationships_tab(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION delete_lit_relationships_tab(p_lit_relationships_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
  deleted_rows integer :=0;
        v_lit_relationship_type varchar := NULL;
        v_lit_relationship_type_id integer := NULL;
  BEGIN
  /*
  1.0 2015-08-26 user DS-809: New Function Created by core.generate_dml_func_v2
  */
        SELECT lrt.name, lrt.id
        INTO v_lit_relationship_type, v_lit_relationship_type_id
        FROM core.lit_relationships lr, core.lit_relationship_types lrt
        WHERE lr.id = p_lit_relationships_id AND
              lr.lit_relationship_type_id = lrt.id;

        IF v_lit_relationship_type_id NOT IN (1,3,4) THEN

        RAISE EXCEPTION 'Only relationships in (transfer, consolidation, and severance) can be deleted, not for: %', v_lit_relationship_type;

        END IF;

  DELETE FROM core.lit_relationships WHERE id = p_lit_relationships_id;

  GET DIAGNOSTICS deleted_rows = ROW_COUNT;
  IF deleted_rows >0 THEN
  RETURN p_lit_relationships_id;
  ELSE
  RETURN -1;
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
  RAISE NOTICE '% %', sqlstate, sqlerrm;
  RETURN -1;
  END;
  $$;


--
-- Name: district_court_court_alias_role_trig_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION district_court_court_alias_role_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
    IF (TG_OP = 'UPDATE') THEN
      IF (1 = 1) THEN
       IF (COALESCE(OLD.alias_id, -1) <> COALESCE(NEW.alias_id, -1)) OR (1 <> 1) THEN
         IF OLD.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.lit_courts', 'alias_id', OLD.alias_id, 'D', 'district_court_court');
         END IF;
         IF NEW.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.lit_courts', 'alias_id', NEW.alias_id, 'I', 'district_court_court');
         END IF;
       END IF;
      END IF;
      RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('core.lit_courts', 'alias_id', OLD.alias_id, 'D', 'district_court_court');
        END IF;
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('core.lit_courts', 'alias_id', NEW.alias_id, 'I', 'district_court_court');
        END IF;
        RETURN NEW;
    ELSE
        RAISE EXCEPTION '[core..district_court_court_alias_role_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core..district_court_court_alias_role_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core..district_court_court_alias_role_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core..district_court_court_alias_role_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: district_court_judge_alias_role_trig_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION district_court_judge_alias_role_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
    IF (TG_OP = 'UPDATE') THEN
      IF (1 = 1) THEN
       IF (COALESCE(OLD.alias_id, -1) <> COALESCE(NEW.alias_id, -1)) OR (1 <> 1) THEN
         IF OLD.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.lit_judges_map', 'alias_id', OLD.alias_id, 'D', 'district_court_judge');
         END IF;
         IF NEW.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.lit_judges_map', 'alias_id', NEW.alias_id, 'I', 'district_court_judge');
         END IF;
       END IF;
      END IF;
      RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('core.lit_judges_map', 'alias_id', OLD.alias_id, 'D', 'district_court_judge');
        END IF;
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('core.lit_judges_map', 'alias_id', NEW.alias_id, 'I', 'district_court_judge');
        END IF;
        RETURN NEW;
    ELSE
        RAISE EXCEPTION '[core..district_court_judge_alias_role_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core..district_court_judge_alias_role_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core..district_court_judge_alias_role_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core..district_court_judge_alias_role_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: district_court_lawfirm_alias_role_trig_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION district_court_lawfirm_alias_role_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
    IF (TG_OP = 'UPDATE') THEN
      IF (1 = 1) THEN
       IF (COALESCE(OLD.lawfirm_alias_id, -1) <> COALESCE(NEW.lawfirm_alias_id, -1)) OR (1 <> 1) THEN
         IF OLD.lawfirm_alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.lit_parties_representations', 'lawfirm_alias_id', OLD.lawfirm_alias_id, 'D', 'district_court_lawfirm');
         END IF;
         IF NEW.lawfirm_alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.lit_parties_representations', 'lawfirm_alias_id', NEW.lawfirm_alias_id, 'I', 'district_court_lawfirm');
         END IF;
       END IF;
      END IF;
      RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('core.lit_parties_representations', 'lawfirm_alias_id', OLD.lawfirm_alias_id, 'D', 'district_court_lawfirm');
        END IF;
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('core.lit_parties_representations', 'lawfirm_alias_id', NEW.lawfirm_alias_id, 'I', 'district_court_lawfirm');
        END IF;
        RETURN NEW;
    ELSE
        RAISE EXCEPTION '[core..district_court_lawfirm_alias_role_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core..district_court_lawfirm_alias_role_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core..district_court_lawfirm_alias_role_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core..district_court_lawfirm_alias_role_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: district_court_lawyer_alias_role_trig_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION district_court_lawyer_alias_role_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
    IF (TG_OP = 'UPDATE') THEN
      IF (1 = 1) THEN
       IF (COALESCE(OLD.lawyer_alias_id, -1) <> COALESCE(NEW.lawyer_alias_id, -1)) OR (1 <> 1) THEN
         IF OLD.lawyer_alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.lit_parties_representations', 'lawyer_alias_id', OLD.lawyer_alias_id, 'D', 'district_court_lawyer');
         END IF;
         IF NEW.lawyer_alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.lit_parties_representations', 'lawyer_alias_id', NEW.lawyer_alias_id, 'I', 'district_court_lawyer');
         END IF;
       END IF;
      END IF;
      RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('core.lit_parties_representations', 'lawyer_alias_id', OLD.lawyer_alias_id, 'D', 'district_court_lawyer');
        END IF;
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('core.lit_parties_representations', 'lawyer_alias_id', NEW.lawyer_alias_id, 'I', 'district_court_lawyer');
        END IF;
        RETURN NEW;
    ELSE
        RAISE EXCEPTION '[core..district_court_lawyer_alias_role_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core..district_court_lawyer_alias_role_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core..district_court_lawyer_alias_role_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core..district_court_lawyer_alias_role_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: district_court_party_alias_role_trig_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION district_court_party_alias_role_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
    IF (TG_OP = 'UPDATE') THEN
      IF (1 = 1) THEN
       IF (COALESCE(OLD.alias_id, -1) <> COALESCE(NEW.alias_id, -1)) OR (1 <> 1) THEN
         IF OLD.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.lit_parties', 'alias_id', OLD.alias_id, 'D', 'district_court_party');
         END IF;
         IF NEW.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.lit_parties', 'alias_id', NEW.alias_id, 'I', 'district_court_party');
         END IF;
       END IF;
      END IF;
      RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('core.lit_parties', 'alias_id', OLD.alias_id, 'D', 'district_court_party');
        END IF;
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('core.lit_parties', 'alias_id', NEW.alias_id, 'I', 'district_court_party');
        END IF;
        RETURN NEW;
    ELSE
        RAISE EXCEPTION '[core..district_court_party_alias_role_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core..district_court_party_alias_role_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core..district_court_party_alias_role_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core..district_court_party_alias_role_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: dma_lit_annotations_before_tr(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION dma_lit_annotations_before_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN


-- tazhagan_c DS-1885 29-Jun-2015 : Update is_npe_suit as per changes in lit_curated_cause_type_id and lit_type_id
-- ateja_c DS-3821 09-06-2016 : Update is_npe_suit as per changes in lit_type_id
-- tazhagan_c DS-4171 03-Aug-2016 : Update core.dma_lit_annotations trigger to not consider is_dj flag based on lit_curated_cause_type_id

    IF TG_OP = 'UPDATE' THEN
        IF session_user = 'dma_app' THEN
            -- If the user is coming from the DMA don't let them update the lit_stage_id
            NEW.lit_stage_id := OLD.lit_stage_id;
        END IF;

        /*
        IF NEW.lit_curated_cause_type_id = 7 THEN
            NEW.is_dj := TRUE;
        ELSIF NEW.lit_curated_cause_type_id IS NULL THEN
            NEW.is_dj := FALSE;
        ELSE
            NEW.is_dj := FALSE;
        END IF;
        */

IF COALESCE(NEW.lit_type_id,-1) != COALESCE(OLD.lit_type_id,-1)
THEN
IF ((select name from core.lit_types where id=new.lit_type_id) in ('NPE','UNI','INV','NCE', 'Patent Licensing Company'))
THEN
NEW.is_npe_suit := TRUE;
ELSE
NEW.is_npe_suit := FALSE;
END IF;
END IF;

        RETURN NEW;

    ELSIF (TG_OP = 'DELETE') THEN
        RETURN OLD;

    ELSIF (TG_OP = 'INSERT') THEN

        /*
        IF NEW.lit_curated_cause_type_id = 7 THEN
            NEW.is_dj := TRUE;
        ELSIF NEW.lit_curated_cause_type_id IS NULL THEN
            NEW.is_dj := FALSE;
        ELSE
            NEW.is_dj := FALSE;
        END IF;
        */

IF ((select name from core.lit_types where id=new.lit_type_id) in ('NPE','UNI','INV','NCE', 'Patent Licensing Company'))
THEN
NEW.is_npe_suit := TRUE;
ELSE
NEW.is_npe_suit := FALSE;
END IF;

        RETURN NEW;

    ELSE
        RAISE EXCEPTION '[core.dma_lit_annotations_before_tr] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core.dma_lit_annotations_before_tr] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core.dma_lit_annotations_before_tr] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core.dma_lit_annotations_before_tr] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: docket_entry_score(text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION docket_entry_score(p_docket_entry_text text) RETURNS real
    LANGUAGE plperl
    AS $_$

  my($work_name) = @_ ;
  my($rel_score) = 1.0000;

  $work_name =~ s/(<[^<]*>|^[\*\t\n ]*)//g;

  #positive attributes
  if ($work_name =~ m/order/i)
    {$rel_score = $rel_score * 2}
  if ($work_name =~ m/judge/i)
    {$rel_score = $rel_score * 1.25}
  if ($work_name =~ m/overruling/i)
    {$rel_score = $rel_score * 2}
  if ($work_name =~ m/markman/i)
    {$rel_score = $rel_score * 2}
  if ($work_name =~ m/granting/i)
    {$rel_score = $rel_score * 2}
  if ($work_name =~ m/denying/i)
    {$rel_score = $rel_score * 2}
  if ($work_name =~ m/lack of jurisdiction/i)
    {$rel_score = $rel_score * 3}
  if ($work_name =~ m/order.*consolidat[a-z]* case/i)
    {$rel_score = $rel_score * 3}
  if ($work_name =~ m/(transfer|change( of)? venue)/i)
    {$rel_score = $rel_score * 2}
  if ($work_name =~ m/(misjoinder|sever)/i)
    {$rel_score = $rel_score * 1.5}
  if ($work_name =~ m/daubert/i)
    {$rel_score = $rel_score * 1.1}
  if ($work_name =~ m/transfered/i)
    {$rel_score = $rel_score * 2}
  if ($work_name =~ m/dismiss/i)
    {$rel_score = $rel_score * 2}
  if ($work_name =~ m/injunction/i)
    {$rel_score = $rel_score * 2}
  if ($work_name =~ m/bankrupt/i)
    {$rel_score = $rel_score * 2}
  if ($work_name =~ m/order.*dismiss.*prejudice/i)
    {$rel_score = $rel_score * 2}
  if ($work_name =~ m/to stay/i)
    {$rel_score = $rel_score * 2}
  if ($work_name =~ m/Voluntary Dismissal/i)
    {$rel_score = $rel_score * 4}
  if ($work_name =~ m/settled/i)
    {$rel_score = $rel_score * 2}
  if ($work_name =~ m/damages/i)
    {$rel_score = $rel_score * 2}
  if ($work_name =~ m/(&#036;|\$) ?[\d,]{4,6}/i)
    {$rel_score = $rel_score * 2}
  if ($work_name =~ m/(&#036;|\$) ?[\d,]{7,}/i)
    {$rel_score = $rel_score * 4}
  if ($work_name =~ m/(&#036;|\$) ?[\d,\.]{1,} ?(m|b)illion/i)
    {$rel_score = $rel_score * 7}
  if ($work_name =~ m/agree.*settle/i)
    {$rel_score = $rel_score * 3}
  if ($work_name =~ m/re.?exam/i)
    {$rel_score = $rel_score * 4}
  if ($work_name =~ m/^final judge?ment/i)
    {$rel_score = $rel_score * 7}
  if ($work_name =~ m/^(JURY VERDICT|verdict)/i)
    {$rel_score = $rel_score * 7}
  if ($work_name =~ m/^judge?ment/i)
    {$rel_score = $rel_score * 5}
  if ($work_name =~ m/recus(al|ed)/i)
    {$rel_score = $rel_score * 5}
  if ($work_name =~ m/validity/i)
    {$rel_score = $rel_score * 5}
  if ($work_name =~ m/nfringment/i)
    {$rel_score = $rel_score * 4}
  if ($work_name =~ m/([^[:alnum:]]I\.?T\.?C[^[:alnum:]]|(intl.?|international) trade commission)/i)
    {$rel_score = $rel_score * 5}
  if ($work_name =~ m/order.*([^[:alnum:]]I\.?T\.?C[^[:alnum:]]|international trade commission)/i)
    {$rel_score = $rel_score * 4}
  if ($work_name =~ m/337\-TA/i)
    {$rel_score = $rel_score * 7}

  #Negative attributes
  if ($work_name =~ m/motion to seal/i)
    {$rel_score = $rel_score * 0.9}
  if ($work_name =~ m/seal/i)
    {$rel_score = $rel_score * 0.9}
  if ($work_name =~ m/order.*filed.*seal/i)
    {$rel_score = $rel_score * 0.75}
  if ($work_name =~ m/disclosure statement/i)
    {$rel_score = $rel_score * 0.75}
  if ($work_name =~ m/deadline/i)
    {$rel_score = $rel_score * 0.5}
  if ($work_name =~ m/date set/i)
    {$rel_score = $rel_score * 0.75}
  if ($work_name =~ m/administrative/i)
    {$rel_score = $rel_score * 0.5}
  if ($work_name =~ m/permit use of.*equipment/i)
    {$rel_score = $rel_score * 0.2}
  if ($work_name =~ m/((exhibit|attachment).*){3,}/i)
    {$rel_score = $rel_score * 0.25}
  if ($work_name =~ m/filed.*error/i)
    {$rel_score = $rel_score * 0.5}
  if ($work_name =~ m/scheduling/i)
    {$rel_score = $rel_score * 0.75}
  if ($work_name =~ m/scheduling conference/i)
    {$rel_score = $rel_score * 0.75}
  if ($work_name =~ m/change of (name|address|date)/i)
    {$rel_score = $rel_score * 0.5}
  if ($work_name =~ m/exten[a-z]*( of)? time/i)
    {$rel_score = $rel_score * 0.2}
  if ($work_name =~ m/date change/i)
    {$rel_score = $rel_score * 0.5}
  if ($work_name =~ m/transcript/i)
    {$rel_score = $rel_score * 0.5}
  if ($work_name =~ m/Pro Hac Vice/i)
    {$rel_score = $rel_score * 0.25}
  if ($work_name =~ m/ATTORNEY Appearance/i)
    {$rel_score = $rel_score * 0.25}
  if ($work_name =~ m/^declaration/i)
    {$rel_score = $rel_score * 0.25}
  if ($work_name =~ m/^(notice|minute|summon|proposed|stipulation|redacted|amend|protective|index|(sur.?)?reply|case manag)/i)
    {$rel_score = $rel_score * 0.75}
  if ($work_name =~ m/case management con/i)
    {$rel_score = $rel_score * 0.5}
  if ($work_name =~ m/^Correspondence/i)
    {$rel_score = $rel_score * 0.75}
  if ($work_name =~ m/(substi[a-z]*|withdraw.?) (as )?(counsel|attorney|represen)/i)
    {$rel_score = $rel_score * 0.1}
  if ($work_name =~ m/\d+.?(a|p).?m[^[:alnum:]]/i)
    {$rel_score = $rel_score * 0.1}


  return($rel_score);

$_$;


--
-- Name: ent_subtypes_map_update_alias_ent_details_boolean_flds_tr_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION ent_subtypes_map_update_alias_ent_details_boolean_flds_tr_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN

  /*
  1.0 vpemmaraju 16-06-2015 DS-4461 New trigger created for updating boolean fields in core.alias_ent_details
  */
  /*
  Notes: checked audit table. there are no deletes performed on this table.
  */
  --CHECK IF DELETE IS HAPPENNING. CHECK AUDIT
   IF (TG_OP = 'UPDATE') THEN
    IF  coalesce(old.ent_subtype_id , -1) != coalesce(new.ent_subtype_id , -1) THEN
      UPDATE core.alias_ent_details
	  SET
	  is_patent_licensing_co = case NEW.ent_subtype_id when 1 then TRUE else FALSE end, --Patent Licensing Compan
	  is_npe = case NEW.ent_subtype_id when 2 then TRUE else FALSE end, --NPE
	  is_defensive_entity =case NEW.ent_subtype_id when 3 then TRUE else FALSE end --Defensive Entity
	  WHERE ent_id = NEW.ent_ID;
    END IF;
  ELSIF (TG_OP = 'INSERT') THEN
      UPDATE core.alias_ent_details
	  SET
	  is_patent_licensing_co = case NEW.ent_subtype_id when 1 then TRUE else FALSE end, --Patent Licensing Compan
	  is_npe = case NEW.ent_subtype_id when 2 then TRUE else FALSE end, --NPE
	  is_defensive_entity =case NEW.ent_subtype_id when 3 then TRUE else FALSE end --Defensive Entity
	  WHERE ent_id = NEW.ent_ID;
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: ents_alias_ent_details_trig_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION ents_alias_ent_details_trig_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
 /*
1.0 vpemmaraju 19-Jun-2017 DS-5470 : add sf_account_id and sf_account_type
*/
    IF (TG_OP = 'UPDATE') THEN
            IF (
                (NEW.name <> OLD.name)
                OR (coalesce(NEW.salesforce_id,'')<>coalesce(OLD.salesforce_id,''))
                OR (coalesce(NEW.ultimate_parent_id, -1) <> coalesce(OLD.ultimate_parent_id,-1))
                OR  (coalesce(NEW.ent_type_id,-1) <> coalesce(OLD.ent_type_id,-1))
                   ) THEN --included check inside
                      UPDATE core.alias_ent_details
                        SET ent_name = NEW.name ,
                        sf_account_id=NEW.salesforce_id ,
                        sf_account_type=(select typex from sf.accountx where id=NEW.salesforce_id),
                        ultimate_parent_id = NEW.ultimate_parent_id,
                        ultimate_parent_name = (SELECT ents1.name FROM  core.ents ents1 WHERE ents1.id = NEW.ultimate_parent_id),
                        ent_type_id = NEW.ent_type_id
                        WHERE ent_id = NEW.id;
	       END IF;

        UPDATE core.alias_ent_details
        SET ultimate_parent_name = NEW.name
        WHERE (ultimate_parent_id = NEW.id) and
	coalesce(ultimate_parent_name,'')<>coalesce(NEW.name,''); --update only if change

      RETURN NEW;
    END IF;

    ---DELETE/INSERT no action
    ---assume aliases/ents update handle them
    IF (TG_OP = 'DELETE') THEN
        RETURN OLD;
    END IF;

    IF (TG_OP = 'INSERT') THEN
        RETURN NEW;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core..ents_alias_ent_details_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core..ents_alias_ent_details_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core..ents_alias_ent_details_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: ents_default_parent_tr(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION ents_default_parent_tr() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
    IF (TG_OP = 'INSERT') THEN
        IF (NEW.ultimate_parent_id IS NULL) OR (NEW.rollup_parent_id IS NULL) THEN
            IF NEW.ultimate_parent_id IS NULL THEN
		        NEW.ultimate_parent_id = NEW.id;
            END IF;

            IF NEW.rollup_parent_id IS NULL THEN
                NEW.rollup_parent_id = NEW.id;
            END IF;

            UPDATE core.ents
            SET ultimate_parent_id = NEW.ultimate_parent_id,
                rollup_parent_id = NEW.rollup_parent_id
            WHERE id = NEW.id;
        END IF;

        RETURN NEW;
    ELSE
        -- Do nothing for existing records
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE WARNING '[core.ents_default_parent_tr] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE WARNING '[core.ents_default_parent_tr] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE WARNING '[core.ents_default_parent_tr] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: find_ent_for_alias(text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION find_ent_for_alias(as_seen text) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    ent_id        INTEGER;
    c_name        CURSOR ( seek_name TEXT ) IS SELECT ent_id FROM core.aliases AS a WHERE a.name        = seek_name AND a.ent_id IS NOT NULL ORDER BY core.score_string(seek_name, aliases.name) DESC LIMIT 1;
    c_lower_strip CURSOR ( seek_name TEXT ) IS SELECT ent_id FROM core.aliases AS a WHERE a.lower_strip = seek_name AND a.ent_id IS NOT NULL ORDER BY core.score_string(seek_name, aliases.name) DESC LIMIT 1;
    c_core_name   CURSOR ( seek_name TEXT ) IS SELECT ent_id FROM core.aliases AS a WHERE a.core_name   = seek_name AND a.ent_id IS NOT NULL ORDER BY core.score_string(seek_name, aliases.name) DESC LIMIT 1;
    c_fingerprint CURSOR ( seek_name TEXT ) IS SELECT ent_id FROM core.aliases AS a WHERE a.fingerprint = seek_name AND a.ent_id IS NOT NULL ORDER BY core.score_string(seek_name, aliases.name) DESC LIMIT 1;
BEGIN
    ent_id := NULL;
    OPEN  c_name(as_seen); FETCH c_name INTO ent_id; CLOSE c_name;
    IF ent_id is NULL THEN
        OPEN  c_lower_strip(as_seen); FETCH c_lower_strip INTO ent_id; CLOSE c_lower_strip;
        IF ent_id is NULL THEN
            OPEN  c_core_name(as_seen); FETCH c_core_name INTO ent_id; CLOSE c_core_name;
            IF ent_id is NULL THEN
                OPEN  c_fingerprint(as_seen); FETCH c_fingerprint INTO ent_id; CLOSE c_fingerprint;
            END if;
        END if;
    END if;

    return ent_id;
END;
$$;


--
-- Name: find_lit_case_type(integer[], character varying[]); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION find_lit_case_type(p_lit_ids integer[] DEFAULT NULL::integer[], p_case_keys character varying[] DEFAULT NULL::character varying[]) RETURNS TABLE(lit_id integer, case_key character varying, case_type_name character varying, case_type_id integer)
    LANGUAGE plpgsql
    AS $_$
DECLARE
  v_sql text := '';
BEGIN
/*
1.1 tazhagan_c 15-Oct-2015 DS-1893 : Modify the inventor logic in inventor section to join on core_name as per Seth Besse
1.2 anarayanan 28-Oct-2015 DS-1893 : Change the API based on lookup values instead of names
1.3 anarayanan 16-Nov-2015 DS-1893 : Added lookup values for Patent Licensing Company and Government
1.4 anarayanan 16-Nov-2015 DS-1893 : Updated logic for Government
1.5 aprakash_c 17-Nov-2015 DS-1893 : updated the logic for Government
1.6 aprakash_c 19-Nov-2015 DS-1893 : added NCE and Pending Review case types
1.7 anarayanan 12-Dec-2015 DS-1893 : Extended NPE logic to Individual ent type as well
2.1 ateja_c 07-July-2016 Ds-4009 : Added filter in NPE logic only for plaintiff,defendant
2.2 ateja_c 13-July-2016 Ds-4009 : Added filter missing_from_source_date is NULL
3.0 tazhagan_c 28-July-2017 DS-5685 : Change of precedence for inventor case type
*/
  v_sql := '
    WITH in_lits AS (
      SELECT
        lits. ID AS lit_id,
        case_key,
        lits.filed_date
      FROM
        core.lits
      WHERE
      (
        $1 IS NULL AND $2 IS NULL
      )
      OR
        lits. ID = ANY ($1)
      OR lits.case_key = ANY ($2)
    ),
  nce AS (
      SELECT
        il.lit_id,
        il.case_key,
        il.filed_date,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        in_lits il
      INNER JOIN core.lit_annotations la ON la.lit_id = il.lit_id
    INNER JOIN core.lit_types lt ON lt. ID = la.lit_type_id
    WHERE
    /*  lt. NAME = ''NCE''  */
    lt. ID = 16
      GROUP BY 1, 2, 3, 4, 5
    ),
     npe AS (
      SELECT
        il.lit_id,
        il.case_key,
        il.filed_date,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        (
          SELECT lit_id, case_key, filed_date FROM in_lits
          EXCEPT SELECT lit_id, case_key, filed_date FROM nce
        ) il
      INNER JOIN core.lit_parties lp ON lp.lit_id = il.lit_id
      INNER JOIN core.aliases al ON al. ID = lp.alias_id
      INNER JOIN core.ents ON ents. ID = al.ent_id
      INNER JOIN core.ent_subtypes_map esm ON (
        esm.ent_id = ents. ID
        AND il.filed_date BETWEEN COALESCE (
          esm.start_date,
          ''1900-01-01''
        )
        AND COALESCE (esm.end_date, ''3000-01-01'')
      )
      INNER JOIN core.ent_subtypes es ON (
        es. ID = esm.ent_subtype_id
        /*AND es. NAME = ''NPE''*/
        AND es. ID = 2
      )
      INNER JOIN core.lit_types lt ON (
        /*lt. NAME = ''NPE''*/
        lt. ID = 1
      )
       WHERE lp.dj_party_normalized_type in (''plaintiff'',''defendant'')
       AND lp.missing_from_source_date is NULL
      GROUP BY 1, 2, 3, 4, 5
    ),
     plc AS (
      SELECT
        il.lit_id,
        il.case_key,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        (
          SELECT lit_id, case_key, filed_date FROM in_lits
          EXCEPT SELECT lit_id, case_key, filed_date FROM nce
          EXCEPT SELECT lit_id, case_key, filed_date FROM npe
        ) il
      INNER JOIN core.lit_parties lp ON (
        lp.lit_id = il.lit_id
        AND lp.dj_party_normalized_type = ''plaintiff''
      )
      INNER JOIN core.aliases al ON al. ID = lp.alias_id
      INNER JOIN core.ents ON ents. ID = al.ent_id
      INNER JOIN core.ent_types et ON (
        et. ID = ents.ent_type_id
        /*AND et. NAME IN (
          ''Company'',
          ''Consortium'',
          ''Research Organization''
        )*/
        AND et. ID IN (1, 8, 7)
      )
      INNER JOIN core.lit_types lt ON (
        /*lt. NAME = ''Patent Licensing Company''*/
        lt. ID = 23
      )
      INNER JOIN core.ent_subtypes_map esm ON (
        esm.ent_id = ents. ID
        AND il.filed_date BETWEEN COALESCE (
          esm.start_date,
          ''1900-01-01''
        )
        AND COALESCE (esm.end_date, ''3000-01-01'')
      )
      INNER JOIN core.ent_subtypes es ON (
        es. ID = esm.ent_subtype_id
        /*AND es. NAME = ''Patent Licensing Company''*/
        AND es. ID = 1
      ) WHERE lp.missing_from_source_date is NULL
      GROUP BY 1, 2, 3, 4
    ),
     university AS (
      SELECT
        il.lit_id,
        il.case_key,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        (
          SELECT lit_id, case_key FROM in_lits
          EXCEPT SELECT lit_id, case_key FROM nce
          EXCEPT SELECT lit_id, case_key FROM npe
          EXCEPT SELECT lit_id, case_key FROM plc
        ) il
      INNER JOIN core.lit_parties lp ON (
        lp.lit_id = il.lit_id
        AND lp.dj_party_normalized_type = ''plaintiff''
      )
      INNER JOIN core.aliases al ON al. ID = lp.alias_id
      INNER JOIN core.ents ON ents. ID = al.ent_id
      INNER JOIN core.ent_types et ON (
        et. ID = ents.ent_type_id
        /*AND et. NAME = ''University''*/
        AND et. ID = 5
      )
      INNER JOIN core.lit_types lt ON (
        /*lt. NAME = ''UNI''*/
        lt. ID = 4
      ) WHERE lp.missing_from_source_date is NULL
      GROUP BY 1, 2, 3, 4
    ),
     oc AS (
      SELECT
        il.lit_id,
        il.case_key,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        (
          SELECT lit_id, case_key FROM in_lits
          EXCEPT SELECT lit_id, case_key FROM nce
          EXCEPT SELECT lit_id, case_key FROM npe
          EXCEPT SELECT lit_id, case_key FROM plc
          EXCEPT SELECT lit_id, case_key FROM university
        ) il
      INNER JOIN core.lit_parties lp ON (
        lp.lit_id = il.lit_id
        AND lp.dj_party_normalized_type = ''plaintiff''
      )
      INNER JOIN core.aliases al ON al. ID = lp.alias_id
      INNER JOIN core.ents ON ents. ID = al.ent_id
      INNER JOIN core.ent_types et ON (
        et. ID = ents.ent_type_id
        /*AND et. NAME = ''Company''*/
        AND et. ID = 1
      )
      INNER JOIN core.lit_types lt ON (
        /*lt. NAME = ''Operating Company''*/
        lt. ID = 11
      ) WHERE lp.missing_from_source_date is NULL
      GROUP BY 1, 2, 3, 4
    ),
     inventor AS (
      SELECT
        il.lit_id,
        il.case_key,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        (
          SELECT lit_id, case_key FROM in_lits
          EXCEPT SELECT lit_id, case_key FROM nce
          EXCEPT SELECT lit_id, case_key FROM npe
          EXCEPT SELECT lit_id, case_key FROM plc
          EXCEPT SELECT lit_id, case_key FROM university
          EXCEPT SELECT lit_id, case_key FROM oc
        ) il
      INNER JOIN core.lit_parties lp ON (
        lp.lit_id = il.lit_id
        AND lp.dj_party_normalized_type = ''plaintiff''
      )
      INNER JOIN core.aliases al ON al. ID = lp.alias_id
      INNER JOIN core.ents ON ents. ID = al.ent_id
      INNER JOIN core.ent_types et ON (
        et. ID = ents.ent_type_id
        /*AND et. NAME = ''Individual''*/
        AND et. ID = 2
      )
      LEFT JOIN core.lits_pats_map lpm ON lpm.lit_id = lp.lit_id
      INNER JOIN core.pats ON pats.stripped_patnum = lpm.patnum
      INNER JOIN core.aliases al_all ON al_all.ent_id = ents. ID
      INNER JOIN core.pats_aliases_map pam ON (pam.pat_id = pats. ID)
    INNER JOIN core.aliases pa ON (pa.id = pam.alias_id and pa.core_name = al_all.core_name)
      INNER JOIN core.pats_aliases_relationship_types part ON (
        part. ID = pam.pats_aliases_relationship_type_id
        /*AND part. NAME = ''Inventor''*/
        AND part. ID = 7
      )
      INNER JOIN core.lit_types lt ON (
        /*lt. NAME = ''INV''*/
        lt. ID = 7
      ) WHERE NOT EXISTS (
            SELECT 1
            FROM core.ent_types et_inr
            INNER JOIN core.ents e_inr ON e_inr.ent_type_id = et_inr. ID
            INNER JOIN core.aliases al_inr ON al_inr.ent_id = e_inr.ID
            INNER JOIN core.lit_parties lp_inr ON (lp_inr.alias_id = al_inr. ID AND lp_inr.dj_party_normalized_type = ''plaintiff'')
            WHERE lp_inr.lit_id = il.lit_id AND et_inr. ID != 2 and lp_inr.missing_from_source_date is NULL
          ) AND lp.missing_from_source_date is NULL
      GROUP BY 1, 2, 3, 4
    ),
     gov AS (
      SELECT
        il.lit_id,
        il.case_key,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        (
          SELECT lit_id, case_key FROM in_lits
      EXCEPT SELECT lit_id, case_key FROM nce
          EXCEPT SELECT lit_id, case_key FROM npe
          EXCEPT SELECT lit_id, case_key FROM plc
          EXCEPT SELECT lit_id, case_key FROM university
          EXCEPT SELECT lit_id, case_key FROM oc
          EXCEPT SELECT lit_id, case_key FROM inventor
        ) il
      INNER JOIN core.lit_parties lp ON (
        lp.lit_id = il.lit_id
        AND lp.dj_party_normalized_type = ''plaintiff''
      )
      INNER JOIN core.aliases al ON al. ID = lp.alias_id
      INNER JOIN core.ents ON ents. ID = al.ent_id
      INNER JOIN core.lit_types lt ON (
        /*lt. NAME = ''Government''*/
        lt. ID = 24
      )
       INNER JOIN core.ent_types et ON (
        et. ID = ents.ent_type_id
        /*AND et. NAME = ''Government''*/
            AND et. ID = 3
      )
      WHERE
        NOT EXISTS (
            SELECT 1
            FROM core.ent_types et_inr
            INNER JOIN core.ents e_inr ON e_inr.ent_type_id = et_inr. ID
            INNER JOIN core.aliases al_inr ON al_inr.ent_id = e_inr.ID
            INNER JOIN core.lit_parties lp_inr ON (lp_inr.alias_id = al_inr. ID AND lp_inr.dj_party_normalized_type = ''plaintiff'')
            WHERE lp_inr.lit_id = il.lit_id AND et_inr. ID != 3 and lp_inr.missing_from_source_date is NULL
          ) AND lp.missing_from_source_date is NULL
      GROUP BY 1, 2, 3, 4
    ),
  pending_review AS (
      WITH source_lits AS
    (SELECT
        il.lit_id,
        il.case_key
      FROM
        (
          SELECT lit_id, case_key FROM in_lits
      EXCEPT SELECT lit_id, case_key FROM nce
          EXCEPT SELECT lit_id, case_key FROM npe
          EXCEPT SELECT lit_id, case_key FROM plc
          EXCEPT SELECT lit_id, case_key FROM university
          EXCEPT SELECT lit_id, case_key FROM oc
          EXCEPT SELECT lit_id, case_key FROM inventor
          EXCEPT SELECT lit_id, case_key FROM gov
        ) il
    )
    (SELECT
      sl.lit_id,
      sl.case_key,
      lt. NAME AS case_type_name,
      lt. ID AS case_type_id
      FROM
        source_lits sl
        INNER JOIN core.lit_annotations la ON la.lit_id = sl.lit_id
        INNER JOIN core.lit_types lt ON (
        /*  lt. NAME = ''Pending Review'' */
        lt. ID = 25
        )
        WHERE la.lit_curated_cause_type_id IS NULL
        GROUP BY 1, 2, 3, 4)
      UNION
    (SELECT
      sl.lit_id,
      sl.case_key,
      lt. NAME AS case_type_name,
      lt. ID AS case_type_id
      FROM
        source_lits sl
        INNER JOIN core.lit_parties lp ON (
        lp.lit_id = sl.lit_id
        AND lp.dj_party_normalized_type = ''plaintiff''
        )
        INNER JOIN core.aliases al ON (al. ID = lp.alias_id AND al. ent_id IS NULL)
        INNER JOIN core.lit_types lt ON (
        /*  lt. NAME = ''Pending Review'' */
        lt. ID = 25
        ) WHERE lp.missing_from_source_date is NULL
        GROUP BY 1, 2, 3, 4)
  ),
     ---if Unknow default to operating companies
     Unkn AS (
      SELECT
        lit_id,
        case_key,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        (
          SELECT lit_id, case_key FROM in_lits
      EXCEPT SELECT lit_id, case_key FROM nce
          EXCEPT SELECT lit_id, case_key FROM npe
          EXCEPT SELECT lit_id, case_key FROM plc
          EXCEPT SELECT lit_id, case_key FROM university
          EXCEPT SELECT lit_id, case_key FROM oc
          EXCEPT SELECT lit_id, case_key FROM inventor
          EXCEPT SELECT lit_id, case_key FROM gov
      EXCEPT SELECT lit_id, case_key FROM pending_review
        ) T
        INNER JOIN core.lit_types lt ON (
          /* Others all Operating companies */
          lt. ID = 11
        )
    )
  SELECT lit_id, case_key, case_type_name, case_type_id FROM nce
    UNION ALL SELECT lit_id, case_key, case_type_name, case_type_id FROM npe
    UNION ALL SELECT lit_id, case_key, case_type_name, case_type_id FROM plc
    UNION ALL SELECT lit_id, case_key, case_type_name, case_type_id FROM university
    UNION ALL SELECT lit_id, case_key, case_type_name, case_type_id FROM oc
    UNION ALL SELECT lit_id, case_key, case_type_name, case_type_id FROM inventor
    UNION ALL SELECT lit_id, case_key, case_type_name, case_type_id FROM gov
    UNION ALL SELECT lit_id, case_key, case_type_name, case_type_id FROM pending_review
    UNION ALL SELECT lit_id, case_key, case_type_name, case_type_id FROM Unkn
    ORDER BY 1
  ';

RETURN QUERY EXECUTE v_sql USING p_lit_ids, p_case_keys;

EXCEPTION WHEN OTHERS THEN RAISE;
END;
$_$;


--
-- Name: find_lit_case_type_v1(integer[], character varying[]); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION find_lit_case_type_v1(p_lit_ids integer[] DEFAULT NULL::integer[], p_case_keys character varying[] DEFAULT NULL::character varying[]) RETURNS TABLE(lit_id integer, case_key character varying, case_type_name character varying, case_type_id integer)
    LANGUAGE plpgsql
    AS $_$
DECLARE
  v_sql text := '';
BEGIN
/*
1.1 tazhagan_c 15-Oct-2015 DS-1893 : Modify the inventor logic in inventor section to join on core_name as per Seth Besse
1.2 anarayanan 28-Oct-2015 DS-1893 : Change the API based on lookup values instead of names
1.3 anarayanan 16-Nov-2015 DS-1893 : Added lookup values for Patent Licensing Company and Government
1.4 anarayanan 16-Nov-2015 DS-1893 : Updated logic for Government
*/
  v_sql := '
    WITH in_lits AS (
      SELECT
        lits. ID AS lit_id,
        case_key,
        lits.filed_date
      FROM
        core.lits
      WHERE
      (
        $1 IS NULL AND $2 IS NULL
      )
      OR
        lits. ID = ANY ($1)
      OR lits.case_key = ANY ($2)
    ),
     npe AS (
      SELECT
        il.lit_id,
        il.case_key,
        il.filed_date,
        lt. NAME AS case_type_name,
				lt. ID AS case_type_id
      FROM
        in_lits il
      INNER JOIN core.lit_parties lp ON lp.lit_id = il.lit_id
      INNER JOIN core.aliases al ON al. ID = lp.alias_id
      INNER JOIN core.ents ON ents. ID = al.ent_id
      INNER JOIN core.ent_types et ON (
        et. ID = ents.ent_type_id
        /*AND et. NAME IN (''Company'', ''Consortium'')*/
				AND et. ID IN (1, 8)
      )
      INNER JOIN core.ent_subtypes_map esm ON (
        esm.ent_id = ents. ID
        AND il.filed_date BETWEEN COALESCE (
          esm.start_date,
          ''1900-01-01''
        )
        AND COALESCE (esm.end_date, ''3000-01-01'')
      )
      INNER JOIN core.ent_subtypes es ON (
        es. ID = esm.ent_subtype_id
        /*AND es. NAME = ''NPE''*/
				AND es. ID = 2
      )
			INNER JOIN core.lit_types lt ON (
				/*lt. NAME = ''NPE''*/
				lt. ID = 1
			)
      GROUP BY 1, 2, 3, 4, 5
    ),
     plc AS (
      SELECT
        il.lit_id,
        il.case_key,
        lt. NAME AS case_type_name,
				lt. ID AS case_type_id
      FROM
        (
          SELECT lit_id, case_key, filed_date FROM in_lits
          EXCEPT SELECT lit_id, case_key, filed_date FROM npe
        ) il
      INNER JOIN core.lit_parties lp ON (
        lp.lit_id = il.lit_id
        AND lp.dj_party_normalized_type = ''plaintiff''
      )
      INNER JOIN core.aliases al ON al. ID = lp.alias_id
      INNER JOIN core.ents ON ents. ID = al.ent_id
      INNER JOIN core.ent_types et ON (
        et. ID = ents.ent_type_id
        /*AND et. NAME IN (
          ''Company'',
          ''Consortium'',
          ''Research Organization''
        )*/
				AND et. ID IN (1, 8, 7)
      )
			INNER JOIN core.lit_types lt ON (
				/*lt. NAME = ''Patent Licensing Company''*/
				lt. ID = 23
			)
      INNER JOIN core.ent_subtypes_map esm ON (
        esm.ent_id = ents. ID
        AND il.filed_date BETWEEN COALESCE (
          esm.start_date,
          ''1900-01-01''
        )
        AND COALESCE (esm.end_date, ''3000-01-01'')
      )
      INNER JOIN core.ent_subtypes es ON (
        es. ID = esm.ent_subtype_id
        /*AND es. NAME = ''Patent Licensing Company''*/
				AND es. ID = 1
      )
      GROUP BY 1, 2, 3, 4
    ),
     university AS (
      SELECT
        il.lit_id,
        il.case_key,
        lt. NAME AS case_type_name,
				lt. ID AS case_type_id
      FROM
        (
          SELECT lit_id, case_key FROM in_lits
          EXCEPT SELECT lit_id, case_key FROM npe
          EXCEPT SELECT lit_id, case_key FROM plc
        ) il
      INNER JOIN core.lit_parties lp ON (
        lp.lit_id = il.lit_id
        AND lp.dj_party_normalized_type = ''plaintiff''
      )
      INNER JOIN core.aliases al ON al. ID = lp.alias_id
      INNER JOIN core.ents ON ents. ID = al.ent_id
      INNER JOIN core.ent_types et ON (
        et. ID = ents.ent_type_id
        /*AND et. NAME = ''University''*/
				AND et. ID = 5
      )
			INNER JOIN core.lit_types lt ON (
				/*lt. NAME = ''UNI''*/
				lt. ID = 4
			)
      GROUP BY 1, 2, 3, 4
    ),
     inventor AS (
      SELECT
        il.lit_id,
        il.case_key,
        lt. NAME AS case_type_name,
				lt. ID AS case_type_id
      FROM
        (
          SELECT lit_id, case_key FROM in_lits
          EXCEPT SELECT lit_id, case_key FROM npe
          EXCEPT SELECT lit_id, case_key FROM plc
          EXCEPT SELECT lit_id, case_key FROM university
        ) il
      INNER JOIN core.lit_parties lp ON (
        lp.lit_id = il.lit_id
        AND lp.dj_party_normalized_type = ''plaintiff''
      )
      INNER JOIN core.aliases al ON al. ID = lp.alias_id
      INNER JOIN core.ents ON ents. ID = al.ent_id
      INNER JOIN core.ent_types et ON (
        et. ID = ents.ent_type_id
        /*AND et. NAME = ''Individual''*/
				AND et. ID = 2
      )
      INNER JOIN core.lits_pats_map lpm ON lpm.lit_id = lp.lit_id
      INNER JOIN core.pats ON pats.stripped_patnum = lpm.patnum
      INNER JOIN core.aliases al_all ON al_all.ent_id = ents. ID
      INNER JOIN core.pats_aliases_map pam ON (pam.pat_id = pats. ID)
	  INNER JOIN core.aliases pa ON (pa.id = pam.alias_id and pa.core_name = al_all.core_name)
      INNER JOIN core.pats_aliases_relationship_types part ON (
        part. ID = pam.pats_aliases_relationship_type_id
        /*AND part. NAME = ''Inventor''*/
				AND part. ID = 7
      )
			INNER JOIN core.lit_types lt ON (
				/*lt. NAME = ''INV''*/
				lt. ID = 7
			)
      GROUP BY 1, 2, 3, 4
    ),
     oc AS (
      SELECT
        il.lit_id,
        il.case_key,
        lt. NAME AS case_type_name,
				lt. ID AS case_type_id
      FROM
        (
          SELECT lit_id, case_key FROM in_lits
          EXCEPT SELECT lit_id, case_key FROM npe
          EXCEPT SELECT lit_id, case_key FROM plc
          EXCEPT SELECT lit_id, case_key FROM university
          EXCEPT SELECT lit_id, case_key FROM inventor
        ) il
      INNER JOIN core.lit_parties lp ON (
        lp.lit_id = il.lit_id
        AND lp.dj_party_normalized_type = ''plaintiff''
      )
      INNER JOIN core.aliases al ON al. ID = lp.alias_id
      INNER JOIN core.ents ON ents. ID = al.ent_id
      INNER JOIN core.ent_types et ON (
        et. ID = ents.ent_type_id
        /*AND et. NAME = ''Company''*/
				AND et. ID = 1
      )
			INNER JOIN core.lit_types lt ON (
				/*lt. NAME = ''Operating Company''*/
				lt. ID = 11
			)
      GROUP BY 1, 2, 3, 4
    ),
     gov AS (
      SELECT
        il.lit_id,
        il.case_key,
        lt. NAME AS case_type_name,
				lt. ID AS case_type_id
      FROM
        (
          SELECT lit_id, case_key FROM in_lits
          EXCEPT SELECT lit_id, case_key FROM npe
          EXCEPT SELECT lit_id, case_key FROM plc
          EXCEPT SELECT lit_id, case_key FROM university
          EXCEPT SELECT lit_id, case_key FROM inventor
          EXCEPT SELECT lit_id, case_key FROM oc
        ) il
      INNER JOIN core.lit_parties lp ON (
        lp.lit_id = il.lit_id
        AND lp.dj_party_normalized_type = ''plaintiff''
      )
      INNER JOIN core.aliases al ON al. ID = lp.alias_id
      INNER JOIN core.ents ON ents. ID = al.ent_id
			INNER JOIN core.lit_types lt ON (
				/*lt. NAME = ''Government''*/
				lt. ID = 24
			)
			WHERE
				NOT EXISTS (
						SELECT 1
						FROM core.ent_types et
						WHERE et. ID = ents.ent_type_id
						/*AND et. NAME != ''Government''*/
						AND et. ID != 3
					)
      GROUP BY 1, 2, 3, 4
    ),
     Unkn AS (
      SELECT
        lit_id,
        case_key,
        lt. NAME AS case_type_name,
				lt. ID AS case_type_id
      FROM
        (
          SELECT lit_id, case_key FROM in_lits
          EXCEPT SELECT lit_id, case_key FROM npe
          EXCEPT SELECT lit_id, case_key FROM plc
          EXCEPT SELECT lit_id, case_key FROM university
          EXCEPT SELECT lit_id, case_key FROM inventor
          EXCEPT SELECT lit_id, case_key FROM oc
          EXCEPT SELECT lit_id, case_key FROM gov
        ) T
				INNER JOIN core.lit_types lt ON (
					/*lt. NAME = ''undefined''*/
					lt. ID = 21
				)
    )
    SELECT lit_id, case_key, case_type_name, case_type_id FROM npe
    UNION ALL SELECT lit_id, case_key, case_type_name, case_type_id FROM plc
    UNION ALL SELECT lit_id, case_key, case_type_name, case_type_id FROM university
    UNION ALL SELECT lit_id, case_key, case_type_name, case_type_id FROM inventor
    UNION ALL SELECT lit_id, case_key, case_type_name, case_type_id FROM oc
    UNION ALL SELECT lit_id, case_key, case_type_name, case_type_id FROM gov
    UNION ALL SELECT lit_id, case_key, case_type_name, case_type_id FROM Unkn
    ORDER BY 1
  ';

RETURN QUERY EXECUTE v_sql USING p_lit_ids, p_case_keys;

EXCEPTION WHEN OTHERS THEN RAISE;
END;
$_$;


--
-- Name: find_matching_contact(integer, character varying, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION find_matching_contact(in_alias_id integer, in_line1 character varying, in_line2 character varying, in_line3 character varying, in_city character varying, in_state character varying, in_country character varying, in_zip character varying) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    our_id INTEGER;
BEGIN
    SELECT id
    FROM core.alias_contacts
    WHERE
      alias_id = in_alias_id AND
      (line1 IS NOT NULL OR line2 IS NOT NULL OR line3 IS NOT NULL OR city IS NOT NULL OR
       state_or_province IS NOT NULL OR country IS NOT NULL OR postal_code IS NOT NULL) AND
      (in_line1 = '' OR line1 IS NULL OR in_line1 = line1) AND
      (in_line2 = '' OR line2 IS NULL OR in_line2 = line2) AND
      (in_line3 = '' OR line3 IS NULL OR in_line3 = line3) AND
      (in_city = '' OR city IS NULL OR in_city = city) AND
      (in_state = '' OR state_or_province IS NULL OR in_state = state_or_province) AND
      (in_country = '' OR country IS NULL OR in_country = country) AND
      (in_zip = '' OR postal_code IS NULL OR in_zip = postal_code)
    INTO our_id;

    RETURN our_id;
END;
$$;


--
-- Name: find_or_create_alias(text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION find_or_create_alias(as_seen text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_alias_id INTEGER;
    v_alias_name TEXT;

    c_alias CURSOR (
        seek_name TEXT
    ) IS
        SELECT min(id) FROM core.aliases WHERE name = seek_name
    ;
BEGIN
    SELECT substr(string_agg(x.t, ''), 1, 500)
    INTO v_alias_name
    FROM (
          SELECT regexp_split_to_table(trim(regexp_replace(as_seen, '\u0013', '')), '') as t
    ) x
    WHERE ascii(x.t) > 31 and ascii(x.t) < 127;

    OPEN  c_alias(v_alias_name);
    FETCH c_alias INTO v_alias_id;
    CLOSE c_alias;

    IF v_alias_id is NULL THEN
     --replaced with two '' for ' for dblink reason
     SELECT x into v_alias_id
     FROM  public.dblink( config.dblink_connection('coredb'),
           'select core.create_alias_sequential(''' || replace(v_alias_name, '''', '''''')  || ''');') as temp(x integer);

    END IF;

    RETURN v_alias_id;
END;
$$;


--
-- Name: find_or_create_alias_contact(integer, character varying, character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION find_or_create_alias_contact(alias_id integer, addressid character varying, contactdetailsid character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_addressid         VARCHAR := TRIM(addressid);
    v_contactdetailsid  VARCHAR := TRIM(contactdetailsid);

    v_filter            TEXT := '';
    v_street1            TEXT;
    v_street2            TEXT;
    v_street3            TEXT;
    v_city                TEXT;
    v_postalstatecode    TEXT;
    v_zipcode            TEXT;
    v_country            TEXT;
    v_businessphone        TEXT;
    v_cellphonenumber    TEXT;
    v_faxnumber            TEXT;
    v_phonenumber        TEXT;
    v_emailaddress        TEXT;

    v_sql               TEXT;
    v_contact_id        INTEGER;

BEGIN
    IF (v_addressid IS NULL OR v_addressid = '') AND (v_contactdetailsid IS NULL OR v_contactdetailsid = '') THEN
        RETURN NULL;
    END IF;

    IF (v_addressid IS NOT NULL AND length(v_addressid) > 0) THEN
        SELECT street1, street2, street3, city, postalstatecode, zipcode, country
        INTO v_street1, v_street2, v_street3, v_city, v_postalstatecode, v_zipcode, v_country
        FROM public.address
        WHERE address.id = v_addressid;

        IF v_street1 IS NOT NULL AND length(v_street1) > 0 THEN
            v_filter := v_filter || ' AND line1 = ''' || quote_nullable(v_street1) || ''' ';
        END IF;
        IF v_street2 IS NOT NULL AND length(v_street2) > 0 THEN
            v_filter := v_filter || ' AND line2 = ''' || quote_nullable(v_street2) || ''' ';
        END IF;
        IF v_street3 IS NOT NULL AND length(v_street3) > 0 THEN
            v_filter := v_filter || ' AND line3 = ''' || quote_nullable(v_street3) || ''' ';
        END IF;
        IF v_city IS NOT NULL AND length(v_city) > 0 THEN
            v_filter := v_filter || ' AND city = ''' || quote_nullable(v_city) || ''' ';
        END IF;
        IF v_postalstatecode IS NOT NULL AND length(v_postalstatecode) > 0 THEN
            v_filter := v_filter || ' AND state_or_province = ''' || quote_nullable(v_postalstatecode) || ''' ';
        END IF;
        IF v_zipcode IS NOT NULL AND length(v_zipcode) > 0 THEN
            v_filter := v_filter || ' AND postal_code = ''' || quote_nullable(v_zipcode) || ''' ';
        END IF;
        IF v_country IS NOT NULL AND length(v_country) > 0 THEN
            v_filter := v_filter || ' AND country = ''' || quote_nullable(v_country) || ''' ';
        END IF;
    END IF;

    IF (v_contactdetailsid IS NOT NULL AND length(v_contactdetailsid) > 0) THEN
        SELECT businessphonenumber, cellphonenumber, faxnumber, phonenumber, emailaddress
        INTO v_businessphone, v_cellphonenumber, v_faxnumber, v_phonenumber, v_emailaddress
        FROM public.contactdetails
        WHERE contactdetails.id = v_contactdetailsid;

        IF v_emailaddress IS NOT NULL AND length(v_emailaddress) > 0 THEN
            v_filter := v_filter || ' AND email = ''' || quote_nullable(v_emailaddress) || ''' ';
        END IF;
        IF v_phonenumber IS NOT NULL AND length(v_phonenumber) > 0 THEN
            v_filter := v_filter || ' AND phone = ''' || quote_nullable(v_phonenumber) || ''' ';
        END IF;
        IF v_cellphonenumber IS NOT NULL AND length(v_cellphonenumber) > 0 THEN
            v_filter := v_filter || ' AND cell = ''' || quote_nullable(v_cellphonenumber) || ''' ';
        END IF;
        IF v_faxnumber IS NOT NULL AND length(v_faxnumber) > 0 THEN
            v_filter := v_filter || ' AND fax = ''' || quote_nullable(v_faxnumber) || ''' ';
        END IF;
    END IF;

    v_sql := 'SELECT id FROM alias_contacts WHERE alias_id = ' || alias_id::varchar || v_filter;
    v_contact_id := EXECUTE(v_sql);

    IF v_contact_id IS NULL and length(v_filter) > 0 THEN
        INSERT INTO alias_contacts
            (alias_id, line1, line2, line3, city, state_or_province, postal_code, country, email, phone, fax, cell)
        VALUES
            (alias_id, quote_nullable(v_street1), quote_nullable(v_street2), quote_nullable(v_street3), quote_nullable(city), quote_nullable(v_postalstatecode), quote_nullable(v_zipcode), quote_nullable(v_country),
             quote_nullable(v_emailaddress), quote_nullable(v_phonenumber), quote_nullable(v_faxnumber), quote_nullable(v_cellphonenumber))
        RETURNING id INTO v_contact_id;
    END IF;

    RETURN v_contact_id;

END;
$$;


--
-- Name: find_or_create_alias_contact_record(integer, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION find_or_create_alias_contact_record(in_alias_id integer, in_line1 character varying DEFAULT NULL::character varying, in_line2 character varying DEFAULT NULL::character varying, in_line3 character varying DEFAULT NULL::character varying, in_line4 character varying DEFAULT NULL::character varying, in_city character varying DEFAULT NULL::character varying, in_state character varying DEFAULT NULL::character varying, in_postal character varying DEFAULT NULL::character varying, in_country character varying DEFAULT NULL::character varying, in_url character varying DEFAULT NULL::character varying, in_phone character varying DEFAULT NULL::character varying, in_fax character varying DEFAULT NULL::character varying, in_cell character varying DEFAULT NULL::character varying, in_email character varying DEFAULT NULL::character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    our_id INTEGER;
    my_md5 text;
    row varchar;
BEGIN

    /*
        1.0 ateja_c 18/07/2017 Deployed to eliminate null / "N/A" inserts in alias_contacts ( N/A is also considered as NULL )
    */


    my_md5 := md5(lower(coalesce(case when UPPER(trim(in_line1))='N/A' THEN NULL ELSE UPPER(trim(in_line1)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(in_line2))='N/A' THEN NULL ELSE UPPER(trim(in_line2)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(in_line3))='N/A' THEN NULL ELSE UPPER(trim(in_line3)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(in_city))='N/A' THEN NULL ELSE UPPER(trim(in_city)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(in_state))='N/A' THEN NULL ELSE UPPER(trim(in_state)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(in_postal))='N/A' THEN NULL ELSE UPPER(trim(in_postal)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(in_country))='N/A' THEN NULL ELSE UPPER(trim(in_country)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(in_url))='N/A' THEN NULL ELSE UPPER(trim(in_url)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(in_phone))='N/A' THEN NULL ELSE UPPER(trim(in_phone)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(in_fax))='N/A' THEN NULL ELSE UPPER(trim(in_fax)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(in_cell))='N/A' THEN NULL ELSE UPPER(trim(in_cell)) END, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(in_email))='N/A' THEN NULL ELSE UPPER(trim(in_email)) END, ''::text)) ||
                        lower(coalesce(NULL, ''::text)) ||
                        lower(coalesce(NULL, ''::text)) ||
                        lower(coalesce(NULL, ''::text)) ||
                        lower(coalesce(case when UPPER(trim(in_line4))='N/A' THEN NULL ELSE UPPER(trim(in_line4)) END, ''::text)));

    IF my_md5 = 'd41d8cd98f00b204e9800998ecf8427e' THEN
     RETURN null;
    END IF;

    SELECT min(id) as id
    FROM core.alias_contacts
    WHERE
      alias_id = in_alias_id AND
      address_md5 = my_md5  INTO our_id;


    IF our_id is NULL THEN
        INSERT INTO core.alias_contacts (
            alias_id,
            line1,
            line2,
            line3,
            line4,
            city,
            state_or_province,
            postal_code,
            country,
            url,
            phone,
            fax,
            cell,
            email
        )
        VALUES (
            in_alias_id,
            trim(in_line1),
            trim(in_line2),
            trim(in_line3),
            trim(in_line4),
            trim(in_city),
            trim(in_state),
            trim(in_postal),
            trim(in_country),
            trim(in_url),
            trim(in_phone),
            trim(in_fax),
            trim(in_cell),
            trim(in_email)
        ) RETURNING id INTO our_id;
    END IF;

    RETURN our_id;
END;
$$;


--
-- Name: find_or_create_lit_cause_type(character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION find_or_create_lit_cause_type(p_lit_cause_type character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_lit_cause_type_id INTEGER := NULL;
BEGIN

 IF p_lit_cause_type is NULL THEN
   RETURN NULL;
 END IF;
 ---data cleaning step here


 ---check if exists already
 SELECT id
 INTO v_lit_cause_type_id
 FROM core.lit_cause_types
 WHERE lower(name) = lower(trim(p_lit_cause_type));

 ---insert if not
 IF NOT FOUND THEN

  INSERT INTO core.lit_cause_types
  (name)
  VALUES
  (trim(p_lit_cause_type))
  RETURNING id into v_lit_cause_type_id;

 END IF;

 RETURN v_lit_cause_type_id;

EXCEPTION
        WHEN OTHERS THEN
        RAISE;
END;
$$;


--
-- Name: find_or_create_lit_curated_cause_type(character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION find_or_create_lit_curated_cause_type(p_lit_curated_cause_type character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_lit_curated_cause_type_id INTEGER := NULL;
BEGIN
/*
  1.0 06-Sep-2016 DS-4303 : Change the logic as below

  (1)Check for an existing match in the table. Ignore the spaces,case and special characters while doing this matching so that breach_of_contract and Breach of Contract will match
    (2)If match found, return the value
    (3)If no match is found, raise an exception since this is not expected

*/
 IF p_lit_curated_cause_type is NULL THEN
   RETURN NULL;
 END IF;
 ---data cleaning step here

 ---check if exists already
 SELECT id
 INTO v_lit_curated_cause_type_id
 FROM core.lit_curated_cause_types
 WHERE lower(regexp_replace(name, '[^a-zA-Z0-9]+', '', 'g')) = lower(regexp_replace(p_lit_curated_cause_type, '[^a-zA-Z0-9]+', '', 'g'));

 --- If no match is found, raise an exception since this is not expected
 IF NOT FOUND THEN

  RAISE EXCEPTION 'No matching value found for ''%'' in core.lit_curated_cause_types',p_lit_curated_cause_type;

 END IF;

 RETURN v_lit_curated_cause_type_id;

EXCEPTION
        WHEN OTHERS THEN
        RAISE;
END;
$$;


--
-- Name: find_or_create_lit_document(character varying, integer, integer, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION find_or_create_lit_document(p_url character varying, p_de_seq_num integer DEFAULT NULL::integer, p_dm_id integer DEFAULT NULL::integer, p_doc_num integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_lit_document_id INTEGER;
BEGIN

 IF p_url is null OR p_url not like 'https%'THEN
   return NULL;
 END IF;

 SELECT id
 INTO   v_lit_document_id
 FROM   core.lit_documents
 WHERE  url = p_url;


 IF NOT FOUND THEN
  INSERT into core.lit_documents
  (url, de_seq_num, dm_id, doc_num)
  VALUES
  (p_url, p_de_seq_num, p_dm_id, p_doc_num)
  RETURNING id into v_lit_document_id;
 ELSE
   --assumption: doc_num is for main document
   --if main document, then update
   --turn off this one, because it casued too many updates. fli: 2016/03/04

   IF p_doc_num is not null THEN
  ---  UPDATE core.lit_documents
  ---  SET
  ---     dm_id = p_dm_id
  ---     ,doc_num = p_doc_num
  ---  WHERE id = v_lit_document_id;
    NULL;
   END IF;
 END IF;

 RETURN v_lit_document_id;
END;
$$;


--
-- Name: find_or_create_lit_document(character varying, integer, character varying, text, text, integer, integer, double precision); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION find_or_create_lit_document(p_url character varying, p_doc_num integer, p_lit_document_type character varying, p_ocr_text text, p_pdf_type text, p_billable_pages integer DEFAULT NULL::integer, p_total_pages integer DEFAULT NULL::integer, p_cost double precision DEFAULT NULL::double precision) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_lit_document_id INTEGER;
BEGIN
/*
1.1 aprakash_c 10-Mar-2016 DS-3389 : considering billable_pages, total_pages, cost columns for update/insert
*/

 IF p_url is null OR p_url not like 'https%'THEN
   return NULL;
 END IF;

 SELECT id
 INTO   v_lit_document_id
 FROM   core.lit_documents
 WHERE  url = p_url;


 IF NOT FOUND THEN
  INSERT into core.lit_documents
  (url, lit_document_type_id, ocr_text, pdf_type, doc_num, billable_pages, no_of_pages, cost)
  VALUES
  (p_url, coalesce((SELECT id FROM core.lit_document_types WHERE description = p_lit_document_type), 0)::int, p_ocr_text, p_pdf_type, p_doc_num, p_billable_pages, p_total_pages, p_cost)
  RETURNING id into v_lit_document_id;
 ELSE
   --assumption: doc_num is for main document
   --if main document, then update
   IF p_doc_num is not null THEN
    UPDATE core.lit_documents
    SET
       lit_document_type_id = CASE lit_document_type_id WHEN 0 THEN coalesce((SELECT id FROM core.lit_document_types WHERE description = p_lit_document_type), 0)::int ELSE lit_document_type_id END
       ,ocr_text = p_ocr_text
       ,pdf_type = p_pdf_type
	   ,billable_pages = p_billable_pages
	   ,no_of_pages = p_total_pages
	   ,cost = p_cost
       ---,doc_num = p_doc_num   ---stop updating this field
    WHERE id = v_lit_document_id AND
          (coalesce(ocr_text, 'NA') != coalesce(p_ocr_text, 'NA') OR
           coalesce(pdf_type, 'NA') != coalesce(p_pdf_type, 'NA') OR
		   coalesce(billable_pages, -1) != coalesce(p_billable_pages, -1) OR
		   coalesce(no_of_pages, -1) != coalesce(p_total_pages, -1) OR
		   coalesce(cost, -1) != coalesce(p_cost, -1) OR
          (lit_document_type_id <> coalesce((SELECT id FROM core.lit_document_types WHERE description = p_lit_document_type), 0)::int AND lit_document_type_id = 0));
   END IF;
 END IF;

 RETURN v_lit_document_id;
END;
$$;


--
-- Name: find_or_create_lit_family(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION find_or_create_lit_family(p_lit_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_rel_count     INTEGER;
    v_family_count  INTEGER;
    v_family_id     INTEGER;
    v_family_set    INTEGER[];
    v_new_family_id INTEGER;
    v_count_null    INTEGER;

BEGIN
    SELECT count(id)
    INTO v_rel_count
    FROM core.lit_relationships
    WHERE from_lit_id = p_lit_id OR to_lit_id = p_lit_id;

    IF v_rel_count = 0 THEN
        --This must be a new litigation that does not yet belong to a relationship or family.
        --We need to create a solitary relationship and create a family for that relationship.
        v_family_id := core.add_lit_family();

        INSERT INTO core.lit_relationships
            (from_lit_id, to_lit_id, lit_relationship_type_id, lit_family_id)
        VALUES
            (p_lit_id, p_lit_id, 2, v_family_id);

    ELSE    --This litigation is already in at least one relationship
        --Find any family ids assigned to relationships the lit is in
		SELECT count(distinct lit_family_id), min(lit_family_id)
		INTO v_family_count, v_family_id
		FROM core.lit_relationships
		WHERE lit_family_id IS NOT NULL
			AND (from_lit_id = p_lit_id OR to_lit_id = p_lit_id);

        IF v_family_count > 1 THEN
            -- This shouldn't actually happen, we should always be checking for existing families before assigning a family to a relationship.
            RAISE NOTICE '[core.find_or_create_lit_family] There is more than one lit_family_id related to the lit_id = %', p_lit_id;
            -- However, if there are two relationships with the same litigation that have different families then those families should merge.
            SELECT array_agg(lit_family_id)
		    INTO v_family_set
		    FROM core.lit_relationships
		    WHERE lit_family_id IS NOT NULL
			    AND (from_lit_id = p_lit_id OR to_lit_id = p_lit_id);

            v_new_family_id := core.combine_lit_families(v_family_set);

            IF v_new_family_id IS NOT NULL AND v_new_family_id > 0 THEN
                v_family_id := v_new_family_id;
            END IF;

        ELSIF v_family_count = 1 THEN
            IF v_family_id IS NULL OR v_family_id = 0 THEN
                RAISE EXCEPTION '[core.find_or_create_lit_family] There is a lit_relationship record for lit_id = % that has no family id.', p_lit_id;
            END IF;

            --We need to make sure that there are no null lit_family_ids
			SELECT count(*)
			INTO v_count_null
			FROM core.lit_relationships
			WHERE lit_family_id IS NULL
				AND (from_lit_id = p_lit_id OR to_lit_id = p_lit_id);

            IF v_count_null > 0 THEN
				UPDATE core.lit_relationships
				SET lit_family_id = v_family_id
				WHERE from_lit_id = p_lit_id OR to_lit_id = p_lit_id
                    AND lit_family_id IS NULL;
            END IF;

        ELSE   --v_family_count = 0
            --This must be a litigation that has at least one relationship, but none of the relationships have a family.
            --We need to create a family and update the lit_relationships record(s) for this lit.
            v_family_id := core.add_lit_family();

            UPDATE core.lit_relationships
            SET lit_family_id = v_family_id
            WHERE from_lit_id = p_lit_id OR to_lit_id = p_lit_id;
        END IF;
    END IF;

    RETURN v_family_id;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core.find_or_create_lit_family] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core.find_or_create_lit_family] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
    WHEN OTHERS THEN
        RAISE;

END;
$$;


--
-- Name: find_or_create_lit_parties_type(text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION find_or_create_lit_parties_type(arg_party_type text) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
   lit_party_type_id INTEGER;

   c_select_party_type CURSOR (
       seek_party_type VARCHAR
   ) IS
       SELECT id FROM core.lit_party_types WHERE name = lower(trim(seek_party_type))
   ;
BEGIN
    OPEN  c_select_party_type(arg_party_type);
    FETCH c_select_party_type INTO lit_party_type_id;
    CLOSE c_select_party_type;

    IF lit_party_type_id is NULL THEN
        INSERT INTO core.lit_party_types (
            name
        ) VALUES (
            lower(trim(arg_party_type))
        )
        RETURNING id INTO lit_party_type_id;
    END IF;

    RETURN lit_party_type_id;
END;
$$;


--
-- Name: find_or_create_lit_party(integer, integer, date, character varying, character varying, character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION find_or_create_lit_party(p_alias_id integer, p_lit_id integer, p_terminatedate date, p_party_type character varying, p_addressid character varying, p_contactdetailsid character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_lit_party_id      INTEGER;
    v_lit_party_type_id    INTEGER;
    v_alias_contact_id    INTEGER;
BEGIN
    SELECT id
    INTO v_lit_party_type_id
    FROM core.lit_party_types
    WHERE name = lower(trim(p_party_type));

    IF v_lit_party_type_id IS NULL THEN
        RAISE EXCEPTION '[core.find_or_create_lit_party] There is no lit_party_type with the name = %', p_party_type;
    END IF;

    SELECT id
    INTO v_lit_party_id
    FROM core.lit_parties
    WHERE alias_id = p_alias_id
        AND lit_id = p_lit_id
        AND lit_party_type_id = v_lit_party_type_id;

    IF v_lit_party_id IS NOT NULL THEN
        IF p_terminate_date IS NOT NULL THEN
            UPDATE core.lit_parties
            SET end_date = p_terminate_date
            WHERE id = v_lit_party_id;
        END IF;
    ELSE
        v_alias_contact_id := find_or_create_alias_contact(p_alias_id, p_addressid, p_contactdetailsid);

        INSERT INTO lit_parties
            (alias_id, lit_id, lit_party_type_id, alias_contact_id, end_date)
        VALUES
            (p_alias_id, p_lit_id, v_lit_party_type_id, v_alias_contact_id, p_terminate_date)
        RETURNING id INTO v_lit_party_id;

        IF v_lit_party_id IS NULL THEN
            RAISE EXCEPTION '[core.find_or_create_lit_party] Could not create lit_parties record with alias_id = %, lit_id = %, lit_party_type_id = %, alias_contact_id = %, end_date = %',
                p_alias_id, p_lit_id, v_lit_party_type_id, v_alias_contact_id, p_terminate_date;
        END IF;
    END IF;

    RETURN v_lit_party_id;
END;
$$;


--
-- Name: find_or_create_lit_stage(character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION find_or_create_lit_stage(p_lit_stage character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_lit_stage_id INTEGER := NULL;
BEGIN

 ---check if exists already
 SELECT id
 INTO v_lit_stage_id
 FROM core.lit_stages
 WHERE lower(name) = lower(coalesce(trim(p_lit_stage), 'unknown'));

 ---insert if not
 IF NOT FOUND THEN

  INSERT INTO core.lit_stages
  (name)
  VALUES
  (trim(p_lit_stage))
  RETURNING id into v_lit_stage_id;

 END IF;

 RETURN v_lit_stage_id;

EXCEPTION
        WHEN OTHERS THEN
        RAISE;
END;
$$;


--
-- Name: find_or_create_market_sector_type(character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION find_or_create_market_sector_type(p_market_sector_type_type character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	v_id                    INTEGER;
	v_market_sector_type    core.market_sector_types.name%TYPE := initcap(trim(p_market_sector_type_type));

BEGIN
    v_id := (SELECT id FROM core.market_sector_types WHERE trim(lower(name)) = trim(lower(v_market_sector_type)));

    IF v_id IS NULL THEN
        INSERT INTO core.market_sector_types (name)
	        VALUES (v_market_sector_type)
            RETURNING id INTO v_id;
    END IF;

    RETURN v_id;
END;
$$;


--
-- Name: find_orig_file_date(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION find_orig_file_date(p_lit_id integer) RETURNS date
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_orig_filed_date date;
    v_filed_date     date;

    c_filed_date CURSOR (
        seek_lit_id INTEGER
    ) IS
        SELECT filed_date FROM core.lits WHERE id = seek_lit_id
    ;

BEGIN
    OPEN c_filed_date(p_lit_id);
    FETCH c_filed_date INTO v_filed_date;
    CLOSE c_filed_date;

    --go back through the lit_relationship tree to find oldest date it could be transfered from
    SELECT min(orig.filed_date)
    INTO v_orig_filed_date
    FROM (WITH RECURSIVE my_tree1(to_lit_id, from_lit_id, viewed_lits) AS
               (SELECT lit_relationships.to_lit_id, lit_relationships.from_lit_id, ARRAY[]::INTEGER[]	AS viewed_lits
                FROM core.lit_relationships
                WHERE lit_relationships.to_lit_id = p_lit_id
                    AND lit_relationships.lit_relationship_type_id != 2
               UNION
                SELECT lr.to_lit_id, lr.from_lit_id, array_append(mt1.viewed_lits, lr.from_lit_id) AS viewed_lits
                FROM core.lit_relationships lr
                JOIN my_tree1 mt1 ON mt1.from_lit_id = lr.to_lit_id
                WHERE lr.to_lit_id != ALL (mt1.viewed_lits)
               )
           SELECT mt1.from_lit_id, lits.filed_date
           FROM my_tree1 mt1
           INNER JOIN core.lits ON mt1.from_lit_id = lits.id
           ) orig
    ;

    IF v_orig_filed_date IS NULL THEN
    -- If we didn't find an original date (it could be there is no lit_relationship)
    -- we'll use the lit's own filed_date.
        v_orig_filed_date = v_filed_date;
    ELSIF v_orig_filed_date > v_filed_date THEN
    -- If the "original" filed date is actually after the lit's filed date
    -- we won't use it, we'll use the older filed_date
        v_orig_filed_date = v_filed_date;
    END IF;

    RETURN v_orig_filed_date;
END;
$$;


--
-- Name: find_original_lit(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION find_original_lit(p_lit_id integer) RETURNS integer[]
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
	solitary_type_id	INTEGER;
    v_orig_lit_ids      INTEGER[];

	c_select_from_lit_relationship_solitary CURSOR
	FOR
		SELECT id FROM core.lit_relationship_types WHERE name = 'solitary'
	;

BEGIN
    -- Used by all_lits to go back through the lit_relationships table and find the first litigation in the chain.

	OPEN  c_select_from_lit_relationship_solitary;
	FETCH c_select_from_lit_relationship_solitary INTO solitary_type_id;
	CLOSE c_select_from_lit_relationship_solitary;

    --Get to the first lit(s) of lit_relationships path
    WITH RECURSIVE my_tree1(from_lit_id, to_lit_id) AS
        (SELECT lit_relationships.from_lit_id, lit_relationships.to_lit_id
         FROM core.lit_relationships
         WHERE lit_relationships.to_lit_id = p_lit_id
             AND lit_relationship_type_id != solitary_type_id
             AND lit_relationships.from_lit_id != p_lit_id
       UNION
         SELECT lr.from_lit_id, lr.to_lit_id
         FROM core.lit_relationships  lr
         INNER JOIN my_tree1                      mt1 ON mt1.from_lit_id = lr.to_lit_id
         WHERE lit_relationship_type_id != solitary_type_id
        )
        SELECT array_agg(mt1.from_lit_id)
        INTO v_orig_lit_ids
        FROM my_tree1 mt1
        WHERE mt1.from_lit_id NOT IN (SELECT lr2.to_lit_id FROM core.lit_relationships lr2);

	RETURN v_orig_lit_ids;
END;
$$;


--
-- Name: find_ult_parent(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION find_ult_parent(p_ent_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_ult_parent_id integer;
    v_ent_type      integer;

    c_ent_type CURSOR (
        seek_ent_id INTEGER
    ) IS
        SELECT ent_type_id FROM core.ents WHERE id = seek_ent_id
    ;

BEGIN
    OPEN c_ent_type(p_ent_id);
    FETCH c_ent_type INTO v_ent_type;
    CLOSE c_ent_type;

    IF v_ent_type = 3 THEN
    -- If the entity is a court then just make it its own parent.
        v_ult_parent_id = p_ent_id;
    END IF;

    --climb the ent_relationship tree to find the parent
    SELECT (WITH RECURSIVE my_tree1(ent_id, related_ent_id) AS
               (SELECT ent_relationships.ent_id, ent_relationships.related_ent_id
                FROM core.ent_relationships
                WHERE ent_relationships.ent_id = p_ent_id
               UNION
                SELECT er.ent_id, er.related_ent_id
                FROM core.ent_relationships er
                JOIN my_tree1 mt1 ON mt1.related_ent_id = er.ent_id
               )
           SELECT mt1.related_ent_id
           FROM my_tree1 mt1
           WHERE mt1.ent_id = mt1.related_ent_id) AS ult_parent_ent_id
    INTO v_ult_parent_id
    FROM core.ent_relationships er2
    WHERE er2.ent_relationship_type_id IN (1,2,6) ;

    IF v_ult_parent_id IS NULL THEN
    -- If we didn't find a parent then they don't have standard parent/subsidiary relationship, it's
    -- probably a judge whose relationship to the court is not the same and shouldn't be considered a parent.
    -- We'll make them their own parent.
        v_ult_parent_id = p_ent_id;
    END IF;

    RETURN v_ult_parent_id;
END;
$$;


--
-- Name: fingerprint(character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION fingerprint(str character varying) RETURNS character varying
    LANGUAGE plpgsql STRICT
    AS $$

BEGIN
    RAISE NOTICE 'This function has been deprecated, please use code_nerd.fingerprint';
    RETURN code_nerd.fingerprint(str);

END
$$;


--
-- Name: fingerprint2(character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION fingerprint2(str character varying) RETURNS character varying
    LANGUAGE plpgsql STRICT
    AS $$

BEGIN
    RAISE NOTICE 'This function has been deprecated, please use code_nerd.fingerprint2';
    RETURN code_nerd.fingerprint2(str);

END
$$;


--
-- Name: format_patnum(character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION format_patnum(p_patnum character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
  declare
  v_sql text:='';
  v_patnum character varying;
  begin
  /*
  1.0 aprakash_c 24-JUL-2015 DS-2002: New API created formatting the patnums in campaign name
  */
    v_sql := '
			SELECT
			 regexp_replace(
			  $1,
			  ''\d+'',
			  TRIM (
			   to_char(
				to_number(
				 SUBSTRING ($1, ''\d+''),
				 ''999999999999''
				),
				''999G999G999G999''
			   )
			  )
			 );';
				
EXECUTE v_sql INTO v_patnum USING p_patnum;
	RETURN v_patnum; 
END;
$_$;


--
-- Name: generate_dml_func(text, text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION generate_dml_func(p_table_name text, p_schema text) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
v_create_function_insert text;
v_create_function_update text;
v_create_function_delete text;
v_function_variable text := 'p_'||p_table_name||'_id';
v_create_type text := '';
r_cn record;
v_schema text := COALESCE(p_schema,'core')||'.';
v_function_name text :=p_table_name;
v_type_name text:= '';
v_fields text := '';
v_update_fields text := '';
v_fields_datatype text:='';
v_values text := '';
v_owner text :='';
v_cursor cursor for SELECT
 pg_a.attname AS cname,
 pg_catalog.format_type (
  pg_a.atttypid,
  pg_a.atttypmod
 ) AS datatype
FROM
 pg_catalog.pg_class pg_c
INNER JOIN pg_catalog.pg_attribute pg_a ON pg_a.attrelid = pg_c.oid
INNER JOIN pg_catalog.pg_namespace pg_n ON pg_n.oid = pg_c.relnamespace
WHERE
 pg_a.attnum > 0
AND NOT pg_a.attisdropped
AND pg_n.nspname = LOWER (p_schema)
AND pg_c.relname = LOWER (p_table_name)
AND pg_c.relkind = 'r'
AND pg_a.attname NOT IN (
 'id',
 'updated_at',
 'created_at'
);

BEGIN

/*
1.1 aprakash_c 18-DEC-2014 DS-809: New Function Created
2.0 aprakash_c 05-Jan-2015 DS-809: Function parameter has been changed to individual columns instead of composite types.
2.1 aprakash_c 19-Jan-2015 DS-809: Function modified to notify the user if the input is not valid for update and delete functions.
*/


FOR r_cn in v_cursor
LOOP
v_fields:=v_fields||chr(13)||chr(10)||r_cn.cname||',';
v_values := v_values||chr(13)||'p_'||r_cn.cname||',';
v_update_fields := v_update_fields||chr(13)||chr(10)||r_cn.cname||'= '||' '||'p_'||r_cn.cname||',';
v_fields_datatype := v_fields_datatype||chr(13)||chr(10)||'p_'||r_cn.cname||'            '||r_cn.datatype||' DEFAULT NULL,';
v_type_name := v_type_name||chr(13)||r_cn.datatype||',';
END LOOP;

v_fields := substring(v_fields,1,(length(v_fields)-1));
v_values := substring(v_values,1,(length(v_values)-1));
v_update_fields := substring(v_update_fields,1,(length(v_update_fields)-1));
v_fields_datatype := substring(v_fields_datatype,1,(length(v_fields_datatype)-1));
v_type_name := substring(v_type_name,1,(length(v_type_name)-1));


raise notice 'v_fields=%',v_fields;
raise notice 'v_values=%',v_values;
raise notice 'v_fields_datatype=%',v_fields_datatype;
raise notice 'v_update_fields=%',v_update_fields;


--execute (v_create_type);

v_create_function_insert:= 'CREATE OR REPLACE FUNCTION '||v_schema||'insert_'||v_function_name|| ' ( '||v_fields_datatype ||') RETURNS INTEGER AS
$BODY$
DECLARE
v_'||p_table_name||'_id  integer;
BEGIN
/*
1.0 '||current_date|| ' user DS-809: New Function Created by core.generate_dml_func
*/
INSERT INTO '|| v_schema || p_table_name||' (id , '|| v_fields||')
VALUES
( default ,'||v_values|| ') returning id into v_'||p_table_name||'_id ;
RETURN v_'||p_table_name||'_id ;
EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE ''% %'', sqlstate, sqlerrm;
RETURN -1;
END;
$BODY$ LANGUAGE plpgsql;
';


v_create_function_update:= 'CREATE OR REPLACE FUNCTION '||v_schema||'update_'||v_function_name|| ' ('||v_function_variable||' integer, '||v_fields_datatype|| ') RETURNS INTEGER AS
$BODY$
DECLARE
updated_rows integer :=0;
BEGIN
/*
1.0 '||current_date|| ' user DS-809: New Function Created by core.generate_dml_func
*/
UPDATE '|| v_schema || p_table_name||'
SET ' ||v_update_fields|| '
WHERE id = '||v_function_variable|| ';

GET DIAGNOSTICS updated_rows = ROW_COUNT;
IF updated_rows >0 THEN
RETURN '||v_function_variable|| ';
ELSE
RETURN -1;
END IF;

EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE ''% %'', sqlstate, sqlerrm;
RETURN -1;
END;
$BODY$ LANGUAGE plpgsql;
';


v_create_function_delete := 'CREATE OR REPLACE FUNCTION '||v_schema||'delete_'||v_function_name|| ' ('||v_function_variable||' integer ) RETURNS INTEGER AS
$BODY$
DECLARE
deleted_rows integer :=0;
BEGIN
/*
1.0 '||current_date|| ' user DS-809: New Function Created by core.generate_dml_func
*/
DELETE FROM '|| v_schema || p_table_name||' WHERE id = '||v_function_variable|| ';

GET DIAGNOSTICS deleted_rows = ROW_COUNT;
IF deleted_rows >0 THEN
RETURN '||v_function_variable|| ';
ELSE
RETURN -1;
END IF;

EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE ''% %'', sqlstate, sqlerrm;
RETURN -1;
END;
$BODY$ LANGUAGE plpgsql;
';

SELECT table_catalog into v_owner FROM information_schema.tables WHERE table_schema=p_schema and table_name=p_table_name;
v_create_function_insert := v_create_function_insert || 'ALTER FUNCTION ' || v_schema ||'insert_'|| v_function_name || '('|| v_type_name||') OWNER TO ' || v_owner || ';' || chr(10);
v_create_function_update := v_create_function_update || 'ALTER FUNCTION ' || v_schema ||'update_'|| v_function_name || '(integer , '|| v_type_name||') OWNER TO ' || v_owner || ';' || chr(10);
v_create_function_delete := v_create_function_delete || 'ALTER FUNCTION ' || v_schema ||'delete_'|| v_function_name || '(integer) OWNER TO ' || v_owner || ';' || chr(10);
--execute (v_create_function_insert);
--execute (v_create_function_update);
--execute (v_create_function_update);

raise notice 'v_create_function=%',v_create_function_insert;
raise notice 'v_create_function=%',v_create_function_update;
raise notice 'v_create_function=%',v_create_function_delete;

RETURN v_create_function_insert||chr(13)||v_create_function_update||chr(13)||v_create_function_delete::text;---v_schema||'.'||v_function_name;
SET search_path TO core;

EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE '% %', sqlstate, sqlerrm;
RETURN -1;
END;
$_$;


--
-- Name: generate_dml_func_v2(text, text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION generate_dml_func_v2(p_table_name text, p_schema text) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
v_create_function_insert text;
v_create_function_update text;
v_create_function_delete text;
v_function_variable text := 'p_'||p_table_name||'_id';
v_create_type text := '';
r_cn record;
v_schema text := COALESCE(p_schema,'core')||'.';
v_function_name text :=p_table_name||'_tab';
v_type_name text:= '';
v_fields text := '';
v_update_fields text := '';
v_fields_datatype text:='';
v_values text := '';
v_owner text :='';
v_cursor cursor for SELECT
 pg_a.attname AS cname,
 pg_catalog.format_type (
  pg_a.atttypid,
  pg_a.atttypmod
 ) AS datatype
FROM
 pg_catalog.pg_class pg_c
INNER JOIN pg_catalog.pg_attribute pg_a ON pg_a.attrelid = pg_c.oid
INNER JOIN pg_catalog.pg_namespace pg_n ON pg_n.oid = pg_c.relnamespace
WHERE
 pg_a.attnum > 0
AND NOT pg_a.attisdropped
AND pg_n.nspname = LOWER (p_schema)
AND pg_c.relname = LOWER (p_table_name)
AND pg_c.relkind = 'r'
AND pg_a.attname NOT IN (
 'id',
 'updated_at',
 'created_at'
);

BEGIN

/*
1.1 aprakash_c 18-DEC-2014 DS-809: New Function Created
2.0 aprakash_c 05-Jan-2015 DS-809: Function parameter has been changed to individual columns instead of composite types.
*/


FOR r_cn in v_cursor
LOOP
v_fields:=v_fields||chr(13)||chr(10)||r_cn.cname||',';
v_values := v_values||chr(13)||'p_'||r_cn.cname||',';
v_update_fields := v_update_fields||chr(13)||chr(10)||r_cn.cname||'= '||' '||'p_'||r_cn.cname||',';
v_fields_datatype := v_fields_datatype||chr(13)||chr(10)||'p_'||r_cn.cname||'            '||r_cn.datatype||' DEFAULT NULL,';
v_type_name := v_type_name||chr(13)||r_cn.datatype||',';
END LOOP;

v_fields := substring(v_fields,1,(length(v_fields)-1));
v_values := substring(v_values,1,(length(v_values)-1));
v_update_fields := substring(v_update_fields,1,(length(v_update_fields)-1));
v_fields_datatype := substring(v_fields_datatype,1,(length(v_fields_datatype)-1));
v_type_name := substring(v_type_name,1,(length(v_type_name)-1));


raise notice 'v_fields=%',v_fields;
raise notice 'v_values=%',v_values;
raise notice 'v_fields_datatype=%',v_fields_datatype;
raise notice 'v_update_fields=%',v_update_fields;


--execute (v_create_type);

v_create_function_insert:= 'CREATE OR REPLACE FUNCTION '||v_schema||'insert_'||v_function_name|| ' ( '||v_fields_datatype ||') RETURNS INTEGER AS
$BODY$
DECLARE
v_'||p_table_name||'_id  integer;
BEGIN
/*
1.0 '||current_date|| ' user DS-809: New Function Created by core.generate_dml_func_v2
*/
INSERT INTO '|| v_schema || p_table_name||' (id , '|| v_fields||')
VALUES
( default ,'||v_values|| ') returning id into v_'||p_table_name||'_id ;
RETURN v_'||p_table_name||'_id ;
EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE ''% %'', sqlstate, sqlerrm;
RETURN -1;
END;
$BODY$ LANGUAGE plpgsql;
';


v_create_function_update:= 'CREATE OR REPLACE FUNCTION '||v_schema||'update_'||v_function_name|| ' ('||v_function_variable||' integer, '||v_fields_datatype|| ') RETURNS INTEGER AS
$BODY$
DECLARE

BEGIN
/*
1.0 '||current_date|| ' user DS-809: New Function Created by core.generate_dml_func_v2
*/
UPDATE '|| v_schema || p_table_name||'
SET ' ||v_update_fields|| '
WHERE id = '||v_function_variable|| ';
RETURN '||v_function_variable|| ';

EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE ''% %'', sqlstate, sqlerrm;
RETURN -1;
END;
$BODY$ LANGUAGE plpgsql;
';


v_create_function_delete := 'CREATE OR REPLACE FUNCTION '||v_schema||'delete_'||v_function_name|| ' ('||v_function_variable||' integer ) RETURNS INTEGER AS
$BODY$
DECLARE

BEGIN
/*
1.0 '||current_date|| ' user DS-809: New Function Created by core.generate_dml_func_v2
*/
DELETE FROM '|| v_schema || p_table_name||' WHERE id = '||v_function_variable|| ';
RETURN '||v_function_variable|| ';

EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE ''% %'', sqlstate, sqlerrm;
RETURN -1;
END;
$BODY$ LANGUAGE plpgsql;
';

SELECT table_catalog into v_owner FROM information_schema.tables WHERE table_schema=p_schema and table_name=p_table_name;
v_create_function_insert := v_create_function_insert || 'ALTER FUNCTION ' || v_schema ||'insert_'|| v_function_name || '('|| v_type_name||') OWNER TO ' || v_owner || ';' || chr(10);
v_create_function_update := v_create_function_update || 'ALTER FUNCTION ' || v_schema ||'update_'|| v_function_name || '(integer , '|| v_type_name||') OWNER TO ' || v_owner || ';' || chr(10);
v_create_function_delete := v_create_function_delete || 'ALTER FUNCTION ' || v_schema ||'delete_'|| v_function_name || '(integer) OWNER TO ' || v_owner || ';' || chr(10);
--execute (v_create_function_insert);
--execute (v_create_function_update);
--execute (v_create_function_update);

raise notice 'v_create_function=%',v_create_function_insert;
raise notice 'v_create_function=%',v_create_function_update;
raise notice 'v_create_function=%',v_create_function_delete;

RETURN v_create_function_insert||chr(13)||v_create_function_update||chr(13)||v_create_function_delete::text;---v_schema||'.'||v_function_name;
SET search_path TO core;

EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE '% %', sqlstate, sqlerrm;
RETURN -1;
END;
$_$;


--
-- Name: get_acquired_lit_document_id_by_casekey(text, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_acquired_lit_document_id_by_casekey(p_case_key text, p_lit_document_type_id integer) RETURNS SETOF integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	rec record;
	C_STATUS_ACQUIRED integer := 3;
BEGIN
	for rec in (
			  select distinct
				  ld.id::integer document_id
			  from                 core.lit_documents              as ld
			       left outer join core.docket_entry_documents_map as dedm on dedm.lit_document_id=ld.id
			       left outer join core.docket_entries             as de on de.id=dedm.docket_entry_id
			       left outer join core.lits                       as l  on l.id=de.lit_id
			  where l.case_key=p_case_key
			    and ld.lit_document_type_id=p_lit_document_type_id
			    and ld.document_status_id=C_STATUS_ACQUIRED
	    UNION
			 select distinct
				 ld.id::integer document_id
			 from
			 	 core.lit_documents ld
			 where ld.case_key=p_case_key
			   and ld.lit_document_type_id=p_lit_document_type_id
			   and ld.document_status_id=C_STATUS_ACQUIRED

			) loop
				return next rec.document_id;
	end loop;
END;
$$;


--
-- Name: get_acquired_lit_document_id_by_casekey_v001(text, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_acquired_lit_document_id_by_casekey_v001(p_case_key text, p_lit_document_type_id integer) RETURNS SETOF integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	rec record;
	C_STATUS_ACQUIRED integer := 3;
BEGIN
	for rec in (
			  select distinct
				  ld.id::integer document_id
			  from                 core.lit_documents              as ld
			       left outer join core.docket_entry_documents_map as dedm on dedm.lit_document_id=ld.id
			       left outer join core.docket_entries             as de on de.id=dedm.docket_entry_id
			       left outer join core.lits                       as l  on l.id=de.lit_id
			  where l.case_key=p_case_key
			    and ld.lit_document_type_id=p_lit_document_type_id
			    and ld.document_status_id=C_STATUS_ACQUIRED
	    UNION
			 select distinct
				 ld.id::integer document_id
			 from
			 	 core.lit_documents ld
			 where ld.case_key=p_case_key
			   and ld.lit_document_type_id=p_lit_document_type_id
			   and ld.document_status_id=C_STATUS_ACQUIRED

			) loop
				return next rec.document_id;
	end loop;
END;
$$;


--
-- Name: get_col_values_for_pat_stats_temp(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_col_values_for_pat_stats_temp(p_pat_id integer) RETURNS TABLE(num_defendants integer, is_litigated boolean)
    LANGUAGE plpgsql
    AS $_$ DECLARE
v_sql TEXT := '' ;
BEGIN
/*
1.0 aprakash_c 04-Jul-2016 : New API created
    */

    v_sql := '
SELECT
(
SELECT COUNT (DISTINCT ultimate_parent_id) AS num_defendants
FROM
(
 SELECT
ents.ultimate_parent_id
FROM core.lits_pats_map lpm
INNER JOIN core.pats p ON lpm.patnum = p.stripped_patnum AND p.country_code=''US''
INNER JOIN core.lit_annotations la ON ( la.lit_id = lpm.lit_id AND la.lit_curated_cause_type_id IN (1, 8) and la.is_abandon = false )
INNER JOIN core.lit_parties lp ON ( lp.lit_id = lpm.lit_id AND lp.dj_party_normalized_type = ''defendant'' and lp.missing_from_source_date is null)
INNER JOIN core.aliases al ON al.id = lp.alias_id
INNER JOIN core.ents ents on ents.id = al.ent_id
WHERE p.id = $1
UNION
SELECT
ents.ultimate_parent_id
FROM itc_investigations.itc_patent_numbers ipn
INNER JOIN core.pats p ON ipn.patent_number = p.stripped_patnum and p.country_code=''US''
INNER JOIN itc_investigations.itc_respondent ir ON ( ir.investigation_id = ipn.investigation_id and ir.missing_from_source_date is null )
INNER JOIN core.aliases al ON al.id = ir.respondent_party_alias_id
INNER JOIN core.ents ents on ents.id = al.ent_id
WHERE p.id = $1
) T
) ::INTEGER num_defendants,
(
SELECT
COALESCE((SELECT TRUE WHERE EXISTS((SELECT 1 FROM core.lits_pats_map lpm INNER JOIN core.lit_annotations la ON ( la.lit_id = lpm.lit_id and la.is_abandon = false) WHERE lpm.patnum = p.stripped_patnum)UNION ALL(SELECT 1 FROM itc_investigations.itc_patent_numbers ipn WHERE ipn.patent_number = p.stripped_patnum))),FALSE) AS is_litigated
FROM core.pats p
WHERE p.id = $1
AND p.country_code=''US''
) ::BOOLEAN is_litigated;
    ';

RETURN QUERY EXECUTE v_sql USING p_pat_id;  EXCEPTION
WHEN OTHERS THEN
RAISE ;
END ; $_$;


--
-- Name: get_entities_all_tree_nodes(integer[]); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_entities_all_tree_nodes(p_entity_ids integer[]) RETURNS TABLE(r_parent_id integer, r_child_id integer)
    LANGUAGE plpgsql
    AS $$
/*
anarayanan 07-Nov-2014 DS-742 : Created a new api based on core.get_entity_children to fetch all the tree nodes
anarayanan 12-Jan-2015 DS-994 : Retrun same id's even if there are no child or parent is available
*/
  BEGIN
    RETURN QUERY
      WITH RECURSIVE ent_tree (
        parent_id,
        child_id,
        tree_depth,
        ent_tree
      ) AS (
        -- This is the initial query, which becomes the operator for the recursion
        SELECT
          er.related_ent_id AS parent_id,
          er.ent_id AS child_id,
          1 AS tree_depth,
          ARRAY [ er.ent_id ] AS ent_tree
        FROM
          core.ent_relationships er
        WHERE
          er.related_ent_id = ANY (p_entity_ids)
        OR er.ent_id = ANY (p_entity_ids)
        AND er.ent_relationship_type_id IN (1, 2, 6)
        UNION ALL
          -- This query is executed on the results of the query above, and continues to execute on results until it catches itself in a loop (cycle)
          SELECT
            er.related_ent_id AS parent_id,
            er.ent_id AS child_id,
            et.tree_depth + 1 AS tree_depth,
            CASE
          WHEN ARRAY [ er.ent_id ] <@ ent_tree THEN
            ent_tree
          ELSE
            er.ent_id || ent_tree
          END AS ent_tree
          FROM
            core.ent_relationships er
          INNER JOIN ent_tree et ON er.related_ent_id = et.child_id
          OR er.ent_id = et.parent_id
          WHERE
            NOT ARRAY [ er.ent_id ] <@ ent_tree
          AND er.ent_relationship_type_id IN (1, 2, 6)
      ) SELECT DISTINCT
          ON (child_id) T .*
        FROM
          (
            SELECT
              parent_id,
              child_id
            FROM
              ent_tree e
            UNION
              SELECT
                ents.ent_id,
                ents.ent_id
              FROM
                (
                  SELECT
                    UNNEST (p_entity_ids) AS ent_id
                ) ents
          ) T;

  EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core.get_entities_all_tree_nodes] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core.get_entities_all_tree_nodes] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
    WHEN OTHERS THEN
        RAISE;
  END;
$$;


--
-- Name: get_entity_children(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_entity_children(p_entity_id integer) RETURNS TABLE(r_ent_id integer)
    LANGUAGE plpgsql
    AS $$
      DECLARE

      BEGIN
          RETURN QUERY
              WITH RECURSIVE ent_tree(parent_id, child_id, tree_depth, ent_path) AS (
                  -- This is the initial query, which becomes the operator for the recursion
                  SELECT er.related_ent_id AS parent_id, er.ent_id AS child_id, 1 AS tree_depth, ARRAY[er.related_ent_id] AS ent_path
                  FROM core.ent_relationships er
                  WHERE er.related_ent_id = p_entity_id
                      AND er.ent_relationship_type_id IN (1,2,6)

                    UNION ALL

                  -- This query is executed on the results of the query above, and continues to execute on results until it catches itself in a loop (cycle)
                  SELECT er.related_ent_id AS parent_id, er.ent_id AS child_id, et.tree_depth + 1 AS tree_depth, ent_path || er.related_ent_id AS ent_path
                  FROM core.ent_relationships er
                  INNER JOIN ent_tree et ON er.related_ent_id = et.child_id
                  WHERE NOT(er.related_ent_id = ANY(ent_path))
                      AND er.ent_relationship_type_id IN (1,2,6)
              )
              SELECT child_id
              FROM ent_tree
              --WHERE child_id != p_entity_id
              ORDER BY (parent_id = child_id) DESC, ent_path
              ;

      EXCEPTION
          WHEN data_exception THEN
              RAISE EXCEPTION '[core.get_entity_children] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
          WHEN unique_violation THEN
              RAISE EXCEPTION '[core.get_entity_children] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
          WHEN OTHERS THEN
              RAISE;

      END;
      $$;


--
-- Name: get_entity_family(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_entity_family(p_entity_id integer) RETURNS integer[]
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_ult_parent_id     INTEGER;
    v_entity_list       INTEGER[];

BEGIN
    SELECT ultimate_parent_id
    INTO v_ult_parent_id
    FROM core.ents
    WHERE id = p_entity_id;

	IF v_ult_parent_id IS NULL THEN
		RAISE EXCEPTION '[core.get_entity_family] Unable to get ultimate parent for entity id = %.',p_entity_id;
	END IF;

    SELECT array_agg(DISTINCT id)
    INTO v_entity_list
    FROM core.ents
    WHERE ultimate_parent_id = v_ult_parent_id;

    RETURN v_entity_list;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core.get_entity_family] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core.get_entity_family] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
    WHEN OTHERS THEN
        RAISE;

END;
$$;


--
-- Name: get_est_exp_date(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_est_exp_date(p_pat_id integer) RETURNS date
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
  pats_row  core.pats%ROWTYPE;
  ret_val   DATE := now();
BEGIN
  SELECT p.* INTO pats_row FROM core.pats p WHERE p.id = p_pat_id;

  IF pats_row.app_filing_date IS NULL THEN
    ret_val = pats_row.app_filing_date ;
  ELSE
    ret_val = pats_row.app_filing_date  + interval '20 year';
  END IF ;

  RETURN ret_val ;
END;
$$;


--
-- Name: get_execution_date(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_execution_date(p_pat_id integer) RETURNS date
    LANGUAGE plpgsql
    AS $$
DECLARE
  ret_val   DATE := now();
BEGIN
    SELECT MAX(aam.execution_date)
    INTO ret_val
    FROM core.pats
    INNER JOIN core.pats_assignments_map pam ON pats.patnum = pam.patnum
    LEFT JOIN core.assignors_aliases_map aam ON (aam.assignment_id = pam.pat_assignment_id)
    WHERE pats.id = p_pat_id;

    RETURN ret_val;
END;
$$;


--
-- Name: get_lit_document_by_casekey(text, integer, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_lit_document_by_casekey(p_case_key text, p_docket_entry_number integer, p_lit_document_type_id integer) RETURNS SETOF record
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	rec record;
BEGIN
	for rec in (
				select
					ld.id document_id,
					ld.document_status_id,
					ld.url source_url,
					(case when document_status_id>1 then rpx_file_location else '' end) rpx_file_location,
					(case when document_status_id>1 then rpx_file_name else '' end) 	rpx_file_name,
					ld.lit_document_type_id,
					ld.file_type_id
				from
						core.lits l
						inner join core.docket_entries de on de.lit_id=l.id
						inner join core.docket_entry_documents_map dedm on dedm.docket_entry_id=de.id
						inner join core.lit_documents ld on ld.id=dedm.lit_document_id
				where l.case_key=p_case_key
				  and de.row_number=(case when p_docket_entry_number=-1 then de.row_number else p_docket_entry_number end)
				  and ld.lit_document_type_id=(case when p_lit_document_type_id=-1 then ld.lit_document_type_id else p_lit_document_type_id end)
			) loop
				return next rec;
	end loop;
END;
$$;


--
-- Name: get_lit_document_by_document_id(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_lit_document_by_document_id(p_document_id integer) RETURNS record
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	r_rec record;
BEGIN
			select
				document_status_id,
				rpx_file_location,
				rpx_file_name,
				lit_document_type_id,
				file_type_id
				into r_rec
			from core.lit_documents
			where id=p_document_id
		 ;
	return r_rec;

END;
$$;


--
-- Name: get_lit_document_file_name(integer, text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_lit_document_file_name(p_document_id integer, p_case_key text DEFAULT NULL::text) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
declare
	v_case_key text;
    v_ld_case_key text;
	v_file_name text;
begin
	select case_key into v_ld_case_key
	from core.lit_documents
	where id=p_document_id;

if length(coalesce(p_case_key,''))>1 then
    v_case_key:=p_case_key;
elseif length(coalesce(v_ld_case_key,''))>1 then
    v_case_key:=v_ld_case_key;
else
	raise exception 'core.get_lit_documenent_file_name: missing case_key value for document_id:%',p_document_id;
end if;

v_file_name:=		'lits/'||
					substring(core.reverse_integer(p_document_id),1,3)||
					'/'||
					(
						case
							when length(core.reverse_integer(p_document_id)) > 3 then
								substring(core.reverse_integer(p_document_id),4,99)
							else
								substring(core.reverse_integer(p_document_id),1,3)
						end
					)
					||'/'||
					v_case_key||
					'.pdf';
return v_file_name;
end;
 $$;


--
-- Name: get_lit_documents_download_info(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_lit_documents_download_info(p_lit_document_id integer) RETURNS SETOF record
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE

         v_case_key            text;
         v_district            text;
         v_url                 text;
         v_url_type            text;
         v_pacer_id            text;
 v_rpx_file_name       text;
         v_rpx_file_location   text;
 i_r       record;
 r                     record;
 C_RPX_FILE_LOCATION   text := 'rpx-docs';
BEGIN
  /*
  1.1 tazhagan_c 18-Oct-2016 DS-4255 : Fix the case_key identification for a lit_document_id
  1.2 tazhagan_c 19-Dec-2016 DS-4255 : Return all cases for the lit_document instead of the latest one alone
  */

if (select 1 from core.lit_documents where id = p_lit_document_id limit 1) is null then
        raise exception 'core.get_lit_documents_download_info: could not locate document id in core.lit_documents %',p_lit_document_id;
end if;

  FOR i_r in
(
SELECT DISTINCT
        ld.id                   AS v_document_id,
        ld.url                  AS v_abs_url,
ldo.case_key            AS v_ldo_case_key,
ld.document_status_id   AS v_document_status_id,
l.case_key     AS v_l_case_key
from core.lit_documents              AS ld
    left outer join core.docket_entry_documents_map AS dedm on dedm.lit_document_id=ld.id and dedm.is_main
    left outer join core.docket_entries             AS de   on de.id=dedm.docket_entry_id
    left outer join core.lits                       AS l    on l.id=de.lit_id
    left outer join core.lit_document_orphans       AS ldo  on ld.id=ldo.lit_document_id
where ld.id=p_lit_document_id
)
loop

if  length(coalesce(i_r.v_l_case_key,'')) > 0 then
v_district := substring(i_r.v_l_case_key, 1, position('-' in i_r.v_l_case_key)-1);
v_pacer_id := substring(i_r.v_l_case_key, position('-' in i_r.v_l_case_key)+1, 999);
v_case_key := i_r.v_l_case_key;
elsif length(coalesce(i_r.v_ldo_case_key,'')) > 0 then
v_district := substring(i_r.v_ldo_case_key, 1, position('-' in i_r.v_ldo_case_key)-1);
v_pacer_id := substring(i_r.v_ldo_case_key, position('-' in i_r.v_ldo_case_key)+1, 999);
v_case_key := i_r.v_ldo_case_key;
else
raise exception 'core.get_lit_documents_download_info: could not obtain case_key (for district and pacer_id) for lit_documents.id=%',p_lit_document_id;
end if;

IF  (LENGTH(COALESCE(i_r.v_abs_url,''))>0) THEN
            v_url      := i_r.v_abs_url;
            v_url_type := 'A';
ELSE
            raise exception 'core.get_lit_documents_download_info: could not obtain pacer URL for lit_documents.id=%',p_lit_document_id;
END IF;

v_rpx_file_name     := core.get_lit_document_file_name(p_lit_document_id,v_case_key);
v_rpx_file_location := C_RPX_FILE_LOCATION;

select
            regexp_replace(v_url,'(/cgi-bin/show_doc.+)\?(add_padlock=[0-9]+?)*\&*(.+?)(\&pdf_header\=[0-9]+).*','\1?\3') AS pacer_url,
            v_url_type           AS pacer_url_type,
            v_district           AS court_district,
            v_case_key           AS rpx_case_key,
            v_pacer_id           AS pacer_id,
            v_rpx_file_name      AS rpx_file_name,
v_rpx_file_location  AS rpx_file_location,
            i_r.v_document_status_id AS current_document_status_id
into r;

return next r;

end loop;

END;
$$;


--
-- Name: get_lit_documents_download_info_v1(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_lit_documents_download_info_v1(p_lit_document_id integer) RETURNS SETOF record
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_document_id         integer;
  v_abs_url             text;
  v_rel_url             text;
  v_rpx_file_name       text;
  v_rpx_file_location   text;
  v_pacer_doc_num       text;
  v_pacer_de_seq_num    text;
  v_pacer_dm_id         text;
  v_ldo_case_key        text;
  v_l_case_key          text;
  v_case_key            text;
  v_cnt                 integer;
  v_district            text;
  v_url                 text;
  v_url_type            text;
  v_pacer_id            text;
  v_status_message      text;
  v_no_of_pages         integer;
  r                     record;
  C_RPX_FILE_LOCATION   text := 'rpx-docs';
  v_document_status_id  integer;
BEGIN

  SELECT DISTINCT
    ld.id                   AS v_document_id,
    ld.url                  AS v_abs_url,
    ld.rpx_file_name        AS v_rpx_file_name,
    ld.rpx_file_location    AS v_rpx_file_location,
    ld.doc_num              AS v_pacer_doc_num,
    ld.de_seq_num           AS v_pacer_de_seq_num,
    ld.dm_id                AS v_pacer_dm_id,
    ldo.case_key            AS v_ldo_case_key,
    ld.document_status_id   AS v_document_status_id,
    max(l.case_key) over () AS v_l_case_key,
    ld.document_status_message AS v_status_message,
    ld.no_of_pages             AS v_no_of_pages
  into
    v_document_id,
    v_abs_url,
    v_rpx_file_name,
    v_rpx_file_location,
    v_pacer_doc_num,
    v_pacer_de_seq_num,
    v_pacer_dm_id,
    v_ldo_case_key,
    v_document_status_id,
    v_l_case_key,
    v_status_message,
    v_no_of_pages
  from                 core.lit_documents              AS ld
       left outer join core.docket_entry_documents_map AS dedm on dedm.lit_document_id=ld.id
       left outer join core.docket_entries             AS de   on de.id=dedm.docket_entry_id
       left outer join core.lits                       AS l    on l.id=de.lit_id
       left outer join core.lit_document_orphans       AS ldo  on ld.id=ldo.lit_document_id
  where ld.id=p_lit_document_id;

 GET DIAGNOSTICS v_cnt=ROW_COUNT;

 if v_cnt != 1 then
 raise exception 'core.get_lit_documents_download_info: could not locate document id in core.lit_documents %',p_lit_document_id;
 end if;

 if length(coalesce(v_l_case_key,'')) > 0 then
       v_district := substring(v_l_case_key, 1, position('-' in v_l_case_key)-1);
       v_pacer_id := substring(v_l_case_key, position('-' in v_l_case_key)+1, 999);
    v_case_key := v_l_case_key;
 elsif length(coalesce(v_ldo_case_key,'')) > 0 then
    v_district := substring(v_ldo_case_key, 1, position('-' in v_ldo_case_key)-1);
    v_pacer_id := substring(v_ldo_case_key, position('-' in v_ldo_case_key)+1, 999);
    v_case_key := v_ldo_case_key;
 else
    v_case_key = v_document_id::TEXT ;
 end if;

 IF  (LENGTH(COALESCE(v_abs_url,''))>0) THEN
  v_url      := v_abs_url;
  v_url_type := 'A';
 ELSE
     raise exception 'core.get_lit_documents_download_info: could not obtain pacer URL for lit_documents.id=%',p_lit_document_id;
 END IF;

 v_rpx_file_name     := core.get_lit_document_file_name(p_lit_document_id,v_case_key);
 v_rpx_file_location := C_RPX_FILE_LOCATION;

 for r in (
       select
    regexp_replace(v_url,'(/cgi-bin/show_doc.+)\?(add_padlock=[0-9]+?)*\&*(.+?)(\&pdf_header\=[0-9]+).*','\1?\3') AS pacer_url,
       v_url_type           AS pacer_url_type,
       v_district           AS court_district,
       v_case_key           AS rpx_case_key,
       v_pacer_id           AS pacer_id,
    v_rpx_file_name      AS rpx_file_name,
    v_rpx_file_location  AS rpx_file_location,
                     v_document_status_id AS current_document_status_id,
                     v_status_message AS status_message,
                     v_no_of_pages AS no_of_pages
  ) loop
   return next r;
 end loop;

end;
$$;


--
-- Name: get_lit_documents_requested(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_lit_documents_requested(p_max_documents integer DEFAULT 1) RETURNS SETOF integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
declare
  v_semaphore integer;
  v_cnt integer;
  r record;
begin
 --synchronize access
 select semaphore
        into v_semaphore
 from core.lit_documents_download_semaphore
 for update;

 GET DIAGNOSTICS v_cnt=ROW_COUNT;

 if v_cnt != 1 then
	raise exception 'core.get_lit_documents_requested: number of rows in core.get_lit_documents_requested is wrong: &',v_cnt;
 end if;
 for r in
   (
	 select id as "document_id"
	 from core.lit_documents
	 where document_status_id=2
	 limit p_max_documents
	 for update
   ) loop
       update core.lit_documents set document_status_id=5 where id=r.document_id;
	   return next r.document_id;
 end loop;
end;
$$;


--
-- Name: get_lit_parties(integer, integer, integer, text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_lit_parties(p_lit_id integer, p_num_of_records integer DEFAULT 0, p_offset integer DEFAULT 0, search_text text DEFAULT NULL::text) RETURNS TABLE(lit_party_id integer, lit_party_type_id integer, lit_party_type_name character varying, alias_id integer, alias_name character varying, ent_id integer, entity_name character varying, total_records bigint)
    LANGUAGE plpgsql
    AS $_$
DECLARE
/*
   Returns all parties, with their aliases and entities, for the specific lit_id

   Usage examples:

   select * from core.get_lit_parties(17393);

   select * from core.get_lit_parties(17393, 0, 0, 'rsa'); -- search for 'rsa' at the beginning of the alias name

   select * from core.get_lit_parties(17393, 10); -- returns first 10 rows

   select * from core.get_lit_parties(17393, 10, 20); -- returns 10 rows with offset 20

   select * from core.get_lit_parties(17393, 2, 2, 'p'); -- returns names that start with p, 2 records, with offset 2

   select * from core.get_lit_parties(47133,50,0,'L'' UNIVERSITE');

 1.0 vsolomakha DS-3014 - Create a new API function to return all lit_parties mapped alias information.
 1.1 tazhagan_c 06-Jan-2016 DS-3014 - Added total records in the output
 1.2 ajayakodi_c 08-jan-2016 DS-3014 - Added condition to return records only lit_parties where lit_party_type of defendant, plaintiff, counter defendant and counter claimant
 1.3 tazhagan_c 21-Jun-2017 DS-5530 : Handle single quotes in input
 */
 v_sql text := '';

BEGIN
  v_sql = '
      select lp.id as lit_party_id,
             lp.lit_party_type_id,
             lpt.lit_party_normalized_type as lit_party_type_name,
             lp.alias_id,
             al.name as alias_name,
             al.ent_id,
             ents.name as entity_name,
         count(*) over () as total_records
      from core.lit_parties lp
      inner join core.aliases al on lp.alias_id = al.id
      left join core.ents on al.ent_id = ents.id
      inner join core.lit_party_types lpt on lpt.id = lp.lit_party_type_id
      where lp.lit_id = $1
      and lpt.id in (74,75,76,77)
  ';

  if search_text ~ '''' then search_text := regexp_replace(search_text,'''',''''''); end if;

  if (search_text is not null and search_text != '') then
    v_sql := v_sql || '
      and al.name ilike ''' || search_text || '%''';
  end if;

  if (p_num_of_records > 0) then
    v_sql := v_sql || '
      limit $2';
    if (p_offset > 0) then
      v_sql := v_sql || '
        offset $3';
    end if;
  end if;

  RETURN QUERY EXECUTE v_sql using p_lit_id, p_num_of_records, p_offset;

EXCEPTION
    WHEN OTHERS THEN
        RAISE;
END;
$_$;


--
-- Name: get_most_recent_assignee(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_most_recent_assignee(p_pat_id integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    ret_val   VARCHAR;
BEGIN

    SELECT STRING_AGG(a.core_name, ', ')
    INTO ret_val
    FROM core.aliases a
    LEFT JOIN core.assignees_aliases_map aam ON (aam.alias_id = a.id)
    WHERE aam.assignment_id IN
        ( SELECT pam.pat_assignment_id
          FROM core.pats
          JOIN core.pats_assignments_map pam ON pats.patnum = pam.patnum
          JOIN core.assignors_aliases_map aami ON aami.assignment_id = pam.pat_assignment_id
          WHERE pats.id = p_pat_id
          ORDER BY aami.execution_date DESC limit 1
        ) ;

    RETURN ret_val;
END;
$$;


--
-- Name: get_new_col_values_for_pat_stats(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_new_col_values_for_pat_stats(p_pat_id integer) RETURNS TABLE(examination_thoroughness numeric, num_citing_clusters integer, num_citing_assignees integer, num_defendants integer, word_cnt_shortest_indep_claim integer)
    LANGUAGE plpgsql
    AS $_$ DECLARE
	v_sql TEXT := '' ;
BEGIN
	/*
	1.0 aprakash_c 04-Jul-2016 : New API created
    */

    v_sql := '
		SELECT
			COALESCE (
				(
					SELECT
						(
							(
								SELECT
									COUNT (DISTINCT T .transaction_desc) num_events
								FROM
									pair.app_data ad
								JOIN pair.transaction_history T ON T .app_data_id = ad. ID
								WHERE
									ad.pat_id = pats. ID
							) * (
								SELECT
									1.25 - allowance_rate
								FROM
									core.pats_aliases_map A
								JOIN (
									SELECT
										alias_id,
										allowed / (filed * 1.00) AS allowance_rate
									FROM
										(
											SELECT
												amap.alias_id,
												COUNT (
													DISTINCT CASE
													WHEN inv.document_type = ''issued patent'' THEN
														inv.invention_id
													ELSE
														NULL
													END
												) AS allowed,
												COUNT (DISTINCT inv.invention_id) AS filed
											FROM
												core.pats_invention_link inv
											JOIN core.pats_aliases_map amap ON amap.pat_id = inv.pat_id
											WHERE
												inv.pat_id = pats. ID
											AND amap.pats_aliases_relationship_type_id = 5
											GROUP BY
												1
										) mid
								) e ON e.alias_id = A .alias_id
								WHERE
									A .pat_id = pats. ID
								AND A .pats_aliases_relationship_type_id = 5
								LIMIT 1
							)
						)
					FROM
						core.pats
					INNER JOIN pair.app_data ad ON ad.pat_id = pats. ID
					WHERE
						pats. ID = $1
				),
				20
			) :: NUMERIC examination_thoroughness,
			(
				SELECT
					COUNT (DISTINCT ac.supercluster_id) AS num_citing_clusters
				FROM
					core.pat_references pr
				JOIN pa_web.analysis_patentclustermap ac ON ac.patent_id = pr.pat_id
				WHERE
					pr.ref_pat_id = $1
			) :: INTEGER num_citing_clusters,
			(
				SELECT
					COUNT (
						DISTINCT ents.ultimate_parent_id
					) AS num_citing_assignees
				FROM
					core.pat_references pr
				JOIN core.pat_stats stats ON stats.pat_id = pr.pat_id
				JOIN core.pat_stats_current_assignees ca ON ca.pat_stats_id = stats. ID
				JOIN core.alias_ent_details ents ON ents.alias_id = ca.alias_id
				WHERE
					pr.ref_pat_id = $1
			) :: INTEGER num_citing_assignees,			
			(
				 SELECT 
					COUNT (DISTINCT ents.ultimate_parent_id) AS num_defendants
				FROM core.lits_pats_map lpm
				INNER JOIN core.pats p ON lpm.patnum = p.stripped_patnum AND p.country_code=''US''
				INNER JOIN core.lit_annotations la ON ( la.lit_id = lpm.lit_id AND la.lit_curated_cause_type_id IN (1, 8) )
				INNER JOIN core.lit_parties lp ON ( lp.lit_id = lpm.lit_id AND lp.dj_party_normalized_type = ''defendant'' and lp.missing_from_source_date is null)
				INNER JOIN core.aliases al ON al.id = lp.alias_id
				INNER JOIN core.ents ents on ents.id = al.ent_id
				WHERE p.id = $1
			) ::INTEGER num_defendants,
			(
				SELECT MIN(word_count) AS word_cnt_indep_claims 
					FROM core.pat_claims pc 
				WHERE NOT EXISTS (SELECT 1 FROM core.pat_claim_relationships pcr WHERE pcr.pat_claims_id = pc. ID) 
				AND pat_id = $1
			) ::INTEGER word_cnt_shortest_indep_claim;
    ';

	RETURN QUERY EXECUTE v_sql USING p_pat_id;  EXCEPTION
WHEN OTHERS THEN
	RAISE ;
END ; $_$;


--
-- Name: get_pat_ent_relationships(integer[], text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_pat_ent_relationships(p_pat_ids integer[] DEFAULT NULL::integer[], p_id_query text DEFAULT NULL::text) RETURNS TABLE(pat_id integer, inventor_alias_ids integer[], inventor_ent_ids integer[], primary_examiner_alias_ids integer[], primary_examiner_ent_ids integer[], secondary_examiner_alias_ids integer[], secondary_examiner_ent_ids integer[], original_assignee_alias_ids integer[], original_assignee_ent_ids integer[], sponsoring_party_alias_ids integer[], sponsoring_party_ent_ids integer[], current_assignee_alias_ids integer[], current_assignee_ent_ids integer[], any_assignee_alias_ids integer[], any_assignee_ent_ids integer[], litigated_by_district_court_alias_ids integer[], litigated_by_district_court_ent_ids integer[], litigated_by_itc_alias_ids integer[], litigated_by_itc_ent_ids integer[], ptab_patent_owner_alias_ids integer[], ptab_patent_owner_ent_ids integer[], litigated_against_district_court_alias_ids integer[], litigated_against_district_court_ent_ids integer[], litigated_against_itc_alias_ids integer[], litigated_against_itc_ent_ids integer[], ptab_petitioner_alias_ids integer[], ptab_petitioner_ent_ids integer[], current_assignee_citation_alias_ids integer[], current_assignee_citation_ent_ids integer[], current_assignee_citee_alias_ids integer[], current_assignee_citee_ent_ids integer[], potentially_relevant_company_alias_ids integer[], potentially_relevant_company_ent_ids integer[], pa_web_licensee_alias_ids integer[], pa_web_licensee_ent_ids integer[], correspondent_alias_ids integer[], correspondent_ent_ids integer[])
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_sql text := '';
	v_pat_ids integer[];
BEGIN
/*
 1.0 tazhagan_c 17-May-2016 DS-3780 : Table for querying patent (inventions) + alias / entity relationships
 1.1 tazhagan_c 18-May-2016 DS-3780 : Remove ultimate_parent_id related information
 1.2 anarayanan 23-May-2016 DS-3780 : For md5 comparison added uniq(sor()) on all the columns
 1.3 anarayanan 26-May-2016 DS-3780 : Used patent_blaster tables instead of pa_web tables
 2.0 tazhagan_c 16-Dec-2016 DS-4616 : We should consider all litigations from rpx_reporting.all_lits instead of just "Willful Patent Infringement"
 Sample : 
 
 select * from core.get_pat_ent_relationships(p_id_query:='select array_agg(id) from core.pats where id <= 10');
 
 select * from core.get_pat_ent_relationships(p_pat_ids:=ARRAY[1,2,3,4,5,6,7,8,9,10]);
*/	

	IF p_id_query IS NULL AND p_pat_ids IS NULL THEN
		RAISE EXCEPTION 'One of the paramters p_id_query,p_pat_ids is mandatory for the api core.get_pat_ent_relationships to be executed';
	END IF;
	
	IF p_id_query IS NOT NULL THEN
		EXECUTE p_id_query INTO v_pat_ids;
	END IF;

	v_pat_ids := v_pat_ids || p_pat_ids;
  
		v_sql := '
			with pats as
			(
			select id as pat_id,patnum,stripped_patnum,country_code 
			from core.pats 
			where id = ANY($1::int[])
			)
			,
			pat_aliases_all_rel_types as
			(
			select pats.pat_id,
			aed.alias_id,
			aed.ent_id,
			part.name as pats_aliases_relationship_type_name
			from pats
			inner join core.pats_aliases_map pam on pam.pat_id = pats.pat_id
			inner join core.pats_aliases_relationship_types part on pam.pats_aliases_relationship_type_id = part.id and part.name in (''Inventor'',''Primary Examiner'',''Assistant Examiner'')
			inner join core.alias_ent_details aed on pam.alias_id = aed.alias_id
			group by 1,2,3,4
			)
			,
			inventors as
			(
			select pat_id,
			uniq(sort((array_agg(alias_id)))) as inventor_alias_ids,
			uniq(sort(string_to_array(string_agg(ent_id::text,'',''),'','')::integer[])) as inventor_ent_ids
			from pat_aliases_all_rel_types where pats_aliases_relationship_type_name=''Inventor''
			group by pat_id
			)
			,
			primary_examiners as
			(
			select pat_id,
			uniq(sort((array_agg(alias_id)))) as primary_examiner_alias_ids,
			uniq(sort(string_to_array(string_agg(ent_id::text,'',''),'','')::integer[])) as primary_examiner_ent_ids
			from pat_aliases_all_rel_types where pats_aliases_relationship_type_name=''Primary Examiner''
			group by pat_id
			)
			,
			secondary_examiners as
			(
			select pat_id,
			uniq(sort((array_agg(alias_id)))) as secondary_examiner_alias_ids,
			uniq(sort(string_to_array(string_agg(ent_id::text,'',''),'','')::integer[])) as secondary_examiner_ent_ids
			from pat_aliases_all_rel_types where pats_aliases_relationship_type_name=''Assistant Examiner''
			group by pat_id
			)
			,
			pat_assignments as
			(
			select pats.pat_id,aed.alias_id,aed.ent_id,pam.is_zero_assignment
			from pats
			inner join core.pats_assignments_map pam on pam.pat_id = pats.pat_id
			inner join core.pat_assignments pa on pa.id = pam. pat_assignment_id
			inner join core.alias_ent_details aed on pa.correspondent_alias_id = aed.alias_id
			)
			,
			original_assignees as
			(
			select pat_id,
			uniq(sort(array_agg(alias_id))) as original_assignee_alias_ids,
			uniq(sort(string_to_array(string_agg(ent_id::text,'',''),'','')::integer[])) as original_assignee_ent_ids
			from pat_assignments where is_zero_assignment
			group by pat_id
			)
			,
			sponsoring_parties as
			(
			select pats.pat_id,
			uniq(sort(array_agg(aed.alias_id))) as sponsoring_party_alias_ids,
			uniq(sort(string_to_array(string_agg(aed.ent_id::text,'',''),'','')::integer[])) as sponsoring_party_ent_ids
			from pats
			inner join core.pat_stats_sponsoring_parties pssp on pssp.pat_id = pats.pat_id
			inner join core.alias_ent_details aed on pssp.alias_id = aed.alias_id
			group by pats.pat_id
			)
			,
			current_assignees as
			(
			select pats.pat_id,
			uniq(sort(array_agg(aed.alias_id))) as current_assignee_alias_ids,
			uniq(sort(string_to_array(string_agg(aed.ent_id::text,'',''),'','')::integer[])) as current_assignee_ent_ids
			from pats
			inner join core.pat_stats_current_assignees pscp on pscp.pat_id = pats.pat_id
			inner join core.alias_ent_details aed on pscp.alias_id = aed.alias_id
			group by pats.pat_id
			)
			,
			any_assignees as
			(
			select pats.pat_id,
			uniq(sort(array_agg(aed.alias_id))) as any_assignee_alias_ids,
			uniq(sort(string_to_array(string_agg(aed.ent_id::text,'',''),'','')::integer[])) as any_assignee_ent_ids
			from pats
			inner join core.pat_stats_all_assignees psap on psap.pat_id = pats.pat_id
			inner join core.alias_ent_details aed on psap.alias_id = aed.alias_id
			group by pats.pat_id
			)
			,
			litigated_district_court as
			(
			select pats.pat_id,
			aed.alias_id,
			aed.ent_id,
			lp.dj_party_normalized_type
			from pats
			inner join core.lits_pats_map lpm on lpm.patnum = pats.stripped_patnum
			inner join core.lit_parties lp on (lp.lit_id = lpm.lit_id and lp.missing_from_source_date is null and lp.dj_party_normalized_type in (''plaintiff'',''defendant''))
			inner join core.alias_ent_details aed on lp.alias_id = aed.alias_id
			where exists (select 1 from rpx_reporting.all_lits al where al.core_lit_id = lpm.lit_id and al.is_primary)
			group by 1,2,3,4
			)
			,
			litigated_by_district_court as
			(
			select pat_id,
			uniq(sort((array_agg(alias_id)))) as litigated_by_district_court_alias_ids,
			uniq(sort(string_to_array(string_agg(ent_id::text,'',''),'','')::integer[])) as litigated_by_district_court_ent_ids
			from litigated_district_court
			where dj_party_normalized_type = ''plaintiff''
			group by pat_id
			)
			,
			litigated_by_itc as
			(
			select pats.pat_id,
			uniq(sort(array_agg(aed.alias_id))) as litigated_by_itc_alias_ids,
			uniq(sort(string_to_array(string_agg(aed.ent_id::text,'',''),'','')::integer[])) as litigated_by_itc_ent_ids
			from pats
			inner join itc_investigations.itc_patent_numbers ipn on ipn.patent_number = pats.stripped_patnum
			inner join itc_investigations.itc_complainant ic on (ic.investigation_id = ipn.investigation_id and ic.missing_from_source_date is null)
			inner join core.alias_ent_details aed on ic.complainant_party_alias_id = aed.alias_id
			group by pats.pat_id
			)
			,
			ptab_all_parties as
			(
			select pats.pat_id,
			aed.alias_id,
			aed.ent_id,
			ppt.name as ptab_party_name
			from pats
			inner join ptab.ptab_cases pc on pats.stripped_patnum = pc.stripped_patnum and pats.country_code = pc.country_code
			inner join ptab.ptab_parties pp on pp.ptab_case_id = pc.id
			inner join ptab.ptab_party_types ppt on (ppt.id = pp.ptab_party_type_id and ppt.name in(''Patent Owner'',''Petitioner''))
			inner join core.alias_ent_details aed on pp.alias_id = aed.alias_id
			group by 1,2,3,4
			)
			,
			ptab_patent_owner as
			(
			select pat_id,
			uniq(sort((array_agg(alias_id)))) as ptab_patent_owner_alias_ids,
			uniq(sort(string_to_array(string_agg(ent_id::text,'',''),'','')::integer[])) as ptab_patent_owner_ent_ids
			from ptab_all_parties
			where ptab_party_name = ''Patent Owner''
			group by pat_id
			)
			,
			litigated_against_district_court as
			(
			select pat_id,
			uniq(sort((array_agg(alias_id)))) as litigated_against_district_court_alias_ids,
			uniq(sort(string_to_array(string_agg(ent_id::text,'',''),'','')::integer[])) as litigated_against_district_court_ent_ids
			from litigated_district_court
			where dj_party_normalized_type = ''defendant''
			group by pat_id
			)
			,
			litigated_against_itc as
			(
			select pats.pat_id,
			uniq(sort(array_agg(aed.alias_id))) as litigated_against_itc_alias_ids,
			uniq(sort(string_to_array(string_agg(aed.ent_id::text,'',''),'','')::integer[])) as litigated_against_itc_ent_ids
			from pats
			inner join itc_investigations.itc_patent_numbers ipn on ipn.patent_number = pats.stripped_patnum
			inner join itc_investigations.itc_respondent ir on (ir.investigation_id = ipn.investigation_id and ir.missing_from_source_date is null)
			inner join core.alias_ent_details aed on ir.respondent_party_alias_id = aed.alias_id
			group by pats.pat_id
			)
			,
			ptab_petitioner as
			(
			select pat_id,
			uniq(sort((array_agg(alias_id)))) as ptab_petitioner_alias_ids,
			uniq(sort(string_to_array(string_agg(ent_id::text,'',''),'','')::integer[])) as ptab_petitioner_ent_ids
			from ptab_all_parties
			where ptab_party_name = ''Petitioner''
			group by pat_id
			)
			,
			current_assignee_citation as
			(
			select pats.pat_id,
			uniq(sort(array_agg(aed.alias_id))) as current_assignee_citation_alias_ids,
			uniq(sort(string_to_array(string_agg(aed.ent_id::text,'',''),'','')::integer[])) as current_assignee_citation_ent_ids
			from pats
			inner join core.pat_references pr on pr.ref_pat_id = pats.pat_id
			inner join core.pat_stats_current_assignees pscp on pscp.pat_id = pr.pat_id
			inner join core.alias_ent_details aed on pscp.alias_id = aed.alias_id
			group by pats.pat_id
			)
			,
			current_assignee_citee as
			(
			select pats.pat_id,
			uniq(sort(array_agg(aed.alias_id))) as current_assignee_citee_alias_ids,
			uniq(sort(string_to_array(string_agg(aed.ent_id::text,'',''),'','')::integer[])) as current_assignee_citee_ent_ids
			from pats
			inner join core.pat_references pr on pr.pat_id = pats.pat_id
			inner join core.pat_stats_current_assignees pscp on pscp.pat_id = pr.ref_pat_id
			inner join core.alias_ent_details aed on pscp.alias_id = aed.alias_id
			group by pats.pat_id
			)
			,
			potentially_relevant_companies as
			(
			select pats.pat_id,
			NULL::integer[] as potentially_relevant_company_alias_ids,
			uniq(sort(string_to_array(string_agg(prc.ent_id::text,'',''),'','')::integer[])) as potentially_relevant_company_ent_ids
			from pats
			inner join patent_blaster.pat_relevant_companies prc on prc.pat_id = pats.pat_id
			group by pats.pat_id
			)
			,
			pa_web_licensees as
			(
			select pats.pat_id,
			NULL::integer[] as pa_web_licensee_alias_ids,
			uniq(sort(string_to_array(string_agg(pl.ent_id::text,'',''),'','')::integer[])) as pa_web_licensee_ent_ids
			from pats
			inner join patent_blaster.pat_licensees pl on pl.pat_id = pats.pat_id
			group by pats.pat_id
			)
			,
			correspondents as
			(
			select pat_id,
			uniq(sort(array_agg(alias_id))) as correspondent_alias_ids,
			uniq(sort(string_to_array(string_agg(ent_id::text,'',''),'','')::integer[])) as correspondent_ent_ids
			from pat_assignments
			group by pat_id
			)
			select pats.pat_id,inv.inventor_alias_ids,inv.inventor_ent_ids,
			pe.primary_examiner_alias_ids,pe.primary_examiner_ent_ids,
			se.secondary_examiner_alias_ids,se.secondary_examiner_ent_ids,
			oa.original_assignee_alias_ids,oa.original_assignee_ent_ids,
			sp.sponsoring_party_alias_ids,sp.sponsoring_party_ent_ids,
			ca.current_assignee_alias_ids,ca.current_assignee_ent_ids,
			aa.any_assignee_alias_ids,aa.any_assignee_ent_ids,
			lbdc.litigated_by_district_court_alias_ids,lbdc.litigated_by_district_court_ent_ids,
			lbi.litigated_by_itc_alias_ids,lbi.litigated_by_itc_ent_ids,
			ppo.ptab_patent_owner_alias_ids,ppo.ptab_patent_owner_ent_ids,
			ladc.litigated_against_district_court_alias_ids,ladc.litigated_against_district_court_ent_ids,
			lac.litigated_against_itc_alias_ids,lac.litigated_against_itc_ent_ids,
			ppe.ptab_petitioner_alias_ids,ppe.ptab_petitioner_ent_ids,
			cac.current_assignee_citation_alias_ids,cac.current_assignee_citation_ent_ids,
			cac1.current_assignee_citee_alias_ids,cac1.current_assignee_citee_ent_ids,
			prc.potentially_relevant_company_alias_ids,prc.potentially_relevant_company_ent_ids,
			pwl.pa_web_licensee_alias_ids,pwl.pa_web_licensee_ent_ids,
			co.correspondent_alias_ids,co.correspondent_ent_ids
			from pats
			left join inventors inv on pats.pat_id = inv.pat_id
			left join primary_examiners pe on pats.pat_id = pe.pat_id
			left join secondary_examiners se on pats.pat_id = se.pat_id
			left join original_assignees oa on pats.pat_id = oa.pat_id
			left join sponsoring_parties sp on pats.pat_id = sp.pat_id
			left join current_assignees ca on pats.pat_id = ca.pat_id
			left join any_assignees aa on pats.pat_id = aa.pat_id
			left join litigated_by_district_court lbdc on pats.pat_id = lbdc.pat_id
			left join litigated_by_itc lbi on pats.pat_id = lbi.pat_id
			left join ptab_patent_owner ppo on pats.pat_id = ppo.pat_id
			left join litigated_against_district_court ladc on pats.pat_id = ladc.pat_id
			left join litigated_against_itc lac on pats.pat_id = lac.pat_id
			left join ptab_petitioner ppe on pats.pat_id = ppe.pat_id
			left join current_assignee_citation cac on pats.pat_id = cac.pat_id
			left join current_assignee_citee cac1 on pats.pat_id = cac1.pat_id
			left join potentially_relevant_companies prc on pats.pat_id = prc.pat_id
			left join pa_web_licensees pwl on pats.pat_id = pwl.pat_id
			left join correspondents co on pats.pat_id = co.pat_id';
			
			RETURN QUERY EXECUTE v_sql USING v_pat_ids; 
			
			EXCEPTION
				WHEN OTHERS THEN
					RAISE;
END;
$_$;


--
-- Name: get_pat_family_pats_details(integer[], text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_pat_family_pats_details(p_pat_id integer[] DEFAULT NULL::integer[], p_id_query text DEFAULT NULL::text) RETURNS TABLE(pat_id integer, patnum character varying, stripped_patnum character varying, country_code character varying, pat_family_id integer, pat_family_name character varying, pat_family_priority_date date, pat_family_expiry_date date, pat_family_us_patent_count integer, pat_family_us_application_count integer, pat_family_non_us_patent_count integer, pat_family_non_us_application_count integer, pat_family_first_us_stripped_patnum character varying)
    LANGUAGE plpgsql
    AS $_$

DECLARE
v_sql TEXT := '';

v_pat_ids INTEGER [];

BEGIN IF p_id_query IS NOT NULL THEN
		EXECUTE p_id_query
		INTO v_pat_ids;
END IF ;
	v_pat_ids := v_pat_ids || p_pat_id;

v_sql := '
SELECT
	pats. ID AS pat_id,
	pats.patnum,
	pats.stripped_patnum,
	pats.country_code,
	pfp.pat_family_id,
	pf. NAME AS pat_family_name,
	pf.priority_date AS pat_family_priority_date,
	pf.expiry_date AS pat_family_expiry_date,
	pf.us_patent_count AS pat_family_us_patent_count,
	pf.us_application_count AS pat_family_us_application_count,
	pf.non_us_patent_count AS pat_family_non_us_patent_count,
	pf.non_us_application_count AS pat_family_non_us_application_count,
	pf.first_us_stripped_patnum AS pat_family_first_us_stripped_patnum
FROM
	core.pats
INNER JOIN docdb_families.pat_family_pats pfp ON (
	pfp.stripped_patnum = pats.stripped_patnum
	AND pfp.country_code = ''US''
	AND pats.doc_kind_code != ''W0''
)
INNER JOIN docdb_families.pat_families pf ON pf. ID = pfp.pat_family_id
WHERE pats.id = ANY($1)
';

RETURN QUERY EXECUTE v_sql using v_pat_ids;
EXCEPTION WHEN OTHERS THEN RAISE;END;$_$;


--
-- Name: get_patent_info(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_patent_info() RETURNS SETOF cp_core_etl_patent
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	core_patent cp_core_etl_patent;
BEGIN
	for core_patent in
	(
		SELECT DISTINCT
					title,
					application_date,
					publication_date,
					core_db_patent_id,
					core_db_patnum,
					patnum,
					is_application,
					inventor
		FROM
		(
			SELECT
					title,
					application_date,
					publication_date,
					core_db_patent_id,
					core_db_patnum,
					patnum,
					is_application,
					inventor,
					max(publication_date) over (partition by patnum,application_date) latest_publication_date
			FROM
			(
				SELECT
						pat.title,
						pat.app_filing_date application_date,
						pat.publication_date,
						pat.id core_db_patent_id,
						pat.patnum core_db_patnum,
						(
							case
								when pat.patnum similar to 'US_______[A-Z][0-9]+' then substring(pat.patnum from 3 for 7) ---> patent
								else substring(pat.app_num_country from 3 for 2)||'/'||substring(pat.app_num_country from 5 for 6) --->application
							end
						) patnum,
						(case
							when pat.patnum similar to 'US_______[A-Z][0-9]+' then false ---> patent
							else true --->application
						end) is_application,
						public.inventors_for_patent(pat.id) inventor
				FROM core.pats pat
				WHERE
					(
						case
							when pat.patnum similar to 'US_______[A-Z][0-9]+' then substring(pat.patnum from 3 for 7) ---> patent
							else substring(pat.app_num_country from 3 for 2)||'/'||substring(pat.app_num_country from 5 for 6) --->application
						end
					)
				in
					(
							SELECT DISTINCT patnum
							from dblink
							( config.dblink_connection('raw'),
							'
								SELECT
									translate(regexp_split_to_table(portfolio_patents,E''\\s+''),'',;- ()'''''','''') patnum
								FROM sf.opportunity
								WHERE isdeleted = ''false''
								AND recordtypeid = ''012400000005PJbAAM''
								AND confidentiality_level != ''Highly Confidential''
							'
							) as pat(patnum text)
					)
			) RS
		) RS2
		WHERE publication_date=latest_publication_date
	) LOOP
		return next core_patent;
	end loop;
END;
$$;


--
-- Name: get_priority_date(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_priority_date(p_pat_id integer) RETURNS date
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
  pats_row  core.pats%ROWTYPE;
  ret_val   DATE := now();
BEGIN
  SELECT p.* INTO pats_row FROM core.pats p WHERE p.id = p_pat_id;

  IF pats_row.pct_102_date IS NULL THEN
    ret_val = pats_row.app_filing_date ;
  ELSE
    IF pats_row.app_filing_date IS NULL THEN
      ret_val = pats_row.pct_102_date ;
    ELSE
      IF pats_row.pct_102_date < pats_row.app_filing_date THEN
        ret_val = pats_row.pct_102_date;
      ELSE
        ret_val = pats_row.app_filing_date;
      END IF;
    END IF ;
  END IF;

  RETURN ret_val;
END;
$$;


--
-- Name: get_ptab_case_id(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_ptab_case_id(p_petition_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_case_key varchar;
  v_ptab_case_id BIGINT := -1;
BEGIN

   SELECT case_key into v_case_key from ldc.lit_docs_ptab_petitions WHERE id = p_petition_id ;

   IF FOUND THEN
      SELECT id INTO v_ptab_case_id FROM ptab.ptab_cases WHERE case_num = v_case_key;
   ELSE
      RAISE Notice 'Case key  not found in ldc.lit_docs_ptab_petitions for petition % .',p_petition_id ;
   END IF;

   RETURN v_ptab_case_id;

END;
$$;


--
-- Name: get_ptab_party_id(integer, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_ptab_party_id(p_petition_id integer, p_ptab_petition_party_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_ptab_case_id BIGINT := -1;
  v_party_alias_id BIGINT := -1;
  v_ptab_party_id BIGINT := -1;
BEGIN

  SELECT core.get_ptab_case_id(p_petition_id) INTO v_ptab_case_id;

  IF v_ptab_case_id = -1 THEN
      RAISE Notice 'Case key  not found in ldc.lit_docs_ptab_petitions for petition % .',p_petition_id ;
  ELSE

    SELECT party_alias_id INTO v_party_alias_id FROM ldc.lit_docs_ptab_petition_parties WHERE petition_id  = p_petition_id AND id = p_ptab_petition_party_id ;

    IF FOUND THEN

      SELECT id into v_ptab_party_id FROM ptab.ptab_parties WHERE ptab_case_id = v_ptab_case_id and alias_id = v_party_alias_id ;

    ELSE
      RAISE Notice 'Party Alias id not found in ldc.lit_docs_ptab_petition_parties for petition %  & petition pparty id % .',p_petition_id ,p_ptab_petition_party_id ;
    END IF;

  END IF;

  RETURN v_ptab_party_id;

END;
$$;


--
-- Name: get_select_string(character varying, character varying, text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_select_string(i_tab_name character varying, i_tab_alias character varying DEFAULT NULL::character varying, i_tab_ignore_cols text DEFAULT NULL::text) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
 v_sql text := '';
 rd record;
BEGIN
/*
  aprakash_c 10-Aug-2015 DS-2067 : Deployed in coredb for the usage in lit_campaigns.refresh_campaign_metrics
*/
 for rd in
  SELECT
    a.attname as cname,
    pg_catalog.format_type(a.atttypid, a.atttypmod) as datatype
  FROM
    pg_catalog.pg_attribute a
  JOIN
    (SELECT c.oid,c.*,n.*
     FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace) c ON a.attrelid=c.oid
  WHERE a.attnum > 0
  AND NOT a.attisdropped
  AND nspname = (string_to_array(i_tab_name, '.'))[1]----schema name here
  AND relname = lower((string_to_array(i_tab_name, '.'))[2]) ----table name here
  AND a.attname not in ('created_at', 'updated_at', 'created_by', 'updated_by', 'stg_id', 'to_be_indexed', 'is_deleted')
  AND NOT (a.attname = any ((SELECT regexp_split_to_array(i_tab_ignore_cols, E',') || '{}')::name[]))
  AND relkind = 'r'
  ORDER BY a.attname loop
   if lower(rd.cname) <> 'stg_id' and lower(rd.cname) <> 'batch_number' then
    v_sql := v_sql || ',' || case when i_tab_alias is null then rd.cname else  i_tab_alias || '.' || rd.cname end;
   end if;
 end loop;
 return ltrim(v_sql, ',');
END;
$$;


--
-- Name: get_select_string_all(character varying, character varying, text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_select_string_all(i_tab_name character varying, i_tab_alias character varying DEFAULT NULL::character varying, i_tab_ignore_cols text DEFAULT NULL::text) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
 v_sql text := '';
 rd record;
BEGIN
/*
  1.0 tazhagan_c N/A : New version without excluding any columns
*/
 for rd in
  SELECT
    a.attname as cname,
    pg_catalog.format_type(a.atttypid, a.atttypmod) as datatype
  FROM
    pg_catalog.pg_attribute a
  JOIN
    (SELECT c.oid,c.*,n.*
     FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace) c ON a.attrelid=c.oid
  WHERE a.attnum > 0
  AND NOT a.attisdropped
  AND nspname = (string_to_array(i_tab_name, '.'))[1]----schema name here
  AND relname = lower((string_to_array(i_tab_name, '.'))[2]) ----table name here
  AND NOT (a.attname = any ((SELECT regexp_split_to_array(i_tab_ignore_cols, E',') || '{}')::name[]))
  AND relkind = 'r'
  ORDER BY a.attname loop
    v_sql := v_sql || ',' || case when i_tab_alias is null then rd.cname else  i_tab_alias || '.' || rd.cname end;
 end loop;
 return ltrim(v_sql, ',');
END;
$$;


--
-- Name: get_similar_entities_v1(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_similar_entities_v1() RETURNS TABLE(entity_id_1 integer, entity_name_1 character varying, entity_id_2 integer, entity_name_2 character varying, score integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
v_sql text := '';
/*
1.0 tazhagan_c 24-Jul-2015 DS-1974 : Get similar entities with matching score
1.1 tazhagan_c 28-Jul-2015 DS-1974 : Run api for all then entities
*/
BEGIN

	v_sql := '
			SELECT
			   *
			FROM
			   (
						SELECT ents1. ID AS ent_id_1, 
						ents1. NAME AS ent_name_1, 
						ents2. ID AS ent_id_2, 
						ents2. NAME AS ent_name_2, 
						ROUND(GREATEST(similarity ( regexp_replace( ents1. NAME, ''[^0-9a-zA-Z]'', '''', ''g'' ),regexp_replace( ents2. NAME, ''[^0-9a-zA-Z]'', '''', ''g'' )) 
						,similarity (ents1. NAME, ents2. NAME)) * 100)::integer as score
						FROM 
								 ( SELECT ents.id,ents.name,ents.ultimate_parent_id FROM core.ents ) ents1
						INNER JOIN 
					   ( SELECT ents.id,ents.name,ents.ultimate_parent_id FROM core.ents ) ents2 
						ON ( ents1. ID <> ents2. ID AND ents1.ultimate_parent_id <> ents2.ultimate_parent_id AND ents1. ID < ents2. ID)
					) T
			WHERE score > 80
			ORDER BY score desc
		';
	
  RETURN QUERY
EXECUTE v_sql;
EXCEPTION
    WHEN OTHERS THEN
        RAISE;
END;
$$;


--
-- Name: get_similar_entities_v1(character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_similar_entities_v1(p_entity_name character varying DEFAULT NULL::character varying) RETURNS TABLE(entity_id_1 integer, entity_name_1 character varying, entity_id_2 integer, entity_name_2 character varying, score integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
v_sql text := '';
v_limit_condition text := '';
/*
1.0 tazhagan_c 24-Jul-2015 DS-1974 : Get similar entities with matching score
*/
BEGIN

IF p_entity_name IS NULL THEN v_limit_condition :='order by name limit 2000'; ELSE v_limit_condition :='where name ~*'''||p_entity_name||''''; END IF;

v_sql := '
SELECT
   *
FROM
   (
SELECT ents1. ID AS ent_id_1,
ents1. NAME AS ent_name_1,
ents2. ID AS ent_id_2,
ents2. NAME AS ent_name_2,
ROUND(GREATEST(similarity ( regexp_replace( ents1. NAME, ''[^0-9a-zA-Z]'', '''', ''g'' ),regexp_replace( ents2. NAME, ''[^0-9a-zA-Z]'', '''', ''g'' ))
,similarity (ents1. NAME, ents2. NAME)) * 100)::integer as score
FROM
 ( SELECT ents.id,ents.name,ents.ultimate_parent_id FROM core.ents '||v_limit_condition||'  ) ents1
INNER JOIN
   ( SELECT ents.id,ents.name,ents.ultimate_parent_id FROM core.ents '||v_limit_condition||' ) ents2
ON ( ents1. ID <> ents2. ID AND ents1.ultimate_parent_id <> ents2.ultimate_parent_id AND ents1. ID < ents2. ID)
) T
WHERE score > 80
ORDER BY score desc
';

  RETURN QUERY
EXECUTE v_sql;
EXCEPTION
    WHEN OTHERS THEN
        RAISE;
END;
$$;


--
-- Name: get_soft_ent_id(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_soft_ent_id(integer) RETURNS integer
    LANGUAGE sql SECURITY DEFINER
    AS $_$
/*
1.0 anarayanan 27-Apr-2017 DS-5282: New API for getting soft ent id
2.0 fli     22-June-2017 DS-5494 soft-ultimate
*/

with src as (
with recursive t as(
SELECT alias_id, clean_name, ent_id, soft_ent_id from core.alias_ent_details a1 where not is_non_human and alias_id = $1
UNION
SELECT a2.alias_id, a2.clean_name, a2.ent_id, a2.soft_ent_id from (select * from core.alias_ent_details where not is_non_human) a2, t
WHERE (a2.clean_name = t.clean_name OR a2.ent_id = t.ent_id)
)
select alias_id, min(alias_id) over () as rep_alias_id from t
),
soft_ult_id as (
select distinct rep_alias_id, max_ultimate_parent_id
from (
select rep_alias_id, ultimate_parent_id as max_ultimate_parent_id,
       max(num) over (partition by rep_alias_id) as max_num, num
from (
 select rep_alias_id, ultimate_parent_id, count(*) as num
 from core.alias_ent_details aed join src on src.alias_id = aed.alias_id
 where ultimate_parent_id is not null
 group by 1,2
) t
) t
where max_num = num
),
soft_ult_name as (
 select alias_id,
        max_ultimate_parent_id,
        case when max_ultimate_parent_id is null then (select name from core.aliases where id = src.rep_alias_id)
             else (select name from core.ents where id = max_ultimate_parent_id)
        end as soft_ultimate_parent_name,
        src.rep_alias_id
 from src left join soft_ult_id u on src.rep_alias_id = u.rep_alias_id
),
upd as (
 update core.alias_ent_details a
 set soft_ultimate_parent_id = u.max_ultimate_parent_id, soft_ent_id = rep_alias_id, soft_ultimate_parent_name = u.soft_ultimate_parent_name
 from soft_ult_name u
 where a.alias_id = u.alias_id
and (
      coalesce(a.soft_ultimate_parent_id, -1) <> coalesce(u.max_ultimate_parent_id, -1)
      or
      coalesce(a.soft_ultimate_parent_name, 'N/A') <> coalesce(u.soft_ultimate_parent_name, 'N/A')
      or
      coalesce(a.soft_ent_id, -1) <> coalesce(u.rep_alias_id, -1)
    )
 returning a.alias_id
)
select  (count(*))::int from upd;

$_$;


--
-- Name: get_update_string(character varying, character varying, text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_update_string(i_tab_name character varying, i_tab_alias character varying DEFAULT NULL::character varying, i_tab_ignore_cols text DEFAULT NULL::text) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
 v_sql text := '';
 rd record;
BEGIN
/*
  aprakash_c 10-Aug-2015 DS-2067 : Deployed in coredb for the usage in lit_campaigns.refresh_campaign_metrics
*/
 for rd in
  SELECT
    a.attname as cname,
    pg_catalog.format_type(a.atttypid, a.atttypmod) as datatype
  FROM
    pg_catalog.pg_attribute a
  JOIN
    (SELECT c.oid,c.*,n.*
     FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace) c ON a.attrelid=c.oid
  WHERE a.attnum > 0
  AND NOT a.attisdropped
  AND nspname = (string_to_array(i_tab_name, '.'))[1]----schema name here
  AND relname = lower((string_to_array(i_tab_name, '.'))[2]) ----table name here
  AND a.attname not in ('created_at', 'updated_at', 'created_by', 'updated_by', 'stg_id', 'to_be_indexed', 'is_deleted')
  AND NOT (a.attname = any ((SELECT regexp_split_to_array(i_tab_ignore_cols, E',') || '{}')::name[]))
  AND relkind = 'r'
  ORDER BY a.attname loop
   if lower(rd.cname) <> 'stg_id' and lower(rd.cname) <> 'batch_number' then
    v_sql := v_sql || ','||chr(10) || case when i_tab_alias is null then rd.cname ||' = ' || rd.cname else  rd.cname || ' = ' || i_tab_alias || '.' || rd.cname end;
   end if;
 end loop;
 return ltrim(v_sql, ','||chr(10));
END;
$$;


--
-- Name: get_update_string(character varying, character varying, character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION get_update_string(i_tab_name character varying, i_tab_alias character varying, i_tab_ignore_cols character varying DEFAULT NULL::character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
 v_sql text := '';
 rd record;
BEGIN

 for rd in
  SELECT
    a.attname as cname,
    pg_catalog.format_type(a.atttypid, a.atttypmod) as datatype
  FROM
    pg_catalog.pg_attribute a
  JOIN
    (SELECT c.oid,c.*,n.*
     FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace) c ON a.attrelid=c.oid
  WHERE a.attnum > 0
  AND NOT a.attisdropped
  AND NOT (a.attname = any ((SELECT regexp_split_to_array(i_tab_ignore_cols, E',') || '{}')::name[]))
  AND nspname = (string_to_array(i_tab_name, '.'))[1]----schema name here
  AND relname = lower((string_to_array(i_tab_name, '.'))[2]) ----table name here
  AND relkind = 'r'
  ORDER BY a.attname loop

  if rd.cname <> 'id' then
     v_sql := v_sql || ', ' || rd.cname || ' = ' || i_tab_alias || '.' || rd.cname || '
    ';
  end if;
 end loop;
 return ltrim(v_sql, ',');
END;
$$;


--
-- Name: handle_orphan_documents(integer[], integer, integer, date, text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION handle_orphan_documents(p_lit_document_ids integer[], p_lit_id integer, p_entry_number integer, p_date_filed date, p_original_docket_text text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN

  INSERT INTO core.lit_document_orphans
  (lit_id, case_key, lit_document_id, entry_date_filed, entry_number, original_docket_text)
  SELECT p_lit_id,
         (SELECT case_key
          FROM core.lits
          WHERE id = p_lit_id) as case_key,
         t.lit_document_id,
         p_date_filed,
         p_entry_number,
         p_original_docket_text
  FROM (
         SELECT distinct lit_document_id
         FROM (
          SELECT UNNEST(p_lit_document_ids) as lit_document_id
         ) t
         WHERE lit_document_id is not NULL
       ) t
  WHERE not EXISTS (
         SELECT  1
         FROM core.docket_entry_documents_map m
         WHERE m.lit_document_id = t.lit_document_id
       ) AND
        not EXISTS (
         SELECT 1
         FROM core.lit_document_orphans o
         WHERE o.lit_document_id = t.lit_document_id
       );

  RETURN 1;
END;
$$;


--
-- Name: insert_docket_entry(integer, date, date, integer, integer, text, text, boolean, integer[], integer, character varying, text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION insert_docket_entry(p_lit_id integer, p_date_filed date, p_date_entered date, p_entry_number integer, p_row_number integer, p_docket_text text, p_original_docket_text text, p_is_mixed_action boolean, p_new_document_ids integer[], p_new_main_document_id integer, p_category character varying, p_event text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_docket_entry_id INTEGER := NULL;
BEGIN

 ---make sure no same entry_number exists
 SELECT id
 INTO v_docket_entry_id
 FROM core.docket_entries
 WHERE entry_number = p_entry_number AND
       ---date_filed = p_date_filed AND
       ---date_entered = p_date_entered AND
       lit_id = p_lit_id;

 ---No changes, then return id
 ---Also make sure not to update data to create duplicates
 IF v_docket_entry_id is not NULL THEN
     ---RAISE EXCEPTION 'Another  docket_entry record (id % entry number % lit %) has the same information. No duplicates allowed.', v_docket_entry_id, p_entry_number, p_lit_id;
     ----RETURN p_Lit_judges_map_id;
     NULL;
 END IF;

 ---is_mixed_action is default false, but is true if we can not tell if a update/delete/insert is a true one.
 INSERT INTO core.docket_entries
 (lit_id, date_filed, date_entered, entry_number, row_number, docket_text, original_docket_text, is_mixed_action, category, event)
 VALUES
 (p_lit_id, p_date_filed, p_date_entered, p_entry_number, p_row_number, p_docket_text, p_original_docket_text, p_is_mixed_action, p_category, p_event)
 RETURNING id into v_docket_entry_id;

 ---main document
 IF p_new_main_document_id is not NULL THEN
    INSERT INTO core.docket_entry_documents_map
    (docket_entry_id, lit_document_id, is_main)
    VALUES
    (v_docket_entry_id, p_new_main_document_id, true);
 END IF;

 ---ecf links mapping with docket_entry
 INSERT into core.docket_entry_documents_map
 (docket_entry_id, lit_document_id, is_main)
 SELECT distinct v_docket_entry_id as docket_entry_id, lit_document_id, false::boolean as is_main
 FROM (
         SELECT UNNEST(p_new_document_ids) as lit_document_id
 ) t
 WHERE lit_document_id is NOT NULL;

 RETURN v_docket_entry_id;
END;
$$;


--
-- Name: insert_ent_advanced_relationship_types(character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION insert_ent_advanced_relationship_types(p_name character varying DEFAULT NULL::character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
v_ent_advanced_relationship_types_id INTEGER ;
BEGIN
/*
1.0 2015-02-06 user DS-809: New Function Created by core.generate_dml_func
*/
INSERT INTO core.ent_advanced_relationship_types (ID, NAME)
VALUES
(DEFAULT, p_name) RETURNING ID INTO v_ent_advanced_relationship_types_id ;
RETURN v_ent_advanced_relationship_types_id ;

EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE '% %',SQLSTATE, sqlerrm ;
RETURN - 1 ;
END ;
$$;


--
-- Name: insert_ent_advanced_relationships_table(integer, integer, integer, date, date, text, character varying, character varying, text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION insert_ent_advanced_relationships_table(p_ent_id integer, p_related_ent_id integer, p_ent_advanced_relationship_type_id integer, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date, p_description text DEFAULT NULL::text, p_updated_by character varying DEFAULT "current_user"(), p_created_by character varying DEFAULT "current_user"(), p_title text DEFAULT NULL::text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_ent_advanced_relationships_id  integer;
BEGIN
  /*
  1.0 2015-08-26 user DS-809: New Function Created by core.generate_dml_func_v2
  */
INSERT INTO core.ent_advanced_relationships
(ent_id,related_ent_id,start_date,end_date,ent_advanced_relationship_type_id,description,updated_by,created_by,title)
  VALUES
(p_ent_id,p_related_ent_id,p_start_date,p_end_date,p_ent_advanced_relationship_type_id,p_description,p_updated_by,p_created_by,p_title)
 returning id into v_ent_advanced_relationships_id;

RETURN v_ent_advanced_relationships_id;

EXCEPTION
  WHEN OTHERS THEN
    RAISE NOTICE '% %', sqlstate, sqlerrm;
RETURN -1;
END;
$$;


--
-- Name: insert_ent_relationships_table(integer, integer, integer, text, date, date, character varying, character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION insert_ent_relationships_table(p_ent_id integer, p_related_ent_id integer, p_ent_relationship_type_id integer, p_description text, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date, p_created_by character varying DEFAULT "current_user"(), p_updated_by character varying DEFAULT "current_user"()) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_ent_relationships_id  integer;
BEGIN
  /*
  1.0 2015-08-26 user DS-809: New Function Created by core.generate_dml_func_v2
  */
INSERT INTO core.ent_relationships
(ent_id,related_ent_id,ent_relationship_type_id,description,start_date,end_date,created_by,updated_by)
  VALUES
(p_ent_id,p_related_ent_id,p_ent_relationship_type_id,p_description,p_start_date,p_end_date,p_created_by,p_updated_by)
 returning id into v_ent_relationships_id;

RETURN v_ent_relationships_id;

EXCEPTION
  WHEN OTHERS THEN
    RAISE NOTICE '% %', sqlstate, sqlerrm;
RETURN -1;
END;
$$;


--
-- Name: insert_ent_subtypes_map(integer, integer, date, date); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION insert_ent_subtypes_map(p_ent_id integer, p_ent_subtype_id integer, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
v_ent_subtypes_map_id INTEGER ;
BEGIN
/*
1.0 aprakash_c 13-FEB-2015 DS-809: New Function Created
*/
INSERT INTO core.ent_subtypes_map (
ID,
ent_id,
ent_subtype_id,
start_date,
end_date
)
VALUES
(
DEFAULT,
p_ent_id,
p_ent_subtype_id,
p_start_date,
p_end_date
) RETURNING ID INTO v_ent_subtypes_map_id ;
RETURN v_ent_subtypes_map_id ;

EXCEPTION WHEN OTHERS THEN
RAISE NOTICE '% %',SQLSTATE, sqlerrm ;
RETURN - 1 ;
END ;
$$;


--
-- Name: insert_ent_types(character varying, boolean); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION insert_ent_types(p_name character varying, p_is_default boolean DEFAULT NULL::boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
v_ent_types_id INTEGER ;
BEGIN
/*
1.0 2015-02-06 user DS-809: New Function Created by core.generate_dml_func
*/
INSERT INTO core.ent_types (
ID,
name,
is_default
)
VALUES
(
DEFAULT,
p_name,
p_is_default
) RETURNING ID INTO v_ent_types_id ;
RETURN v_ent_types_id ;

EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE '% %',SQLSTATE, sqlerrm ;
RETURN - 1 ;
END ;
$$;


--
-- Name: insert_lit_relationships_tab(integer, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION insert_lit_relationships_tab(p_from_lit_id integer DEFAULT NULL::integer, p_to_lit_id integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
  v_lit_relationships_id  integer;
  BEGIN
  /*
  1.0 2015-08-26 user DS-809: New Function Created by core.generate_dml_func_v2
  */

  IF p_from_lit_id IS NOT NULL AND p_to_lit_id IS NOT NULL AND p_from_lit_id = p_to_lit_id THEN
    RAISE EXCEPTION 'Can not create a self-referential relationship for %', p_from_lit_id;
    RETURN -1;

  END IF;

        ---Give a default lit_relationship_type_id 1. Anyway there is a logic calculation
  INSERT INTO core.lit_relationships (id ,
from_lit_id,
to_lit_id,
lit_relationship_type_id)
  VALUES
  ( default ,
p_from_lit_id,
p_to_lit_id, 1
) returning id into v_lit_relationships_id ;

  RETURN v_lit_relationships_id ;
  EXCEPTION
  WHEN OTHERS THEN
  RAISE NOTICE '% %', sqlstate, sqlerrm;
  RETURN -1;
  END;
  $$;


--
-- Name: insert_timestamps(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION insert_timestamps() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.created_at := current_timestamp;
    NEW.updated_at := current_timestamp;
    RETURN NEW;
END;
$$;


--
-- Name: insert_users(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION insert_users() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
IF (NEW.created_by IS NULL) THEN
NEW.created_by := current_user;
END IF;
NEW.updated_by = NEW.created_by;
    RETURN NEW;
END;
$$;


--
-- Name: is_human(text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION is_human(as_seen text) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $$

BEGIN
    RAISE NOTICE 'This function has been deprecated, please use code_nerd.is_likely_human';
    RETURN code_nerd.is_likely_human(as_seen::varchar);

END
$$;


--
-- Name: lit_annotation_is_dj_update_lit_parties_tr_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION lit_annotation_is_dj_update_lit_parties_tr_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
 DECLARE
 BEGIN
     IF (TG_OP = 'UPDATE') THEN
         UPDATE core.lit_parties lp SET updated_at = timezone('UTC'::text, clock_timestamp()),
         dj_party_normalized_type =
         ( CASE WHEN lpt.lit_party_normalized_type IN ('defendant', 'plaintiff') THEN ( CASE WHEN la.is_dj
         THEN ( CASE WHEN lpt.lit_party_normalized_type = 'defendant' THEN 'plaintiff' ELSE 'defendant' END )
         ELSE lpt.lit_party_normalized_type END ) ELSE NULL END )
         FROM core.lit_annotations la, core.lit_party_types lpt
         WHERE la.lit_id = lp.lit_id
         AND lpt. ID = lp.lit_party_type_id
         AND la.id = old.id;
         RETURN NEW;
     ELSIF (TG_OP = 'DELETE') THEN
         UPDATE core.lit_parties lp SET updated_at = timezone('UTC'::text, clock_timestamp()),
         dj_party_normalized_type =
         ( CASE WHEN lpt.lit_party_normalized_type IN ('defendant', 'plaintiff') THEN lpt.lit_party_normalized_type
         ELSE NULL END )
         FROM core.lit_party_types lpt
         WHERE lp.lit_id = old.lit_id
         AND lpt. ID = lp.lit_party_type_id;
         RETURN OLD;
     ELSIF (TG_OP = 'INSERT') THEN
     	 UPDATE core.lit_parties lp SET updated_at = timezone('UTC'::text, clock_timestamp()),
         dj_party_normalized_type =
         ( CASE WHEN lpt.lit_party_normalized_type IN ('defendant', 'plaintiff') THEN ( CASE WHEN la.is_dj
         THEN ( CASE WHEN lpt.lit_party_normalized_type = 'defendant' THEN 'plaintiff' ELSE 'defendant' END )
         ELSE lpt.lit_party_normalized_type END ) ELSE NULL END )
         FROM core.lit_annotations la, core.lit_party_types lpt
         WHERE la.lit_id = lp.lit_id
         AND lpt. ID = lp.lit_party_type_id
         AND la.id = new.id;
         RETURN NEW;
     ELSE
         RAISE EXCEPTION '[lit_annotation_is_dj_update_lit_parties_tr_func] - Other action occurred: %, at %',TG_OP,now();
         RETURN NULL;
     END IF;

 EXCEPTION
     WHEN data_exception THEN
         RAISE EXCEPTION '[lit_annotation_is_dj_update_lit_parties_tr_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
         RETURN NULL;
     WHEN unique_violation THEN
         RAISE EXCEPTION '[lit_annotation_is_dj_update_lit_parties_tr_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
         RETURN NULL;
     WHEN OTHERS THEN
         RAISE EXCEPTION '[lit_annotation_is_dj_update_lit_parties_tr_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
         RETURN NULL;
 END;
 $$;


--
-- Name: lit_annotations_before_tr(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION lit_annotations_before_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

-- tazhagan_c DS-1885 29-Jun-2015 : Update is_npe_suit as per changes in lit_curated_cause_type_id and lit_type_id
-- fli   DS-3726  04-May-2016: remove is_dj logic

    IF TG_OP = 'UPDATE' THEN
        IF session_user = 'dma_app' THEN
            -- If the user is coming from the DMA don't let them update the lit_stage_id
            NEW.lit_stage_id := OLD.lit_stage_id;
        END IF;

IF COALESCE(NEW.lit_curated_cause_type_id,-1) != COALESCE(OLD.lit_curated_cause_type_id,-1) OR COALESCE(NEW.lit_type_id,-1) != COALESCE(OLD.lit_type_id,-1)
THEN
IF ((select name from core.lit_curated_cause_types where id=new.lit_curated_cause_type_id) in ('Infringement','Declaratory Judgment','Willful Patent Infringement')) AND ((select name from core.lit_types where id=new.lit_type_id) in ('NPE','UNI','INV','NCE', 'Patent Licensing Company'))
THEN
NEW.is_npe_suit := TRUE;
ELSE
NEW.is_npe_suit := FALSE;
END IF;
END IF;

        RETURN NEW;

    ELSIF (TG_OP = 'DELETE') THEN
        RETURN OLD;

    ELSIF (TG_OP = 'INSERT') THEN

IF ((select name from core.lit_curated_cause_types where id=new.lit_curated_cause_type_id) in ('Infringement','Declaratory Judgment','Willful Patent Infringement')) AND ((select name from core.lit_types where id=new.lit_type_id) in ('NPE','UNI','INV','NCE', 'Patent Licensing Company'))
THEN
NEW.is_npe_suit := TRUE;
ELSE
NEW.is_npe_suit := FALSE;
END IF;

        RETURN NEW;

    ELSE
        RAISE EXCEPTION '[core.lit_annotations_before_tr] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core.lit_annotations_before_tr] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core.lit_annotations_before_tr] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core.lit_annotations_before_tr] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: lit_annotations_portal_display_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION lit_annotations_portal_display_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
 DECLARE
 BEGIN
    IF (TG_OP = 'INSERT') THEN

IF new.portal_display_override IS NULL THEN
new.display_on_portal := (new.is_abandon = false AND new.lit_curated_cause_type_id IN (1,7,8,10));
ELSE
new.display_on_portal:=new.portal_display_override;
END IF;
RETURN NEW;

ELSIF (TG_OP = 'UPDATE') THEN

IF new.portal_display_override IS NULL THEN
new.display_on_portal := (new.is_abandon = false AND new.lit_curated_cause_type_id IN (1,7,8,10));
ELSE
new.display_on_portal:=new.portal_display_override;
END IF;
RETURN NEW;

    ELSE

RAISE EXCEPTION '[lit_annotations_portal_display_func] - Other action occurred: %, at %',TG_OP,now();
RETURN NULL;

    END IF;

 EXCEPTION
     WHEN data_exception THEN
         RAISE EXCEPTION '[lit_annotations_portal_display_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
         RETURN NULL;
     WHEN unique_violation THEN
         RAISE EXCEPTION '[lit_annotations_portal_display_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
         RETURN NULL;
     WHEN OTHERS THEN
         RAISE EXCEPTION '[lit_annotations_portal_display_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
         RETURN NULL;
 END;
 $$;


--
-- Name: lit_parties_trig_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION lit_parties_trig_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    IF (TG_OP = 'UPDATE') THEN
        IF coalesce(old.lit_party_type_id, -1) != coalesce(new.lit_party_type_id, -1) THEN
         SELECT
              ( CASE WHEN lpt.lit_party_normalized_type IN ('defendant', 'plaintiff')
                     THEN ( CASE WHEN la.is_dj THEN ( CASE WHEN lpt.lit_party_normalized_type = 'defendant' THEN 'plaintiff' ELSE 'defendant' END ) ELSE lpt.lit_party_normalized_type END ) ELSE NULL END )
         INTO NEW.dj_party_normalized_type
         FROM core.lit_annotations la, core.lit_party_types lpt
         WHERE la.lit_id = NEW.lit_id
         AND lpt.ID = NEW.lit_party_type_id;
        END IF;
        RETURN NEW;
    ELSE
        RAISE EXCEPTION '[core..lit_parties_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core..lit_parties_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core..lit_parties_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core..lit_parties_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: lit_party_lit_family_path(integer, integer, boolean); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION lit_party_lit_family_path(p_lit_id integer, p_ent_id integer, p_include_subs boolean DEFAULT false) RETURNS TABLE(r_lit_relationship_id integer, r_from_lit_id integer, r_to_lit_id integer, r_lit_family_id integer, r_lit_relationship_type_id integer, r_path_step integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_check_ent     TEXT;
    v_start_lits    INTEGER[];
    v_path_length   INTEGER;
    v_family_id     INTEGER;
    v_ent_id_list   INTEGER[];

BEGIN
    IF p_include_subs THEN
        v_ent_id_list := core.get_entity_family(p_ent_id);

        /*
        SELECT array_agg(id)
        INTO v_ent_id_list
        FROM core.ents
        WHERE ents.ultimate_parent_id = p_ent_id;

        IF v_ent_id_list IS NULL THEN
            v_ent_id_list := ARRAY[p_ent_id];
        END IF;
        */
    ELSE
        v_ent_id_list := ARRAY[p_ent_id];
    END IF;

    SELECT array_to_string(array_agg(al.ent_id), ',')
    INTO v_check_ent
    FROM core.lit_parties   lp
    INNER JOIN core.aliases al  ON lp.alias_id = al."id"
    WHERE lp.lit_id = p_lit_id
        AND al.ent_id = ANY (v_ent_id_list);

    IF v_check_ent IS NULL OR LENGTH(v_check_ent) = 0 THEN
        RAISE EXCEPTION '[core.lit_party_lit_family_path] The litigation with lit_id = % does not have a lit_party connected to ent_id = %', p_lit_id, p_ent_id;
    END IF;

    --Get to the first lit(s) of lit_relationships path
    WITH RECURSIVE my_tree1(from_lit_id, to_lit_id) AS
        (SELECT lit_relationships.from_lit_id, lit_relationships.to_lit_id
         FROM core.lit_relationships
         WHERE lit_relationships.to_lit_id = p_lit_id
             AND lit_relationships.from_lit_id IN (SELECT lits.id
                                                   FROM core.lits
                                                   INNER JOIN core.lit_parties lp ON lits.id = lp.lit_id
                                                   INNER JOIN core.aliases     al ON lp.alias_id = al.id
                                                   WHERE al.ent_id = ANY (v_ent_id_list))
       UNION
         SELECT lr.from_lit_id, lr.to_lit_id
         FROM core.lit_relationships  lr
         INNER JOIN my_tree1                      mt1 ON mt1.from_lit_id = lr.to_lit_id
         WHERE lr.from_lit_id IN (SELECT lits.id
                                  FROM core.lits
                                  INNER JOIN core.lit_parties lp ON lits.id = lp.lit_id
                                  INNER JOIN core.aliases     al ON lp.alias_id = al.id
                                  WHERE al.ent_id = ANY (v_ent_id_list))
        )
        SELECT array_agg(mt1.from_lit_id)
        INTO v_start_lits
        FROM my_tree1 mt1
        WHERE mt1.from_lit_id NOT IN (SELECT lr2.to_lit_id FROM core.lit_relationships lr2);

    --If there are no litgations before it, set our starting set to the one passed in
    IF v_start_lits IS NULL THEN
        v_start_lits := ARRAY[p_lit_id];
    END IF;

    --climb back up the tree and return the set
    SELECT count(*)
    INTO v_path_length
    FROM core.trace_lit_family_forward(v_start_lits, v_ent_id_list);

    IF v_path_length = 0 OR v_path_length IS NULL THEN
        --If there are no relationships with that lit and ent combo, just pass back the one lit
        v_family_id := core.find_or_create_lit_family(p_lit_id);

        RETURN QUERY
            SELECT 0 AS r_lit_relationship_id,
                   p_lit_id AS r_from_lit_id,
                   p_lit_id AS r_to_lit_id,
                   v_family_id AS r_lit_family_id,
                   2 AS r_lit_relationship_type_id,
                   1 AS r_path_step;
    ELSE
        RETURN QUERY
            SELECT *
            FROM core.trace_lit_family_forward(v_start_lits, v_ent_id_list)
            ORDER BY r_path_step;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core.lit_party_lit_family_path] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core.lit_party_lit_family_path] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
    WHEN OTHERS THEN
        RAISE;

END;
$$;


--
-- Name: lit_short_title(character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION lit_short_title(p_title character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_title                 VARCHAR := p_title;
	v_title_parts 			VARCHAR[];
	v_first_half			VARCHAR;
	v_second_half			VARCHAR;
	v_first_half_formatted	VARCHAR;
	v_second_half_formatted	VARCHAR;
	v_cap_word				VARCHAR;
	v_regexp				VARCHAR;
	v_cap_char_count		FLOAT;
	v_char_count			FLOAT;
	v_et_al_regexp			VARCHAR := '[^[:alnum:]]et[^[:alnum:]]{0,3}al[^[:alnum:]]*$';

BEGIN
--#Deal with special characters
    IF v_title ~* '&#' THEN
        v_title := regexp_replace(v_title, '&#035;', '#', 'g');
        v_title := regexp_replace(v_title, '&#037;', '%', 'g');
        v_title := regexp_replace(v_title, '&#039;', '#single#', 'g');
    END IF;

    v_title := regexp_replace(v_title, '&quot;', '"', 'g');
    v_title := regexp_replace(v_title,'(<[^<]*>|^[\*\t\n ]*|&#[0-9]*;)','','g');

    --We don't want single quotes pulled out while we manipulate the strings so we replace them momentarily
    v_title := regexp_replace(v_title, '''', '#single#', 'g');

--#Collect parts of title
	--Handle some special cases for splitting 
	IF v_title ~* ' v\. ' AND v_title ~* '[^[:alnum:]]v([ ,$])' THEN 
		v_title_parts = regexp_split_to_array(v_title,' v\. ');
	ELSE 
		v_title_parts = regexp_split_to_array(v_title,'[^([:alnum:]|(N\.?))][vV][sS]?\.?[^[:alnum:]]');
	END IF;

	--Must have two and only two parts to continue. 
	IF array_length(v_title_parts,1) != 2 THEN
		RAISE NOTICE '"%" failed to split into two parts. Splits to % part(s).', p_title, array_length(v_title_parts,1); 
		RETURN v_title;
	END IF;

	v_first_half = v_title_parts[1];
	v_second_half = v_title_parts[2];


--#First pass at making things pretty
	v_first_half_formatted = code_nerd.format_entity_name(code_nerd.core_name_for(v_first_half));
	v_second_half_formatted = code_nerd.format_entity_name(code_nerd.core_name_for(v_second_half));

--#Edge cases that should be handled before case correction
    --Turn .com back to what it should have been
	IF v_first_half_formatted ~* '([a-z]+) Com([^[:alnum:]]|$)' AND v_first_half ~* '([a-z]+)\.com([^[:alnum:]]|$)' THEN
		v_first_half_formatted = regexp_replace(v_first_half_formatted,'([a-z]+) Com([^[:alnum:]]|$)','\1.com\2');
	END IF;

	IF v_second_half_formatted ~* '([a-z]+) Com([^[:alnum:]]|$)' AND v_second_half ~* '([a-z]+)\.com([^[:alnum:]]|$)' THEN
		v_second_half_formatted = regexp_replace(v_second_half_formatted,'([a-z]+) Com([^[:alnum:]]|$)','\1.com\2');
	END IF;

    --put back the single quotes
    IF v_first_half_formatted ~* '#single#' THEN
        v_first_half_formatted := regexp_replace(v_first_half_formatted, '#single#', '''', 'gi');
    END IF;

    IF v_second_half_formatted ~* '#single#' THEN
        v_second_half_formatted := regexp_replace(v_second_half_formatted, '#single#', '''', 'gi');
    END IF;

    --Make sure it treats 's as part of the word and doesn't capitalize it like an initial or short word
    IF v_first_half_formatted ~ '''S ' THEN
        v_first_half_formatted := regexp_replace(v_first_half_formatted, '''S ', '''s ', 'g');
    END IF;

    IF v_second_half_formatted ~* '''S ' THEN
        v_second_half_formatted := regexp_replace(v_second_half_formatted, '''S ', '''s ', 'g');
    END IF;

    -- strip off the ending non-alpha numeric charaters left from names like Schwab & Co that had Co stripped off
    IF v_first_half_formatted ~ '[&/,\\] *$' THEN
        v_first_half_formatted := regexp_replace(v_first_half_formatted, '[&/,\\] *$', '');
    END IF;

    IF v_second_half_formatted ~* '[&/,\\] *$' THEN
        v_second_half_formatted := regexp_replace(v_second_half_formatted, '[&/,\\] *$', '');
    END IF;

--#This block figures out if the title is mostly caps, and if not re-places remaining words with orginal case. This might be able to be abstracted to be part of code_nerd.format_entity_name instead
	--Count all caps
	SELECT COALESCE(count(*),0)::FLOAT  
	INTO v_cap_char_count
	FROM regexp_matches(p_title,'[A-Z]','g')
	;
	--Count all letters
	SELECT COALESCE(count(*),1)::FLOAT 
	INTO v_char_count
	FROM regexp_matches(p_title,'[a-zA-Z]','g')
	;
	--If less than 75% of letters are caps, start replacing
	IF (v_cap_char_count/v_char_count) < 0.75 THEN

		FOR v_cap_word IN SELECT tt[1] FROM regexp_matches(v_first_half,'([a-zA-Z]+)','g') as tt
        LOOP
			--RAISE NOTICE '%',v_cap_word;
			v_regexp = '(^|[^[:alnum:]])' || regexp_replace(v_cap_word, '(\[|\]|\\|\^|\$|\.|\||\?|\*|\+|\(|\))', '\\\1', 'g') || '([^[:alnum:]]|$)';
			v_first_half_formatted = regexp_replace(v_first_half_formatted, v_regexp, ('\1' || v_cap_word || '\2'),'i');
			--RAISE NOTICE '%',v_first_half_formatted;
		END LOOP;

		FOR v_cap_word IN SELECT tt[1] FROM regexp_matches(v_second_half,'([a-zA-Z]+)','g') as tt
        LOOP
			--RAISE NOTICE '%',v_cap_word;
			v_regexp = '(^|[^[:alnum:]])' || regexp_replace(v_cap_word, '(\[|\]|\\|\^|\$|\.|\||\?|\*|\+|\(|\))', '\\\1', 'g') || '([^[:alnum:]]|$)';
			v_second_half_formatted = regexp_replace(v_second_half_formatted, v_regexp, ('\1' || v_cap_word || '\2'),'i');
		END LOOP;

	END IF;

--#Now lets rebuild the title!
	--Tack on et al to the appropriate part if original existed and has been stipped above
	IF v_first_half ~* v_et_al_regexp AND v_first_half_formatted !~* v_et_al_regexp THEN
		v_first_half_formatted 	= v_first_half_formatted || ' et al';
	END IF;

	IF v_second_half ~* v_et_al_regexp AND v_second_half_formatted !~* v_et_al_regexp THEN
		v_second_half_formatted = v_second_half_formatted || ' et al';
	END IF;
	
	RETURN regexp_replace(v_first_half_formatted || ' v. ' || v_second_half_formatted, '  +', ' ', 'g');   --This also turns multiple spaces to single spaces

END
$_$;


--
-- Name: lits_orig_filed_date_tr(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION lits_orig_filed_date_tr() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN

/*

    2.0  - 31 July 2017 , ateja_c , DS-5681 Correct when there is error in loading original_filed_date from pds -> core.lits during insert.

*/
    IF (TG_OP = 'UPDATE') THEN

        IF (OLD.original_filed_date < '1900-01-01') THEN
             NEW.original_filed_date = NEW.filed_date;
        END IF;

        RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        -- just send back the same for delete
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        -- For new litigation start with the assumption that orig filed date is lit filed date,
        -- If it's a transfer is will get updated when the lit_relationship gets added.
        IF (NEW.original_filed_date IS NULL) THEN
		    NEW.original_filed_date = NEW.filed_date;
        END IF;

        RETURN NEW;
    ELSE
        RAISE WARNING '[core.sync_ultimate_parent_tr] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE WARNING '[core.lits_orig_filed_date_tr] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE WARNING '[core.lits_orig_filed_date_tr] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE WARNING '[core.lits_orig_filed_date_tr] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: lower_strip(character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION lower_strip(str character varying) RETURNS character varying
    LANGUAGE plpgsql STRICT
    AS $$

BEGIN
    RAISE NOTICE 'This function has been deprecated, please use code_nerd.lower_strip';
    RETURN code_nerd.lower_strip(str);

END
$$;


--
-- Name: p(text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION p(message text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $$
BEGIN
   RAISE NOTICE '%', message;
END;
$$;


--
-- Name: patent_aliases_map_alias_role_trig_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION patent_aliases_map_alias_role_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
    IF (TG_OP = 'UPDATE') THEN
      IF (OLD.pats_aliases_relationship_type_id = 7 OR NEW.pats_aliases_relationship_type_id = 7) THEN
       IF (COALESCE(OLD.alias_id, -1) <> COALESCE(NEW.alias_id, -1)) OR (OLD.pats_aliases_relationship_type_id <> NEW.pats_aliases_relationship_type_id) THEN
         IF OLD.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', OLD.alias_id, 'D', 'patent_inventor');
         END IF;
         IF NEW.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', NEW.alias_id, 'I', 'patent_inventor');
         END IF;
       END IF;
      END IF;
      IF (OLD.pats_aliases_relationship_type_id = 4 OR NEW.pats_aliases_relationship_type_id = 4) THEN
       IF (COALESCE(OLD.alias_id, -1) <> COALESCE(NEW.alias_id, -1)) OR (OLD.pats_aliases_relationship_type_id <> NEW.pats_aliases_relationship_type_id) THEN
         IF OLD.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', OLD.alias_id, 'D', 'patent_party');
         END IF;
         IF NEW.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', NEW.alias_id, 'I', 'patent_party');
         END IF;
       END IF;
      END IF;
      IF (OLD.pats_aliases_relationship_type_id = 5 OR NEW.pats_aliases_relationship_type_id = 5) THEN
       IF (COALESCE(OLD.alias_id, -1) <> COALESCE(NEW.alias_id, -1)) OR (OLD.pats_aliases_relationship_type_id <> NEW.pats_aliases_relationship_type_id) THEN
         IF OLD.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', OLD.alias_id, 'D', 'patent_primary_examiner');
         END IF;
         IF NEW.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', NEW.alias_id, 'I', 'patent_primary_examiner');
         END IF;
       END IF;
      END IF;
      IF (OLD.pats_aliases_relationship_type_id = 6 OR NEW.pats_aliases_relationship_type_id = 6) THEN
       IF (COALESCE(OLD.alias_id, -1) <> COALESCE(NEW.alias_id, -1)) OR (OLD.pats_aliases_relationship_type_id <> NEW.pats_aliases_relationship_type_id) THEN
         IF OLD.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', OLD.alias_id, 'D', 'patent_assistant_examiner');
         END IF;
         IF NEW.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', NEW.alias_id, 'I', 'patent_assistant_examiner');
         END IF;
       END IF;
      END IF;
      RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        IF (OLD.pats_aliases_relationship_type_id = 7) THEN
         PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', OLD.alias_id, 'D', 'patent_inventor');
        END IF;
        IF (OLD.pats_aliases_relationship_type_id = 4) THEN
         PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', OLD.alias_id, 'D', 'patent_party');
        END IF;
        IF (OLD.pats_aliases_relationship_type_id = 5) THEN
         PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', OLD.alias_id, 'D', 'patent_primary_examiner');
        END IF;
        IF (OLD.pats_aliases_relationship_type_id = 6) THEN
         PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', OLD.alias_id, 'D', 'patent_assistant_examiner');
        END IF;
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        IF (NEW.pats_aliases_relationship_type_id = 7) THEN
         PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', NEW.alias_id, 'I', 'patent_inventor');
        END IF;
        IF (NEW.pats_aliases_relationship_type_id = 4) THEN
         PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', NEW.alias_id, 'I', 'patent_party');
        END IF;
        IF (NEW.pats_aliases_relationship_type_id = 5) THEN
         PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', NEW.alias_id, 'I', 'patent_primary_examiner');
        END IF;
        IF (NEW.pats_aliases_relationship_type_id = 6) THEN
         PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', NEW.alias_id, 'I', 'patent_assistant_examiner');
        END IF;
        RETURN NEW;
    ELSE
        RAISE EXCEPTION '[core..patent_aliases_map_alias_role_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core..patent_aliases_map_alias_role_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core..patent_aliases_map_alias_role_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core..patent_aliases_map_alias_role_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: patent_assignee_alias_role_trig_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION patent_assignee_alias_role_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
    IF (TG_OP = 'UPDATE') THEN
      IF (1 = 1) THEN
       IF (COALESCE(OLD.alias_id, -1) <> COALESCE(NEW.alias_id, -1)) OR (1 <> 1) THEN
         IF OLD.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.assignees_aliases_map', 'alias_id', OLD.alias_id, 'D', 'patent_assignee');
         END IF;
         IF NEW.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.assignees_aliases_map', 'alias_id', NEW.alias_id, 'I', 'patent_assignee');
         END IF;
       END IF;
      END IF;
      RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('core.assignees_aliases_map', 'alias_id', OLD.alias_id, 'D', 'patent_assignee');
        END IF;
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('core.assignees_aliases_map', 'alias_id', NEW.alias_id, 'I', 'patent_assignee');
        END IF;
        RETURN NEW;
    ELSE
        RAISE EXCEPTION '[core..patent_assignee_alias_role_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core..patent_assignee_alias_role_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core..patent_assignee_alias_role_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core..patent_assignee_alias_role_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: patent_assignor_alias_role_trig_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION patent_assignor_alias_role_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
    IF (TG_OP = 'UPDATE') THEN
      IF (1 = 1) THEN
       IF (COALESCE(OLD.alias_id, -1) <> COALESCE(NEW.alias_id, -1)) OR (1 <> 1) THEN
         IF OLD.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.assignors_aliases_map', 'alias_id', OLD.alias_id, 'D', 'patent_assignor');
         END IF;
         IF NEW.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.assignors_aliases_map', 'alias_id', NEW.alias_id, 'I', 'patent_assignor');
         END IF;
       END IF;
      END IF;
      RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('core.assignors_aliases_map', 'alias_id', OLD.alias_id, 'D', 'patent_assignor');
        END IF;
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('core.assignors_aliases_map', 'alias_id', NEW.alias_id, 'I', 'patent_assignor');
        END IF;
        RETURN NEW;
    ELSE
        RAISE EXCEPTION '[core..patent_assignor_alias_role_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core..patent_assignor_alias_role_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core..patent_assignor_alias_role_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core..patent_assignor_alias_role_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: patent_assistant_examiner_alias_role_trig_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION patent_assistant_examiner_alias_role_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
    IF (TG_OP = 'UPDATE') THEN
      IF (OLD.pats_aliases_relationship_type_id = 6 OR NEW.pats_aliases_relationship_type_id = 6) THEN
       IF (COALESCE(OLD.alias_id, -1) <> COALESCE(NEW.alias_id, -1)) OR (OLD.pats_aliases_relationship_type_id <> NEW.pats_aliases_relationship_type_id) THEN
         IF OLD.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', OLD.alias_id, 'D', 'patent_assistant_examiner');
         END IF;
         IF NEW.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', NEW.alias_id, 'I', 'patent_assistant_examiner');
         END IF;
       END IF;
      END IF;
      RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        IF (OLD.pats_aliases_relationship_type_id = 6) THEN
         PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', OLD.alias_id, 'D', 'patent_assistant_examiner');
        END IF;
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        IF (NEW.pats_aliases_relationship_type_id = 6) THEN
         PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', NEW.alias_id, 'I', 'patent_assistant_examiner');
        END IF;
        RETURN NEW;
    ELSE
        RAISE EXCEPTION '[core..patent_assistant_examiner_alias_role_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core..patent_assistant_examiner_alias_role_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core..patent_assistant_examiner_alias_role_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core..patent_assistant_examiner_alias_role_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: patent_correspondent_alias_role_trig_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION patent_correspondent_alias_role_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
    IF (TG_OP = 'UPDATE') THEN
      IF (1 = 1) THEN
       IF (COALESCE(OLD.correspondent_alias_id, -1) <> COALESCE(NEW.correspondent_alias_id, -1)) OR (1 <> 1) THEN
         IF OLD.correspondent_alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.pat_assignments', 'correspondent_alias_id', OLD.correspondent_alias_id, 'D', 'patent_correspondent');
         END IF;
         IF NEW.correspondent_alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.pat_assignments', 'correspondent_alias_id', NEW.correspondent_alias_id, 'I', 'patent_correspondent');
         END IF;
       END IF;
      END IF;
      RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('core.pat_assignments', 'correspondent_alias_id', OLD.correspondent_alias_id, 'D', 'patent_correspondent');
        END IF;
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('core.pat_assignments', 'correspondent_alias_id', NEW.correspondent_alias_id, 'I', 'patent_correspondent');
        END IF;
        RETURN NEW;
    ELSE
        RAISE EXCEPTION '[core..patent_correspondent_alias_role_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core..patent_correspondent_alias_role_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core..patent_correspondent_alias_role_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core..patent_correspondent_alias_role_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: patent_current_assignee_alias_role_trig_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION patent_current_assignee_alias_role_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
    IF (TG_OP = 'UPDATE') THEN
      IF (1 = 1) THEN
       IF (COALESCE(OLD.alias_id, -1) <> COALESCE(NEW.alias_id, -1)) OR (1 <> 1) THEN
         IF OLD.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.pat_stats_current_assignees', 'alias_id', OLD.alias_id, 'D', 'patent_current_assignee');
         END IF;
         IF NEW.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.pat_stats_current_assignees', 'alias_id', NEW.alias_id, 'I', 'patent_current_assignee');
         END IF;
       END IF;
      END IF;
      RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('core.pat_stats_current_assignees', 'alias_id', OLD.alias_id, 'D', 'patent_current_assignee');
        END IF;
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('core.pat_stats_current_assignees', 'alias_id', NEW.alias_id, 'I', 'patent_current_assignee');
        END IF;
        RETURN NEW;
    ELSE
        RAISE EXCEPTION '[core..patent_current_assignee_alias_role_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core..patent_current_assignee_alias_role_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core..patent_current_assignee_alias_role_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core..patent_current_assignee_alias_role_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: patent_inventor_alias_role_trig_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION patent_inventor_alias_role_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
    IF (TG_OP = 'UPDATE') THEN
      IF (OLD.pats_aliases_relationship_type_id = 7 OR NEW.pats_aliases_relationship_type_id = 7) THEN
       IF (COALESCE(OLD.alias_id, -1) <> COALESCE(NEW.alias_id, -1)) OR (OLD.pats_aliases_relationship_type_id <> NEW.pats_aliases_relationship_type_id) THEN
         IF OLD.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', OLD.alias_id, 'D', 'patent_inventor');
         END IF;
         IF NEW.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', NEW.alias_id, 'I', 'patent_inventor');
         END IF;
       END IF;
      END IF;
      RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        IF (OLD.pats_aliases_relationship_type_id = 7) THEN
         PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', OLD.alias_id, 'D', 'patent_inventor');
        END IF;
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        IF (NEW.pats_aliases_relationship_type_id = 7) THEN
         PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', NEW.alias_id, 'I', 'patent_inventor');
        END IF;
        RETURN NEW;
    ELSE
        RAISE EXCEPTION '[core..patent_inventor_alias_role_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core..patent_inventor_alias_role_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core..patent_inventor_alias_role_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core..patent_inventor_alias_role_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: patent_party_alias_role_trig_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION patent_party_alias_role_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
    IF (TG_OP = 'UPDATE') THEN
      IF (OLD.pats_aliases_relationship_type_id = 4 OR NEW.pats_aliases_relationship_type_id = 4) THEN
       IF (COALESCE(OLD.alias_id, -1) <> COALESCE(NEW.alias_id, -1)) OR (OLD.pats_aliases_relationship_type_id <> NEW.pats_aliases_relationship_type_id) THEN
         IF OLD.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', OLD.alias_id, 'D', 'patent_party');
         END IF;
         IF NEW.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', NEW.alias_id, 'I', 'patent_party');
         END IF;
       END IF;
      END IF;
      RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        IF (OLD.pats_aliases_relationship_type_id = 4) THEN
         PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', OLD.alias_id, 'D', 'patent_party');
        END IF;
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        IF (NEW.pats_aliases_relationship_type_id = 4) THEN
         PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', NEW.alias_id, 'I', 'patent_party');
        END IF;
        RETURN NEW;
    ELSE
        RAISE EXCEPTION '[core..patent_party_alias_role_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core..patent_party_alias_role_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core..patent_party_alias_role_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core..patent_party_alias_role_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: patent_primary_examiner_alias_role_trig_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION patent_primary_examiner_alias_role_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
    IF (TG_OP = 'UPDATE') THEN
      IF (OLD.pats_aliases_relationship_type_id = 5 OR NEW.pats_aliases_relationship_type_id = 5) THEN
       IF (COALESCE(OLD.alias_id, -1) <> COALESCE(NEW.alias_id, -1)) OR (OLD.pats_aliases_relationship_type_id <> NEW.pats_aliases_relationship_type_id) THEN
         IF OLD.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', OLD.alias_id, 'D', 'patent_primary_examiner');
         END IF;
         IF NEW.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', NEW.alias_id, 'I', 'patent_primary_examiner');
         END IF;
       END IF;
      END IF;
      RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        IF (OLD.pats_aliases_relationship_type_id = 5) THEN
         PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', OLD.alias_id, 'D', 'patent_primary_examiner');
        END IF;
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        IF (NEW.pats_aliases_relationship_type_id = 5) THEN
         PERFORM core.update_alias_role('core.pats_aliases_map', 'alias_id', NEW.alias_id, 'I', 'patent_primary_examiner');
        END IF;
        RETURN NEW;
    ELSE
        RAISE EXCEPTION '[core..patent_primary_examiner_alias_role_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core..patent_primary_examiner_alias_role_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core..patent_primary_examiner_alias_role_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core..patent_primary_examiner_alias_role_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: patent_sponsoring_party_alias_role_trig_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION patent_sponsoring_party_alias_role_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
    IF (TG_OP = 'UPDATE') THEN
      IF (1 = 1) THEN
       IF (COALESCE(OLD.alias_id, -1) <> COALESCE(NEW.alias_id, -1)) OR (1 <> 1) THEN
         IF OLD.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.pat_stats_sponsoring_parties', 'alias_id', OLD.alias_id, 'D', 'patent_sponsoring_party');
         END IF;
         IF NEW.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.pat_stats_sponsoring_parties', 'alias_id', NEW.alias_id, 'I', 'patent_sponsoring_party');
         END IF;
       END IF;
      END IF;
      RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('core.pat_stats_sponsoring_parties', 'alias_id', OLD.alias_id, 'D', 'patent_sponsoring_party');
        END IF;
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('core.pat_stats_sponsoring_parties', 'alias_id', NEW.alias_id, 'I', 'patent_sponsoring_party');
        END IF;
        RETURN NEW;
    ELSE
        RAISE EXCEPTION '[core..patent_sponsoring_party_alias_role_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core..patent_sponsoring_party_alias_role_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core..patent_sponsoring_party_alias_role_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core..patent_sponsoring_party_alias_role_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: ps_update_lit_judges_map(integer, integer, integer, integer, character varying, date, date, date); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION ps_update_lit_judges_map(p_lit_id integer, p_lit_judges_map_id integer, p_alias_id integer, p_assignment_type_id integer, p_assignment_role_as_filed character varying, p_start_date date, p_end_date date, p_missing_from_source_date date) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_lit_judges_map_id INTEGER := NULL;
BEGIN

 SELECT id
 INTO v_lit_judges_map_id
 FROM core.lit_judges_map
 WHERE alias_id = p_alias_id AND
       lit_id = p_lit_id AND
       assignment_type_id = p_assignment_type_id AND
       assignment_role_as_filed = p_assignment_role_as_filed AND
       coalesce(missing_from_source_date, '3001-01-01') = coalesce(p_missing_from_source_date, '3001-01-01') AND
       coalesce(start_date, '3001-01-01') = coalesce(p_start_date, '3001-01-01') AND
       coalesce(end_date, '3001-01-01') = coalesce(p_end_date, '3001-01-01');

 ---No changes, then return id
 ---Also make sure not to update data to create duplicates
 IF v_lit_judges_map_id is not NULL THEN

  IF coalesce(p_lit_judges_map_id, v_lit_judges_map_id) <> v_lit_judges_map_id THEN
     RAISE NOTICE 'Another  lit_judges_map record (id %) has the same information. No duplicates allowed.', v_lit_judges_map_id;
  END IF;

  RETURN v_lit_judges_map_id;
 END IF;

 UPDATE core.lit_judges_map
 SET
      is_terminated = (CASE WHEN p_end_date is not NULL THEN TRUE ELSE FALSE END),
      assignment_role_as_filed = p_assignment_role_as_filed,
      start_date = p_start_date,
      missing_from_source_date = p_missing_from_source_date,
      end_date = p_end_date
 WHERE id = p_lit_judges_map_id AND
       start_date < p_start_date;

 RETURN p_Lit_judges_map_id;
END;
$$;


--
-- Name: ps_update_lit_judges_map_missing(integer, date, date); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION ps_update_lit_judges_map_missing(p_lit_judges_map_id integer, p_end_date date, p_missing_from_source_date date) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
/*

	1.0 ateja_c DS-3712 21 Jun 2016 Updated logic of end_date and missing_from_source_date

*/
BEGIN

 ---missing date has to 10 days after start_date
 ---disable 10 days rule
 UPDATE core.lit_judges_map
 SET
      is_terminated = (CASE WHEN p_end_date is not NULL THEN TRUE ELSE FALSE END),
      missing_from_source_date = GREATEST(p_missing_from_source_date,start_date),
      end_date = GREATEST(p_end_date,start_date)
 WHERE id = p_lit_judges_map_id;

 ---- and coalesce(start_date, '1970-01-01') < p_missing_from_source_date - interval '10 days';

 RETURN p_Lit_judges_map_id;
END;
$$;


--
-- Name: ps_update_lit_parties(integer, integer, integer, integer, integer, date, date, date); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION ps_update_lit_parties(p_lit_id integer, p_lit_parties_id integer, p_alias_id integer, p_lit_party_type_id integer, p_alias_contact_id integer, p_start_date date, p_end_date date, p_missing_from_source_date date) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_lit_parties_id INTEGER := NULL;
BEGIN

 ---check if data has changes at all
 SELECT id
 INTO v_lit_parties_id
 FROM core.lit_parties
 WHERE lit_id = p_lit_id AND
       alias_id = p_alias_id AND
       coalesce(alias_contact_id, -1) = coalesce(p_alias_contact_id, -1) AND
       lit_party_type_id = p_lit_party_type_id AND
       coalesce(missing_from_source_date, '3001-01-01') = coalesce(p_missing_from_source_date, '3001-01-01') AND
       coalesce(start_date, '3001-01-01') = coalesce(p_start_date, '3001-01-01') AND
       coalesce(end_date, '3001-01-01') = coalesce(p_end_date, '3001-01-01');

 ---No changes, then return id
 ---Also make sure not to update data to create duplicates
 IF v_lit_parties_id is not NULL THEN
  IF coalesce(p_lit_parties_id, v_lit_parties_id) <> v_lit_parties_id THEN
     RAISE NOTICE 'Another lit_party record (id %) has the same information. No duplicates allowed.', v_lit_parties_id;
  END IF;
  RETURN v_lit_parties_id;
 END IF;

 IF p_lit_parties_id is NULL THEN
    RAISE EXCEPTION 'lit_parties_id must be provided for a update: %', p_lit_parties_id;
 END IF;

 UPDATE core.lit_parties lp
 SET
     alias_contact_id = CASE WHEN p_alias_contact_id is NULL THEN (SELECT MAX(id) FROM core.alias_contacts WHERE alias_id = p_alias_id) ELSE p_alias_contact_id END,
     alias_id = p_alias_id,
     start_date = p_start_date,
     missing_from_source_date = p_missing_from_source_date,
     is_removed_from_pacer = (CASE WHEN p_missing_from_source_date is NOT NULL THEN TRUE ELSE FALSE END)::BOOLEAN,
     end_date = p_end_date,
     lit_party_type_id = p_lit_party_type_id,
     dj_party_normalized_type = ( CASE WHEN lpt.lit_party_normalized_type IN ('defendant', 'plaintiff')
                                       THEN ( CASE WHEN la.is_dj
                                                   THEN ( CASE WHEN lpt.lit_party_normalized_type = 'defendant'
                                                               THEN 'plaintiff' ELSE 'defendant'
                                                          END )
                                       ELSE lpt.lit_party_normalized_type END )
                                  ELSE NULL END )
 FROM core.lit_annotations la, core.lit_party_types lpt WHERE la.lit_id = p_lit_id AND lpt.ID = p_lit_party_type_id
 AND lp.id = p_lit_parties_id;

 RETURN p_lit_parties_id;
END;
$$;


--
-- Name: ps_update_lit_parties_missing(integer, date); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION ps_update_lit_parties_missing(p_lit_parties_id integer, p_missing_from_source_date date) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_lit_parties_id INTEGER := NULL;
BEGIN
/*
	2.0 anarayanan 07-Aug-2017 DS-5684: Set end to missing from source date
*/
 IF p_lit_parties_id is NULL THEN
    RAISE EXCEPTION 'lit_parties_id must be provided for a update: %', p_lit_parties_id;
 END IF;


 ---missing date has to 10 days after start_date
 ---this is to handle the issue of initial load
 ---We received some dockets after initial loads without things like parties, judges
 ---but initial loads already had the information
 ---Give 10 days to make sure we get a good docket

 ---modification: this 10 days rule is a problem for new cases
 ---there are cases with bad party name then later fixed
 ---we need to turn off this 10 days rule because we don't have to deal with historical load any more.
 UPDATE core.lit_parties
 SET
     missing_from_source_date = p_missing_from_source_date,
     is_removed_from_pacer = (CASE WHEN p_missing_from_source_date is NOT NULL THEN TRUE ELSE FALSE END)::BOOLEAN,
     end_date = p_missing_from_source_date
 WHERE id = p_lit_parties_id;

 ----and coalesce(start_date, '1970-01-01') < p_missing_from_source_date - interval '10 days';

 RETURN p_lit_parties_id;
END;
$$;


--
-- Name: ps_update_lit_parties_representations(integer, integer, integer, integer, boolean, boolean, integer, integer, boolean, date, date, date); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION ps_update_lit_parties_representations(p_lit_parties_id integer, p_lit_parties_representations_id integer, p_lawfirm_alias_id integer, p_lawyer_alias_id integer, p_is_lead_lawyer boolean, p_is_notify_lawyer boolean, p_lawyer_alias_contact_id integer, p_lawfirm_alias_contact_id integer, p_is_local_lawyer boolean, p_start_date date, p_end_date date, p_missing_from_source_date date) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_lit_parties_representations_id INTEGER := NULL;
BEGIN
 SELECT id
 INTO v_lit_parties_representations_id
 FROM core.lit_parties_representations
 WHERE lit_parties_id = p_lit_parties_id AND
       lawyer_alias_id = p_lawyer_alias_id AND
       lawfirm_alias_id = p_lawfirm_alias_id AND
       is_lead_lawyer = p_is_lead_lawyer AND
       is_notify_lawyer = p_is_notify_lawyer AND
       coalesce(lawyer_alias_contact_id, -1) = coalesce(p_lawyer_alias_contact_id, -1) AND
       coalesce(lawfirm_alias_contact_id, -1) = coalesce(p_lawfirm_alias_contact_id, -1) AND
       is_local_lawyer = p_is_local_lawyer AND
       coalesce(missing_from_source_date, '3001-01-01') = coalesce(p_missing_from_source_date, '3001-01-01') AND
       coalesce(start_date, '3001-01-01') = coalesce(p_start_date, '3001-01-01') AND
       coalesce(end_date, '3001-01-01') = coalesce(p_end_date, '3001-01-01');


 ---No changes, then return id
 ---Also make sure not to update data to create duplicates
 IF v_lit_parties_representations_id is not NULL THEN

  IF coalesce(p_lit_parties_representations_id, v_lit_parties_representations_id) <> v_lit_parties_representations_id THEN
     RAISE NOTICE 'Another  lit_party_representation record (id %) has the same information. No duplicates allowed.', v_lit_parties_representations_id;
  END IF;

  RETURN v_lit_parties_representations_id;
 END IF;

 IF p_lit_parties_representations_id is NULL THEN
    RAISE EXCEPTION 'lit_parties_representations_id must be provided for a update: %', p_lit_parties_representations_id;
 END IF;

 UPDATE core.lit_parties_representations
 SET
       is_lead_lawyer = p_is_lead_lawyer,
       is_notify_lawyer = p_is_notify_lawyer,
       lawyer_alias_contact_id = p_lawyer_alias_contact_id,
       lawfirm_alias_contact_id = p_lawfirm_alias_contact_id,
       lawyer_alias_id = p_lawyer_alias_id,
       lawfirm_alias_id = p_lawfirm_alias_id,
       is_local_lawyer = p_is_local_lawyer,
       start_date = p_start_date,
       missing_from_source_date = p_missing_from_source_date,
       end_date = p_end_date
 WHERE id = p_lit_parties_representations_id;

 RETURN p_Lit_parties_representations_id;

END;
$$;


--
-- Name: ps_update_lit_parties_representations_missing(integer, date); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION ps_update_lit_parties_representations_missing(p_lit_parties_representations_id integer, p_missing_from_source_date date) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN

 IF p_lit_parties_representations_id is NULL THEN
    RAISE EXCEPTION 'lit_parties_representations_id must be provided for a update: %', p_lit_parties_representations_id;
 END IF;

 ---missing date has to 10 days after start_date
 ---disable 10 days rule
 UPDATE core.lit_parties_representations
 SET
       missing_from_source_date = p_missing_from_source_date
 WHERE id = p_lit_parties_representations_id;
 ---- and coalesce(start_date, '1970-01-01') < p_missing_from_source_date - interval '10 days';

 RETURN p_Lit_parties_representations_id;

END;
$$;


--
-- Name: queue_clear(integer, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION queue_clear(i_msg_type integer, i_priority integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_rowcount integer;
BEGIN
    DELETE FROM core.msg_queue
    WHERE msg_type=(CASE i_msg_type when 0 THEN msg_type ELSE i_msg_type END)
    AND priority=(CASE i_priority when 0 THEN priority ELSE i_priority END);
    GET DIAGNOSTICS v_rowcount = ROW_COUNT;
    RETURN v_rowcount;
END;
$$;


--
-- Name: seq_msg_queue; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE seq_msg_queue
    START WITH 101
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: msg_queue; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE msg_queue (
    msg_id integer DEFAULT nextval('seq_msg_queue'::regclass) NOT NULL,
    msg_key character varying(100) NOT NULL,
    msg_body text NOT NULL,
    create_tsp timestamp without time zone DEFAULT '2011-10-28 06:33:31.964695'::timestamp without time zone NOT NULL,
    priority smallint DEFAULT 1 NOT NULL,
    push_client character varying DEFAULT 'UNKNOWN'::character varying NOT NULL,
    msg_type integer,
    CONSTRAINT msg_type_chk CHECK ((msg_type = ANY (ARRAY[1, 2, 3, 4, 5, 6, 7, 8, 9, 10])))
);


--
-- Name: TABLE msg_queue; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE msg_queue IS 'This table is the intake queue for the DMA. Items are poped from this queue and added to the DMA and then logged in the msg_queue_log.';


--
-- Name: COLUMN msg_queue.msg_body; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN msg_queue.msg_body IS 'A json representation of the data that needs to be disambiguated/tagged in the DMA.';


--
-- Name: COLUMN msg_queue.priority; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN msg_queue.priority IS 'Priority in which items are popped from the Queue by the DMA. The greaters integers are popped first.';


--
-- Name: queue_list(integer, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION queue_list(i_msg_type integer, i_priority integer) RETURNS SETOF msg_queue
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    queue_row core.msg_queue%rowtype;
BEGIN
    FOR queue_row IN
        SELECT *
        FROM core.msg_queue
        WHERE msg_type=(CASE i_msg_type when 0 THEN msg_type ELSE i_msg_type END)
        AND priority=(CASE i_priority when 0 THEN priority ELSE i_priority END)
        ORDER BY msg_id DESC
    LOOP
        RETURN NEXT queue_row;
    END LOOP;
    RETURN;
END;
$$;


--
-- Name: queue_pop(integer, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION queue_pop(i_msg_type integer, i_priority integer) RETURNS queue_msg_type
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_client varchar;
    v_priority integer;
    v_create_tsp timestamp;
    v_poped_msg boolean := true;
    v_empty_queue boolean := false;
    v_max_priority integer := 0;
    v_flag integer := 0;
    r_msg core.queue_msg_type;
BEGIN
    -- Serialize access. Reader will block.
    SELECT flag
    INTO v_flag
    FROM core.queue_semaphore
    WHERE flag = 1 FOR UPDATE;

    IF i_priority = 0 THEN
        SELECT max(priority)
        FROM core.msg_queue
        INTO v_max_priority
        WHERE msg_type=(CASE i_msg_type when 0 THEN msg_type ELSE i_msg_type END);
    ELSE
        v_max_priority:=i_priority;
    END IF;

    SELECT msg_id, msg_body, msg_key, msg_type, priority, create_tsp, push_client
    INTO r_msg.msg_id,r_msg.msg_body, r_msg.msg_key, r_msg.msg_type, r_msg.msg_priority, r_msg.msg_create_ts, r_msg.msg_client_id
    FROM core.msg_queue
    WHERE msg_id = (
        -- FIFO: the earliest msg_id for the given type+priority
        SELECT min(msg_id)
        FROM core.msg_queue
        WHERE priority=v_max_priority
        AND msg_type=(CASE i_msg_type when 0 THEN msg_type ELSE i_msg_type END)
    );

    IF NOT FOUND THEN
        v_empty_queue := true;
        v_poped_msg := false;
    END IF;

    IF v_empty_queue IS TRUE THEN
        r_msg.msg_id := 0;
        r_msg.msg_key := 0;
        r_msg.msg_body := '';

    ELSEIF v_poped_msg IS TRUE THEN
        -- Keep a log of popped messages
        INSERT INTO core.msg_queue_log (
            msg_id,
            msg_key,
            msg_body,
            msg_type,
            priority,
            push_client,
            org_create_tsp,
            create_tsp
        ) (SELECT
               msg_id,
               msg_key,
               msg_body,
               msg_type,
               priority,
               push_client,
               create_tsp,
               timeofday()::timestamp
           FROM core.msg_queue
           WHERE msg_id = r_msg.msg_id
        );
        -- Remove message from queue
        DELETE FROM core.msg_queue WHERE msg_id=r_msg.msg_id;
    ELSE
        RAISE EXCEPTION 'queue_pop: failed to pop from queue. reason unknown';
    END IF;

    RETURN r_msg;
END;
$$;


--
-- Name: queue_push(integer, integer, character varying, character varying, character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION queue_push(i_msg_type integer, i_priority integer, i_msg_key character varying, i_msg_body character varying, i_client character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_msg_id integer;
BEGIN
    SELECT nextval('core.SEQ_MSG_QUEUE') INTO v_msg_id;
    INSERT INTO core.msg_queue (
        msg_id,
        msg_type,
        msg_key,
        msg_body,
        priority,
        push_client,
        create_tsp
    ) VALUES (
        v_msg_id,
        i_msg_type,
        i_msg_key,
        i_msg_body,
        i_priority,
        i_client,
        timeofday()::timestamp
    );

    RETURN v_msg_id;
END;
$$;


--
-- Name: queue_restore(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION queue_restore(i_log_msg_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_msg_type INTEGER;
  v_priority INTEGER;
  v_msg_key CHARACTER VARYING;
  v_msg_body CHARACTER VARYING;
  v_client CHARACTER VARYING;
  v_cnt INTEGER := 0;
BEGIN
SELECT
   count(*) over () cnt,
   msg_type,
   priority,
   msg_key,
   msg_body,
   push_client
INTO
  v_cnt,
  v_msg_type,
  v_priority,
  v_msg_key,
  v_msg_body,
  v_client
FROM core.msg_queue_log q
WHERE q.msg_id=i_log_msg_id;

IF coalesce(v_cnt, 0) != 1 THEN
  RETURN NULL;
END IF;

RETURN (
  SELECT * FROM core.queue_push (
    v_msg_type,
    v_priority,
    v_msg_key,
    v_msg_body,
    v_client
  )
);
END;
$$;


--
-- Name: queue_size(integer, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION queue_size(i_msg_type integer, i_priority integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_count integer;
BEGIN
    SELECT count(msg_id)
    INTO v_count
    FROM core.msg_queue
    WHERE priority=(CASE i_priority when 0 THEN priority ELSE i_priority END)
    AND msg_type=(CASE i_msg_type when 0 THEN msg_type ELSE i_msg_type END);
    RETURN v_count;
END;
$$;


--
-- Name: random_string(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  chars TEXT[] := '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
  result TEXT := '';
  i INTEGER := 0;
BEGIN
  IF length < 0
  THEN
    raise exception 'Given length cannot be less than 0';
  END IF;
  FOR i IN 1..length
  LOOP
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  END LOOP;
  RETURN result;
END;
$$;


--
-- Name: refresh_pat_family_pats_details(integer[], text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION refresh_pat_family_pats_details(p_pat_id integer[] DEFAULT NULL::integer[], p_id_query text DEFAULT NULL::text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$

DECLARE 
v_sql TEXT := '';

v_table_cols TEXT := core.get_select_string(i_tab_name:='core.pat_family_pats_details',i_tab_ignore_cols :='id'); 
v_table_cols_ins TEXT := core.get_select_string(i_tab_name:='core.pat_family_pats_details',i_tab_ignore_cols :='id',i_tab_alias:='ap');
v_table_cols_pfpd TEXT := core.get_select_string(i_tab_name:='core.pat_family_pats_details',i_tab_ignore_cols :='id',i_tab_alias:='pfpd');

v_pat_ids INTEGER [];
ia_inserted_pat_ids INTEGER[];
ia_updatable_pat_ids INTEGER[];
v_count INTEGER;

BEGIN 
/*
2.0 anarayanan 11-Apr-2016 DS-3554 : Drop the temporary table at the end of the API.
3.0 anarayanan 02-May-2016 DS-3699 : Removing the drop command to restrict using this API more than once in a single transaction
									Added performance improvments
4.0 anarayanan 03-May-2016 DS-3699 : Converted TEMP table to CTE. Will use batch concepts to update the code.
4.1 tazhagan_c 09-May-2016 DS-3725 : Update processed_stage = 'C' after processing
*/

IF p_id_query IS NOT NULL THEN
		EXECUTE p_id_query
		INTO v_pat_ids;
END IF ;
	v_pat_ids := v_pat_ids || p_pat_id;

v_sql :=  '
	WITH api_pfpd AS (
		SELECT
			*
		FROM
			core.get_pat_family_pats_details (p_pat_id := $1)
	),
	 del AS (
		DELETE
		FROM
			core.pat_family_pats_details pd
		WHERE
			pd.pat_id = ANY ($1)
		AND NOT EXISTS (
			SELECT
				1
			FROM
				api_pfpd ap
			WHERE
				ap.pat_id = pd.pat_id
		) RETURNING pat_id
	),
	 to_upd AS (
		SELECT
			ARRAY_AGG (ap.pat_id) AS pat_ids
		FROM
			core.pat_family_pats_details pfpd
		INNER JOIN api_pfpd ap ON (
			pfpd.pat_id = ap.pat_id
			AND md5(
				('||v_table_cols_pfpd||') :: TEXT
			) != md5(
				('||v_table_cols_ins||') :: TEXT
			)
		)
		WHERE
			pfpd.pat_id = ANY ($1)
	),
	 upd_del AS (
		DELETE
		FROM
			core.pat_family_pats_details
		WHERE
			pat_id = ANY (
				(SELECT pat_ids FROM to_upd) :: INT []
			) RETURNING pat_id
	),
	 upd_ins AS (
		INSERT INTO core.pat_family_pats_details ('||v_table_cols||') SELECT
			'||v_table_cols_ins||'
		FROM
			api_pfpd ap
		WHERE
			ap.pat_id = ANY (
				(
					SELECT
						ARRAY_AGG (pat_id)
					FROM
						upd_del
				) :: INT []
			) RETURNING pat_id
	),
	 ins AS (
		INSERT INTO core.pat_family_pats_details ('||v_table_cols||') SELECT
			'||v_table_cols_ins||'
		FROM
			api_pfpd ap
		WHERE
			NOT EXISTS (
				SELECT
					1
				FROM
					core.pat_family_pats_details pd
				WHERE
					pd.pat_id = ap.pat_id
			) RETURNING pat_id
	) SELECT
		SUM (cnt)
	FROM
		(
			SELECT
				COUNT (pat_id) AS cnt
			FROM
				del
			UNION ALL
				SELECT
					COUNT (pat_id)
				FROM
					upd_ins
				UNION ALL
					SELECT
						COUNT (pat_id)
					FROM
						ins
		) T
';

EXECUTE v_sql using v_pat_ids into v_count;

	v_sql:='
		UPDATE patent_stats.pat_stats_control t
		SET processed_stage = ''C''
		FROM core.pats pats
		WHERE pats.stripped_patnum = t.stripped_patnum AND pats.country_code = t.country_code
		AND pats.id = ANY($1)
		';
			
	EXECUTE v_sql USING v_pat_ids;

RETURN v_count;

EXCEPTION WHEN OTHERS THEN RAISE;END;$_$;


--
-- Name: remove_orphan_documents(integer[]); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION remove_orphan_documents(p_lit_document_ids integer[]) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 rd RECORD;
BEGIN

 FOR rd IN (SELECT UNNEST(p_lit_document_ids) as lit_document_id)
 LOOP
  DELETE
  FROM core.lit_document_orphans t
  WHERE t.lit_document_id = rd.lit_document_id
        AND EXISTS
        (SELECT 1
         FROM core.docket_entry_documents_map m
         WHERE m.lit_document_id = rd.lit_document_id
         LIMIT 1);
 END LOOP;
 RETURN 1;
END;
$$;


--
-- Name: replace_lits_pats_tmp(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION replace_lits_pats_tmp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    vrecord RECORD;
BEGIN
    IF TG_OP = 'INSERT' THEN
        -- Does the record exist in lits_pats_map ?
        SELECT id, lit_id, patnum, start_date, end_date
        INTO vrecord FROM core.lits_pats_map
        WHERE lit_id=NEW.lit_id AND patnum=NEW.patnum;

        IF NOT FOUND THEN
            INSERT INTO lits_pats_map (lit_id, patnum, start_date, end_date) VALUES (NEW.lit_id, NEW.patnum, NEW.start_date, NEW.end_date);

            RETURN NEW; -- The trigger succeeded
        ELSIF (vrecord.start_date != NEW.start_date) OR (vrecord.end_date != NEW.end_date) THEN
            RAISE EXCEPTION 'There already is a record for lit_id % and patnum % in lits_pats_map. Its id is %. Its start_date is %. Its end_date is %.',
                            NEW.lit_id, NEW.patnum, vrecord.id, vrecord.start_date, vrecord.end_date USING ERRCODE = 'unique_violation';
        END IF; -- Nothing more to do, the lit pat combination already exists and is OK

    ELSIF TG_OP = 'UPDATE' THEN
        -- Does the record exist in lits_pats_map ?
        SELECT id, lit_id, patnum, start_date, end_date
        INTO vrecord FROM core.lits_pats_map
        WHERE id=NEW.id ;

        IF FOUND THEN
            UPDATE lits_pats_map
            SET lit_id = NEW.lit_id,
                patnum = NEW.patnum,
                start_date = NEW.start_date,
                end_date = NEW.end_date
            WHERE id = OLD.id;

            RETURN NEW; -- The trigger succeeded
        ELSE
            RAISE EXCEPTION 'There is no record for id %, lit_id %, and patnum % in lits_pats_map. Cannot update.',
                                OLD.id, OLD.lit_id, OLD.patnum USING ERRCODE = 'no_data';
        END IF;

    ELSIF TG_OP = 'DELETE' THEN
        -- Does the record exist in lits_pats_map ?
        SELECT id, lit_id, patnum, start_date, end_date
        INTO vrecord FROM core.lits_pats_map
        WHERE id=OLD.id ;

        IF FOUND THEN
            DELETE FROM lits_pats_map
            WHERE id = OLD.id;

            RETURN OLD;
        ELSE
            RAISE EXCEPTION 'There is no record for id % and lit_id % and patnum % in lits_pats_map. Cannot delete.',
                            OLD.id, OLD.lit_id, OLD.patnum USING ERRCODE = 'no_data';
        END IF;

    END IF;

    RETURN NULL;
END;
$$;


--
-- Name: reverse_integer(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION reverse_integer(p_integer integer) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
begin
	return
		(
		  select
			coalesce((regexp_split_to_array(p_integer::text,''))[12],'')||
			coalesce((regexp_split_to_array(p_integer::text,''))[11],'')||
			coalesce((regexp_split_to_array(p_integer::text,''))[10],'')||
			coalesce((regexp_split_to_array(p_integer::text,''))[9],'')||
			coalesce((regexp_split_to_array(p_integer::text,''))[8],'')||
			coalesce((regexp_split_to_array(p_integer::text,''))[7],'')||
			coalesce((regexp_split_to_array(p_integer::text,''))[6],'')||
			coalesce((regexp_split_to_array(p_integer::text,''))[5],'')||
			coalesce((regexp_split_to_array(p_integer::text,''))[4],'')||
			coalesce((regexp_split_to_array(p_integer::text,''))[3],'')||
			coalesce((regexp_split_to_array(p_integer::text,''))[2],'')||
			coalesce((regexp_split_to_array(p_integer::text,''))[1],'')
		);
end;
$$;


--
-- Name: score_context(integer, integer, text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION score_context(alias_id integer, ent_id integer, tbl text) RETURNS double precision
    LANGUAGE plpgsql STRICT
    AS $$

BEGIN
    RAISE NOTICE 'This function has been deprecated, please use code_nerd.score_context';
    RETURN code_nerd.score_context(alias_id, ent_id, tbl);

END
$$;


--
-- Name: score_string(text, text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION score_string(str1 text, str2 text) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $$

BEGIN
    RAISE NOTICE 'This function has been deprecated, please use code_nerd.score_string';
    RETURN code_nerd.score_string(str1, str2);

END
$$;


--
-- Name: set_lit_document_status(integer, integer, character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION set_lit_document_status(p_doc_id integer, p_doc_status_id integer, p_doc_status_message character varying) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	a_state_matrix integer [5][5]:='{{-11,1,1,1,-15,-16},{-21,1,1,1,1,-26},{-31,-32,1,1,1,1},{-41,-42,1,1,1,1},{-51,-52,1,1,1,1},{-61,-62,1,1,1,1}}';
	v_document_status_id integer :=0;
	v_cnt integer:=0;
BEGIN

	select document_status_id,count(1) over () cnt
	into v_document_status_id, v_cnt
	from core.lit_documents
	where id=p_doc_id;

	---Does the document exist
	if (v_cnt=0 or v_document_status_id is null)
	then
		raise exception '[core.set_lit_document_status] could not locate the document in core.lit_documents using document id=%', p_doc_id;
	end if;

	---Is this a legal state/status transition?
	if (coalesce(a_state_matrix[v_document_status_id][p_doc_status_id],-99)<0) then
		raise exception '[core.set_lit_document_status] code % could not change status_id % to status_id % for document id=%',
												coalesce(a_state_matrix[v_document_status_id][p_doc_status_id],-99), v_document_status_id, p_doc_status_id, p_doc_id;
	end if;

	update core.lit_documents
		set document_status_id=p_doc_status_id,
		 	document_status_message=p_doc_status_message
		where id=p_doc_id;
END;
 $$;


--
-- Name: set_lit_relationship_type(integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION set_lit_relationship_type(p_lit_relationship_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_from_lit          INTEGER;
    v_to_lit            INTEGER;
    v_cnt_from          INTEGER;
    v_cnt_to            INTEGER;

    v_to_lit_filed      DATE;
    v_from_lit_parties  INTEGER[];
    v_to_lit_parties    INTEGER[];

    v_rel_type          INTEGER := 0;

BEGIN
    -- Get the lit ids from the lit_relationships
    SELECT from_lit_id, to_lit_id
    INTO v_from_lit, v_to_lit
    FROM core.lit_relationships
    WHERE id = p_lit_relationship_id;

    IF v_from_lit IS NULL OR v_from_lit = 0 OR v_to_lit IS NULL OR v_to_lit = 0 THEN
        RAISE EXCEPTION '[core.set_lit_relationship_type] Could not get litigations from lit_relationship id = %',p_lit_relationship_id;
    END IF;

    -- Count the number of litigations that go to the to_lit_id
    SELECT count(*)
    INTO v_cnt_from
    FROM core.lit_relationships
    WHERE to_lit_id = v_to_lit;

    -- Count the number of litigations that come from the from_lit_id
    SELECT count(*)
    INTO v_cnt_to
    FROM core.lit_relationships
    WHERE from_lit_id = v_from_lit;

    IF v_cnt_from = 1 AND v_cnt_to = 1 THEN
        IF v_to_lit = v_from_lit THEN
            v_rel_type := (SELECT id FROM core.lit_relationship_types WHERE name = 'solitary');

        ELSE
            v_to_lit_filed := (SELECT filed_date FROM core.lits WHERE id = v_to_lit);

            --Get the list of active parties in the "from" litigation that were active when the "to" litigation was started
            SELECT array_agg(al.id)
            INTO v_from_lit_parties
            FROM core.lit_parties lp
            INNER JOIN core.lit_party_types lpt ON lp.lit_party_type_id = lpt.id
            INNER JOIN core.aliases al ON lp.alias_id = al.id
            WHERE lp.lit_id = v_from_lit
                AND (lp.end_date > v_to_lit_filed OR lp.end_date IS NULL)
                AND lpt.lit_party_normalized_type = 'defendant';

            --Get the list of active parties in the "to" litigation
            SELECT array_agg(al.id)
            INTO v_to_lit_parties
            FROM core.lit_parties lp
            INNER JOIN core.lit_party_types lpt ON lp.lit_party_type_id = lpt.id
            INNER JOIN core.aliases al ON lp.alias_id = al.id
            WHERE lp.lit_id = v_to_lit
                AND lpt.lit_party_normalized_type = 'defendant';

            IF v_from_lit_parties <@ v_to_lit_parties THEN
                --all the lit_parties in the from_lit are in the to_lit
                v_rel_type := (SELECT id FROM core.lit_relationship_types WHERE name = 'transfer');
            ELSE
                --there are parties in the from_lit that didn't move to the to_lit
                v_rel_type := (SELECT id FROM core.lit_relationship_types WHERE name = 'severance');
            END IF;

        END IF;
    ELSIF v_cnt_from = 1 AND v_cnt_to > 1 THEN
        v_rel_type := (SELECT id FROM core.lit_relationship_types WHERE name = 'severance');

    ELSIF v_cnt_from > 1 AND v_cnt_to = 1 THEN
        v_rel_type := (SELECT id FROM core.lit_relationship_types WHERE name = 'consolidation');

    ELSIF v_cnt_from > 1 AND v_cnt_to > 1 THEN
        --This can be both a severance and a consolidation depending on which end we look from,
        --but since the directionality seems to be from oldest to newest, severance will win out.
        v_rel_type := (SELECT id FROM core.lit_relationship_types WHERE name = 'severance');

    END IF;

    IF v_rel_type > 0 THEN
        UPDATE core.lit_relationships
        SET lit_relationship_type_id = v_rel_type
        WHERE id = p_lit_relationship_id
            AND (lit_relationship_type_id != v_rel_type OR lit_relationship_type_id IS NULL);
    ELSE
        RAISE EXCEPTION '[core.set_lit_relationship_type] Could not determine relationship type for lit_relationship id = %',p_lit_relationship_id;
    END IF;

    RETURN v_rel_type;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core.set_lit_relationship_type] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core.set_lit_relationship_type] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
    WHEN OTHERS THEN
        RAISE;

END;
$$;


--
-- Name: sf_accountx_alias_ent_details_trig_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION sf_accountx_alias_ent_details_trig_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
 /*
1.0 vpemmaraju 19-Jun-2017 DS-5470 : add sf_account_id and sf_account_type
*/
    IF (TG_OP = 'UPDATE') THEN
            IF ( coalesce(NEW.typex,'') <> coalesce(OLD.typex,'') ) THEN
                      UPDATE core.alias_ent_details
                        SET sf_account_type=NEW.typex
                        WHERE sf_account_id = NEW.id;
	       END IF;

      RETURN NEW;
    END IF;


    IF (TG_OP = 'DELETE') THEN
         --if an account in salesforce is deleted. we have to mark the field salesforce_id in core.ents to null.
         --we already have a trigger on core.ents which will update sf_account_id to null in core.alias_ent_details.
          UPDATE core.ents SET salesforce_id=NULL  WHERE salesforce_id=OLD.id;
        RETURN OLD;
    END IF;

    IF (TG_OP = 'INSERT') THEN
                      -- some times there is a gap where salesforce_id in core.ents getts updated first and later we will have that id created in sf. accountx.
                      -- in such cases this update will fix the issue.
                        UPDATE core.alias_ent_details e
                        SET sf_account_type=NEW.typex
                        WHERE sf_account_id = NEW.id and coalesce(e.sf_account_type,'') <> coalesce(NEW.typex,'') ;
        RETURN NEW;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core.sf_accountx_alias_ent_details_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core.sf_accountx_alias_ent_details_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core.sf_accountx_alias_ent_details_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: strip_html(text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION strip_html(p_text_to_strip text) RETURNS text
    LANGUAGE plperlu SECURITY DEFINER
    AS $_X$

	#use HTML::Restrict;

	#my $hr = HTML::Restrict->new();
	#return $processed = $hr->process($_[0]);

	use HTML::Strip;
	my $hs = HTML::Strip->new();
	my $clean_text = $hs->parse( $_[0] );
	return $clean_text;

END;
	$_X$;


--
-- Name: sync_ent_subss_trig_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION sync_ent_subss_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_id int;
BEGIN

/* 1.1 tazhagan_c DS-5426 : Need to make logic in rpx_reporting.ent_subs consistent to include original ent_id also in the subsidiary column */

    IF (TG_OP = 'UPDATE') THEN
     with src as (
        select t.ent_id, case when s.ent_id is null then true else false end as is_new
        from (select distinct unnest(ARRAY[NEW.ent_id, OLD.ent_id, NEW.related_ent_id, OLD.related_ent_id]) as ent_id) t
        left join rpx_reporting.ent_subs s on t.ent_id = s.ent_id
     ),
     ins as (
      insert into rpx_reporting.ent_subs (ent_id, subs)
        select  ent_id,
                (select array_agg(r_ent_id) from (select r_ent_id from core.get_entity_children(s.ent_id) union select s.ent_id)t)
        from src s
        where is_new
     ),
     upd as (
      update rpx_reporting.ent_subs t
        set subs = (select array_agg(r_ent_id) from (select r_ent_id from core.get_entity_children(s.ent_id) union select s.ent_id)t)
        from src s
        where s.ent_id = t.ent_id and s.is_new = false
     )
     select 1 into v_id;

      RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
     with src as (
        select t.ent_id, case when s.ent_id is null then true else false end as is_new
        from (select distinct unnest(ARRAY[OLD.ent_id, OLD.related_ent_id]) as ent_id) t
        left join rpx_reporting.ent_subs s on t.ent_id = s.ent_id
     ),
     ins as (
      insert into rpx_reporting.ent_subs (ent_id, subs)
        select  ent_id,
                (select array_agg(r_ent_id) from (select r_ent_id from core.get_entity_children(s.ent_id) union select s.ent_id)t)
        from src s
        where is_new
     ),
     upd as (
      update rpx_reporting.ent_subs t
        set subs = (select array_agg(r_ent_id) from (select r_ent_id from core.get_entity_children(s.ent_id) union select s.ent_id)t)
        from src s
        where s.ent_id = t.ent_id and s.is_new = false
     )
     select 1 into v_id;
      RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
     with src as (
        select t.ent_id, case when s.ent_id is null then true else false end as is_new
        from (select distinct unnest(ARRAY[NEW.ent_id, NEW.related_ent_id]) as ent_id) t
        left join rpx_reporting.ent_subs s on t.ent_id = s.ent_id
     ),
     ins as (
      insert into rpx_reporting.ent_subs (ent_id, subs)
        select  ent_id,
                (select array_agg(r_ent_id) from (select r_ent_id from core.get_entity_children(s.ent_id) union select s.ent_id)t)
        from src s
        where is_new
     ),
     upd as (
      update rpx_reporting.ent_subs t
        set subs = (select array_agg(r_ent_id) from (select r_ent_id from core.get_entity_children(s.ent_id) union select s.ent_id)t)
        from src s
        where s.ent_id = t.ent_id and s.is_new = false
     )
     select 1 into v_id;
      RETURN NEW;
    ELSE
        RAISE EXCEPTION '[core..sync_ent_subs_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core..sync_ent_subs_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core..sync_ent_subs_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core..sync_ent_subs_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: sync_original_filed_date_tr(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION sync_original_filed_date_tr() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_lit_id            integer;
    v_lit_id_2          integer;
    v_trsfr_to_count    integer;

BEGIN
    IF (TG_OP = 'UPDATE') THEN
        v_lit_id = OLD.to_lit_id;
        v_lit_id_2 = NEW.to_lit_id;
    ELSIF (TG_OP = 'DELETE') THEN
        v_lit_id = OLD.to_lit_id;
    ELSIF (TG_OP = 'INSERT') THEN
        v_lit_id = NEW.to_lit_id;
    ELSE
        RAISE WARNING '[core.sync_original_filed_date_tr] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

    -- We need to update the orig filed date for the to_lit_id (both old and new if applicable) of the relationship.
    UPDATE core.lits
    SET original_filed_date = core.find_orig_file_date(v_lit_id)
    WHERE id = v_lit_id;

    IF v_lit_id_2 != v_lit_id THEN
        UPDATE core.lits
        SET original_filed_date = core.find_orig_file_date(v_lit_id_2)
        WHERE id = v_lit_id_2;
    END IF;

    SELECT count(to_lit_id)
    INTO v_trsfr_to_count
    FROM core.lit_relationships
    WHERE from_lit_id IN (v_lit_id, v_lit_id_2);

    IF v_trsfr_to_count IS NOT NULL THEN
    -- There are other litigations that the one(s) we're looking at will transfer to.
    -- so if the case(s) we're looking at has a new orig filed date then so will any case
    -- that it transfers into. We need to re-calculate the orig file date for any
    -- litigation after it in the tranfer chain.
        UPDATE core.lits
        SET original_filed_date = core.find_orig_file_date(id)
        WHERE id IN (WITH RECURSIVE my_tree1(to_lit_id, from_lit_id, viewed_lits) AS
                         (SELECT lit_relationships.to_lit_id, lit_relationships.from_lit_id, ARRAY[]::INTEGER[] AS viewed_lits
                          FROM core.lit_relationships
                          WHERE lit_relationships.from_lit_id = v_lit_id
                              AND lit_relationships.lit_relationship_type_id != 2
                        UNION
                          SELECT lr.to_lit_id, lr.from_lit_id, array_append(mt1.viewed_lits, lr.from_lit_id) AS viewed_lits
                          FROM core.lit_relationships lr
                          JOIN my_tree1 mt1 ON mt1.to_lit_id = lr.from_lit_id
                          WHERE lr.to_lit_id != ALL (mt1.viewed_lits)
                         )
                     SELECT mt1.to_lit_id
                     FROM my_tree1 mt1);
    END IF;

    IF (TG_OP = 'UPDATE') THEN
        RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        RETURN NEW;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE WARNING '[core.sync_original_filed_date_tr] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE WARNING '[core.sync_original_filed_date_tr] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE WARNING '[core.sync_original_filed_date_tr] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: sync_ultimate_parent_tr(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION sync_ultimate_parent_tr() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_ent_id            integer;
--    v_ent_ult_parent    integer;
    v_new_parent        integer;
    v_child_count       integer;

BEGIN
    IF (TG_OP = 'UPDATE') THEN
        v_ent_id = NEW.ent_id;
    ELSIF (TG_OP = 'DELETE') THEN
        v_ent_id = OLD.ent_id;
    ELSIF (TG_OP = 'INSERT') THEN
        v_ent_id = NEW.ent_id;
    ELSE
        RAISE WARNING '[core.sync_ultimate_parent_tr] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

/*
    SELECT ultimate_parent_id
    INTO v_ent_ult_parent
    FROM core.ents
    WHERE id = v_ent_id;
*/

    v_new_parent := core.find_ult_parent(v_ent_id);

    -- We need to update the ultimate parent for the child of the changed relationship.
    UPDATE core.ents
    SET ultimate_parent_id = v_new_parent,
        rollup_parent_id = (CASE WHEN ultimate_parent_id = rollup_parent_id THEN v_new_parent ELSE rollup_parent_id END)
    WHERE id = v_ent_id;

    SELECT count(ent_id)
    INTO v_child_count
    FROM core.ent_relationships
    WHERE related_ent_id = v_ent_id;

    IF v_child_count IS NOT NULL THEN
    -- There are sub-children of the child of the relationship we are changing and since
    -- their parent is now pointing to a new ult-parent their ultimate parent will change.
    -- Since their parent's ultimate parent will be their ultimate parent as well there
    -- is no need to recalculate for each child.

        UPDATE core.ents
        SET ultimate_parent_id = v_new_parent,
            rollup_parent_id = (CASE WHEN ultimate_parent_id = rollup_parent_id THEN v_new_parent ELSE rollup_parent_id END)
        WHERE id IN (WITH RECURSIVE my_tree1(ent_id, related_ent_id) AS
                         (SELECT ent_relationships.ent_id, ent_relationships.related_ent_id
                          FROM core.ent_relationships
                          WHERE ent_relationships.related_ent_id = v_ent_id
                              AND ent_relationships.ent_relationship_type_id IN (1,2,6)
                        UNION
                          SELECT er.ent_id, er.related_ent_id
                          FROM core.ent_relationships er
                          JOIN my_tree1 mt1 ON mt1.ent_id = er.related_ent_id
                              AND er.ent_relationship_type_id IN (1,2,6)
                         )
                     SELECT mt1.ent_id
                     FROM my_tree1 mt1);
    END IF;

    IF (TG_OP = 'UPDATE') THEN
        RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        RETURN NEW;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE WARNING '[core.sync_ultimate_parent_tr] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE WARNING '[core.sync_ultimate_parent_tr] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE WARNING '[core.sync_ultimate_parent_tr] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: table_audit_summary(text, text, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION table_audit_summary(p_schema text, p_table text, p_start_time timestamp without time zone, p_end_time timestamp without time zone) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
v_sql VARCHAR;
v_column VARCHAR;
v_action CHAR[] := ARRAY['I','U','D'];
v_user VARCHAR;
v_count INTEGER;
v_summary TEXT := '';
BEGIN
FOR v_column IN
SELECT column_name
FROM information_schema.columns
WHERE table_name = p_table||'_aud' AND table_schema = p_schema||'_audit'
AND substr(column_name, 1, 2) = '__'
LOOP
v_summary = v_summary || substr(v_column,3) || ' ~ ';
FOR i IN 1..3
LOOP
v_sql := '
SELECT user_name, count(*)
FROM ' || p_schema || '_audit.' || p_table || '_aud' || '
WHERE created_at BETWEEN ''' || p_start_time || ''' AND ''' || p_end_time || '''
AND ' || v_column || ' = TRUE
AND action = ''' || v_action[i] || ''' GROUP BY user_name;';

FOR v_user, v_count IN EXECUTE v_sql
LOOP
v_summary := v_summary || v_user || ':' || v_action[i] || ':' || v_count || ';';
END LOOP;
v_summary := regexp_replace(v_summary, '\;$', ' ');
END LOOP;
v_summary := v_summary || '| ';
END LOOP;
v_summary := regexp_replace(v_summary, '\| $', '');
RETURN v_summary;
END;
$_$;


--
-- Name: table_audit_summary(character varying, character varying, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION table_audit_summary(p_schema character varying, p_table character varying, p_start_time timestamp without time zone, p_end_time timestamp without time zone) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	v_sql VARCHAR;
	v_column VARCHAR;
	v_action VARCHAR[] := ARRAY['I','U','D'];
	v_count INTEGER;
	v_summary TEXT := '';
BEGIN
FOR v_column IN
	SELECT column_name
	FROM information_schema.columns
	WHERE table_name = p_table||'_aud' AND table_schema = p_schema||'_audit'
	AND substr(column_name, 1, 2) = '__'
LOOP
	v_summary = v_summary || substr(v_column,3) || ' -';
	FOR i IN 1..3
	LOOP
		v_sql := '
		SELECT count(*)
		FROM core_audit.' || p_table || '_aud' || '
		WHERE created_at BETWEEN ''' || p_start_time || ''' AND ''' || p_end_time || '''
		AND ' || v_column || ' = TRUE
		AND action = ''' || v_action[i] || ''';';
		EXECUTE v_sql INTO v_count;	
		v_summary := v_summary || ' ' || v_action[i] || ':' || v_count;  
	END LOOP;
		v_summary := v_summary || '|';  
END LOOP;

RETURN v_summary;
END;
$$;


--
-- Name: table_delete_count(text, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION table_delete_count(p_table text, p_start_time timestamp without time zone, p_end_time timestamp without time zone) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
v_sql VARCHAR;
v_count INTEGER;
BEGIN
v_sql := '
SELECT count(*)
FROM ' || split_part(p_table, '.', 1) || '_audit.' || split_part(p_table, '.', 2) || '_aud' || '
WHERE created_at BETWEEN ''' || p_start_time || ''' AND ''' || p_end_time || '''
AND action = ''D''';

EXECUTE v_sql INTO v_count;
RETURN v_count;
END;
$$;


--
-- Name: trace_lit_family_forward(integer[], integer[]); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION trace_lit_family_forward(p_start_lits integer[], p_ent_id_list integer[]) RETURNS TABLE(r_lit_relationship_id integer, r_from_lit_id integer, r_to_lit_id integer, r_lit_family_id integer, r_lit_relationship_type integer, r_path_step integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_ult_parent_id     INTEGER;
    v_entity_list       INTEGER[];

BEGIN
    RETURN QUERY
		(WITH RECURSIVE my_tree2(lit_relationship_id, from_lit_id, to_lit_id, lit_family_id, lit_relationship_type, path_step, viewed_lits) AS
			(SELECT lit_relationships.id,
                    lit_relationships.from_lit_id,
                    lit_relationships.to_lit_id,
                    lit_relationships.lit_family_id,
                    lit_relationships.lit_relationship_type_id,
                    1 					AS path_step,
                    ARRAY[]::INTEGER[]	AS viewed_lits
			 FROM core.lit_relationships
			 WHERE lit_relationships.from_lit_id = ANY(p_start_lits)
                 AND lit_relationships.to_lit_id IN (SELECT lits.id
									                 FROM core.lits
									                 INNER JOIN core.lit_parties lp ON lits.id = lp.lit_id
									                 INNER JOIN core.aliases     al ON lp.alias_id = al.id
									                 WHERE al.ent_id = ANY (p_ent_id_list))
		   UNION
			 SELECT lr.id, lr.from_lit_id, lr.to_lit_id, lr.lit_family_id, lr.lit_relationship_type_id, mt2.path_step + 1, array_append(mt2.viewed_lits, lr.from_lit_id) AS viewed_lits
			 FROM core.lit_relationships lr
			 INNER JOIN my_tree2                     mt2 ON mt2.to_lit_id = lr.from_lit_id
			 WHERE lr.to_lit_id IN (SELECT lits.id
									FROM core.lits
									INNER JOIN core.lit_parties lp ON lits.id = lp.lit_id
									INNER JOIN core.aliases     al ON lp.alias_id = al.id
									WHERE al.ent_id = ANY (p_ent_id_list))
                 AND lr.to_lit_id != ALL (mt2.viewed_lits)
                 AND lr.to_lit_id != lr.from_lit_id
			)
			SELECT mt2.lit_relationship_id, mt2.from_lit_id, mt2.to_lit_id, mt2.lit_family_id, mt2.lit_relationship_type, mt2.path_step
			FROM my_tree2 mt2)
			;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core.trace_lit_family_forward] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core.trace_lit_family_forward] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
    WHEN OTHERS THEN
        RAISE;

END;
$$;


--
-- Name: update_alias_ent_details_alias_role(integer, integer[]); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION update_alias_ent_details_alias_role(p_alias_id integer, p_alias_roles integer[]) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_count int := 0;
BEGIN
/*
	2.0 15-Aug-2017 anarayanan DS-5724: Updated the api to just update the alias_roles

******
	select core.update_alias_ent_details_alias_role(4717161,array[21,23,34]);
	select core.update_alias_ent_details_alias_role(4717161,null::int[]);
*/
  UPDATE core.alias_ent_details aed
    SET alias_roles = p_alias_roles
  WHERE aed.alias_id = p_alias_id;

  RETURN 1;
END;
$$;


--
-- Name: update_alias_ent_details_alias_role(character varying, character varying, integer, character varying, character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION update_alias_ent_details_alias_role(p_table_name character varying, p_alias_id_col character varying, p_alias_id_val integer, p_action character varying, p_role_name character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_count int := 0;
BEGIN
  IF p_action = 'I' THEN
     update core.alias_ent_details a set alias_roles = array_append(alias_roles, t.id)
     from (select id from core.alias_roles where name = p_role_name) t
     where a.alias_id = p_alias_id_val and (NOT (ARRAY[t.id] && alias_roles) OR alias_roles is NULL);
  END IF;

  IF p_action = 'D' THEN
    execute 'select count(*) from ' || p_table_name || ' where ' || p_alias_id_col || ' = ' || p_alias_id_val into v_count;
    if v_count = 0 then
     update core.alias_ent_details a set alias_roles = array_remove(alias_roles, t.id)
     from (select id from core.alias_roles where name = p_role_name) t
     where a.alias_id = p_alias_id_val and ARRAY[t.id] && alias_roles;
    end if;
  END IF;
  RETURN 1;
END;
$$;


--
-- Name: update_alias_role(character varying, character varying, integer, character varying, character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION update_alias_role(p_table_name character varying, p_alias_id_col character varying, p_alias_id_val integer, p_action character varying, p_role_name character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_count int := 0;
 v_new_roles integer[];
 i_role_id int;
 t_sql_filter text;
BEGIN
/*
	2.0 anarayanan	09-Aug-2017	DS-5724: Latest updates are not visible causing roles not to be computed properly
******************
	select core.update_alias_role('core.lit_parties','alias_id',2314713,'D','district_court_party');
	select core.update_alias_role('core.lit_parties','alias_id',2314713,'I','district_court_party');
	select core.update_alias_role('core.assignors_aliases_map','alias_id',4717161,'I','patent_assignor');
	select core.update_alias_role('core.assignors_aliases_map','alias_id',4717161,'D','patent_assignor');
*/

	SELECT ID, sql_filter INTO i_role_id,t_sql_filter FROM core.alias_roles WHERE name = p_role_name;

	IF p_action = 'I' THEN
		select array_append(alias_roles, i_role_id) into v_new_roles
		from
		core.alias_ent_details a
		where a.alias_id = p_alias_id_val and (NOT (ARRAY[i_role_id] && alias_roles) OR alias_roles is NULL);
	END IF;

	IF p_action = 'D' THEN
		execute
			'select 1 from ' ||
			 p_table_name ||
			 ' where ' || p_alias_id_col || ' = ' || p_alias_id_val ||
			 COALESCE(t_sql_filter,'') ||
			 ' limit 1'
			 into v_count;
		if COALESCE(v_count,0) = 0 then
			select array_remove(alias_roles, i_role_id) into v_new_roles
			from
			core.alias_ent_details a
		 	where a.alias_id = p_alias_id_val and ARRAY[i_role_id] && alias_roles;
		end if;
	END IF;

	select x into v_count
	from public.dblink( config.dblink_connection('coredb'), 'SELECT core.update_alias_ent_details_alias_role(p_alias_id:=''' || p_alias_id_val || ''',p_alias_roles:=''' || v_new_roles::text || ''');')
	as temp(x int);

  RETURN 1;
END;
$$;


--
-- Name: update_docket_entry(integer, integer, text, text, boolean, integer[], integer[], integer, integer, character varying, text); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION update_docket_entry(p_docket_entry_id integer, p_row_number integer, p_docket_text text, p_original_docket_text text, p_is_mixed_action boolean, p_old_document_ids integer[], p_new_document_ids integer[], p_old_main_document_id integer, p_new_main_document_id integer, p_category character varying, p_event text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_orphan_candidates INT[];
 v_old_original_docket_text TEXT;
 v_entry_number INTEGER;
 v_date_filed DATE;
 v_lit_id INTEGER;
BEGIN

 ---gather old information so we use them for orphaned documents
 SELECT lit_id, date_filed, entry_number, original_docket_text
 INTO v_lit_id, v_date_filed, v_entry_number, v_old_original_docket_text
 FROM core.docket_entries
 WHERE id = p_docket_entry_id;

 ----update docket
 ----logic for is_mixed_action is the same as insert procedure
 UPDATE core.docket_entries
 SET
   docket_text = p_docket_text,
   original_docket_text = p_original_docket_text,
   row_number = p_row_number,
   is_mixed_action = p_is_mixed_action,
   category = p_category,
   event = p_event
 WHERE id = p_docket_entry_id;

 ---if main document changes, the we delete/insert
 ---Assume main document won't change very much.
 ---delete/insert can simplify logic
 IF coalesce(p_old_main_document_id, -1) <> coalesce(p_new_main_document_id, -1) THEN
  IF p_old_main_document_id is not NULL THEN
    DELETE FROM core.docket_entry_documents_map
    WHERE docket_entry_id = p_docket_entry_id AND
          is_main = true;
    v_orphan_candidates := v_orphan_candidates || p_old_main_document_id;
  END IF;
  IF p_new_main_document_id is not NULL THEN
    INSERT INTO core.docket_entry_documents_map
    (docket_entry_id, lit_document_id, is_main)
    VALUES
    (p_docket_entry_id, p_new_main_document_id, true);
  END IF;
 END IF;

 ----remove old documents
 DELETE FROM core.docket_entry_documents_map
 WHERE docket_entry_id = p_docket_entry_id AND
       lit_document_id in (
         SELECT UNNEST(p_old_document_ids) as id
         EXCEPT
         SELECT UNNEST(p_new_document_ids) as id
       ) AND
       is_main = false;

 ---insert new ones
 INSERT into core.docket_entry_documents_map
 (docket_entry_id, lit_document_id, is_main)
 SELECT distinct p_docket_entry_id, lit_document_id, false
 FROM (
         SELECT UNNEST(p_new_document_ids) as lit_document_id
         EXCEPT
         SELECT UNNEST(p_old_document_ids) as lit_document_id
 ) t;
 ----make input for handle_orphan_documents function
 v_orphan_candidates := v_orphan_candidates || (SELECT ARRAY_AGG(document_id) from (SELECT UNNEST(p_old_document_ids) as document_id EXCEPT SELECT UNNEST(p_new_document_ids) as document_Id) t)::INT[];

 ---handle orphan documents
 PERFORM core.handle_orphan_documents(
   v_orphan_candidates,
   v_lit_id,
   v_entry_number,
   v_date_filed,
   v_old_original_docket_text
 );

 RETURN p_docket_entry_id;
END;
$$;


--
-- Name: update_docket_entry_main_document(integer, integer, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION update_docket_entry_main_document(p_docket_entry_id integer, p_old_main_document_id integer, p_new_main_document_id integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_orphan_candidates INT[];
 v_old_original_docket_text TEXT;
 v_entry_number INTEGER;
 v_date_filed DATE;
 v_lit_id INTEGER;
BEGIN
 ---gather old information so we use them for orphaned documents
 SELECT lit_id, date_filed, entry_number, original_docket_text
 INTO v_lit_id, v_date_filed, v_entry_number, v_old_original_docket_text
 FROM core.docket_entries
 WHERE id = p_docket_entry_id;

 ---if main document changes, the we delete/insert
 ---Assume main document won't change very much.
 ---delete/insert can simplify logic
 IF coalesce(p_old_main_document_id, -1) <> coalesce(p_new_main_document_id, -1) THEN
  IF p_old_main_document_id is not NULL THEN
    DELETE FROM core.docket_entry_documents_map
    WHERE docket_entry_id = p_docket_entry_id AND
          is_main = true;
    v_orphan_candidates := v_orphan_candidates || p_old_main_document_id;
  END IF;
  IF p_new_main_document_id is not NULL THEN
    INSERT INTO core.docket_entry_documents_map
    (docket_entry_id, lit_document_id, is_main)
    VALUES
    (p_docket_entry_id, p_new_main_document_id, true);
  END IF;
 END IF;

 ---handle orphan documents
 PERFORM core.handle_orphan_documents(
   v_orphan_candidates,
   v_lit_id,
   v_entry_number,
   v_date_filed,
   v_old_original_docket_text
 );

 RETURN p_docket_entry_id;
END;
$$;


--
-- Name: update_docket_entry_non_main_documents(integer, integer[], integer[]); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION update_docket_entry_non_main_documents(p_docket_entry_id integer, p_old_document_ids integer[], p_new_document_ids integer[]) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_orphan_candidates INT[];
 v_old_original_docket_text TEXT;
 v_entry_number INTEGER;
 v_date_filed DATE;
 v_lit_id INTEGER;
 RD RECORD;
BEGIN
 ---gather old information so we use them for orphaned documents
 SELECT lit_id, date_filed, entry_number, original_docket_text
 INTO v_lit_id, v_date_filed, v_entry_number, v_old_original_docket_text
 FROM core.docket_entries
 WHERE id = p_docket_entry_id;

 FOR RD IN (
   SELECT old_id, new_id
   FROM (SELECT UNNEST(p_old_document_ids) as old_id) t1
         FULL OUTER JOIN
        (SELECT UNNEST(p_new_document_ids) as new_id) t2
   ON t1.old_id = t2.new_id
 ) LOOP

   ---if main document changes, the we delete/insert
   ---Assume main document won't change very much.
   ---delete/insert can simplify logic
   IF RD.new_id is NULL THEN
      DELETE FROM core.docket_entry_documents_map
      WHERE docket_entry_id = p_docket_entry_id AND
            is_main = false AND
            lit_document_id = RD.old_id;
      v_orphan_candidates := v_orphan_candidates || RD.old_id;
   END IF;

   IF RD.old_id is NULL THEN
      INSERT INTO core.docket_entry_documents_map
      (docket_entry_id, lit_document_id, is_main)
      VALUES
      (p_docket_entry_id, RD.new_id, false);
   END IF;

 END LOOP;

 ---handle orphan documents
 PERFORM core.handle_orphan_documents(
   v_orphan_candidates,
   v_lit_id,
   v_entry_number,
   v_date_filed,
   v_old_original_docket_text
 );

 RETURN p_docket_entry_id;
END;
$$;


--
-- Name: update_docket_entry_rownum(integer, integer); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION update_docket_entry_rownum(p_docket_entry_id integer, p_row_number integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
 ----update docket rownum only
 UPDATE core.docket_entries
 SET
   row_number = p_row_number
 WHERE id = p_docket_entry_id;

 RETURN p_docket_entry_id;
END;
$$;


--
-- Name: update_ent_advanced_relationship_types(integer, character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION update_ent_advanced_relationship_types(p_ent_advanced_relationship_types_id integer, p_name character varying DEFAULT NULL::character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
updated_rows INTEGER := 0 ;
BEGIN
/*
1.0 2015-02-06 user DS-809: New Function Created by core.generate_dml_func
*/
UPDATE core.ent_advanced_relationship_types
SET NAME = p_name
WHERE
ID = p_ent_advanced_relationship_types_id ;

GET DIAGNOSTICS updated_rows = ROW_COUNT ;
IF updated_rows > 0 THEN
RETURN p_ent_advanced_relationship_types_id ;
ELSE
RETURN - 1 ;
END IF ;

EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE '% %',SQLSTATE, sqlerrm ;
RETURN - 1 ;
END ;
$$;


--
-- Name: update_ent_advanced_relationships_table(integer, integer, integer, date, date, text, text, character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION update_ent_advanced_relationships_table(p_ent_id integer DEFAULT NULL::integer, p_ent_advanced_relationship_type_id integer DEFAULT NULL::integer, p_related_ent_id integer DEFAULT NULL::integer, u_start_date date DEFAULT NULL::date, u_end_date date DEFAULT NULL::date, u_description text DEFAULT NULL::text, u_title text DEFAULT NULL::text, u_updated_by character varying DEFAULT "current_user"()) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  updated_rows integer :=0;
BEGIN
  /*
  1.0 2015-08-26 user DS-809: New Function Created by core.generate_dml_func_v2
  */

  IF COALESCE(p_ent_id,p_ent_advanced_relationship_type_id,p_related_ent_id) IS NULL THEN
    RAISE EXCEPTION 'Need atleast one input parameter p_ent_id/p_ent_advanced_relationship_type_id/p_related_ent_id to execute this function';
  ELSE

    UPDATE core.ent_advanced_relationships
      SET
      start_date  = coalesce(u_start_date,start_date),
      end_date  = coalesce(u_end_date,end_date),
      description = coalesce(u_description,description),
      title     = coalesce(u_title,title),
      updated_by  =   CASE WHEN updated_by=u_updated_by THEN updated_by ELSE u_updated_by END
      WHERE   CASE WHEN p_ent_id IS NULL THEN TRUE ELSE ent_id = p_ent_id END AND
          CASE WHEN p_ent_advanced_relationship_type_id IS NULL THEN TRUE ELSE ent_advanced_relationship_type_id = p_ent_advanced_relationship_type_id END AND
          CASE WHEN p_related_ent_id IS NULL THEN TRUE ELSE related_ent_id = p_related_ent_id END;

    GET DIAGNOSTICS updated_rows = ROW_COUNT;

    IF updated_rows > 0 THEN
      RETURN 1;
    ELSE
      RETURN -1;
    END IF;

  END IF;

  EXCEPTION
    WHEN OTHERS THEN
      RAISE NOTICE '% %', sqlstate, sqlerrm;
  RETURN -1;
END;
$$;


--
-- Name: update_ent_relationships_table(integer, integer, integer, date, date, character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION update_ent_relationships_table(p_ent_id integer DEFAULT NULL::integer, p_ent_relationship_type_id integer DEFAULT NULL::integer, p_related_ent_id integer DEFAULT NULL::integer, u_start_date date DEFAULT NULL::date, u_end_date date DEFAULT NULL::date, u_updated_by character varying DEFAULT "current_user"()) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  updated_rows integer :=0;
BEGIN
  /*
  1.0 2015-08-26 user DS-809: New Function Created by core.generate_dml_func_v2
  */
  IF COALESCE(p_ent_id,p_ent_relationship_type_id,p_related_ent_id) IS NULL THEN
    RAISE EXCEPTION 'Need atleast one input parameter p_ent_id/p_ent_relationship_type_id/p_related_ent_id to execute this function';
  ELSE
    UPDATE core.ent_relationships
      SET
      start_date  =   coalesce(u_start_date,start_date),
      end_date  = coalesce(u_end_date,end_date),
      updated_by  =   CASE WHEN SUBSTRING(u_updated_by FROM 1 FOR 1) = '~' THEN
                  SUBSTRING(u_updated_by FROM 2 FOR (LENGTH(u_updated_by)-1))
              ELSE
                  u_updated_by
              END
      WHERE   CASE WHEN p_ent_id IS NULL THEN TRUE ELSE ent_id = p_ent_id END AND
          CASE WHEN p_ent_relationship_type_id IS NULL THEN TRUE ELSE ent_relationship_type_id = p_ent_relationship_type_id END AND
          CASE WHEN p_related_ent_id IS NULL THEN TRUE ELSE related_ent_id = p_related_ent_id END;

    GET DIAGNOSTICS updated_rows = ROW_COUNT;

    IF updated_rows >0 THEN
      RETURN 1;
    ELSE
      RETURN -1;
    END IF;

  END IF;

  EXCEPTION
    WHEN OTHERS THEN
    RAISE NOTICE '% %', sqlstate, sqlerrm;
  RETURN -1;
END;
$$;


--
-- Name: update_ent_subtypes_map(integer, integer, date, date); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION update_ent_subtypes_map(p_ent_subtypes_map_id integer, p_ent_subtype_id integer DEFAULT NULL::integer, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
updated_rows INTEGER := 0 ;
BEGIN
/*
1.0 aprakash_c 13-FEB-2015 DS-809: New Function Created
*/
UPDATE core.ent_subtypes_map
SET ent_subtype_id = COALESCE (p_ent_subtype_id, ent_subtype_id),
start_date = COALESCE (p_start_date, start_date),
end_date = COALESCE (p_end_date, end_date)
WHERE
ID = p_ent_subtypes_map_id ;

GET DIAGNOSTICS updated_rows = ROW_COUNT ;
IF updated_rows > 0 THEN
RETURN p_ent_subtypes_map_id ;
ELSE
RETURN - 1 ;
END IF ;

EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE '% %',SQLSTATE, sqlerrm ;
RETURN - 1 ;
END ;
$$;


--
-- Name: update_ent_types(integer, character varying, boolean); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION update_ent_types(p_ent_types_id integer, p_name character varying DEFAULT NULL::character varying, p_is_default boolean DEFAULT NULL::boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
updated_rows INTEGER := 0 ;
BEGIN
/*
1.0 2015-02-06 user DS-809: New Function Created by core.generate_dml_func
*/
UPDATE core.ent_types
SET name = COALESCE (p_name, name),
is_default = COALESCE (p_is_default, is_default)
WHERE
ID = p_ent_types_id ;

GET DIAGNOSTICS updated_rows = ROW_COUNT ;
IF updated_rows > 0 THEN
RETURN p_ent_types_id ;
ELSE
RETURN - 1 ;
END IF ;

EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE '% %',SQLSTATE, sqlerrm ;
RETURN - 1 ;
END ;
$$;


--
-- Name: update_lit_court(integer, date, date); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION update_lit_court(p_lit_court_id integer, p_start_date date, p_end_date date) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_lit_court_id INTEGER := NULL;
BEGIN

 SELECT id
 INTO v_lit_court_id
 FROM core.lit_courts
 WHERE id = p_lit_court_id AND
       coalesce(start_date, '1970-01-01') = coalesce(p_start_date, '1970-01-01') AND
       coalesce(end_date, '3001-01-01') = coalesce(p_end_date, '3001-01-01');

 ---No changes, then return id
 IF v_lit_court_id is not NULL THEN
  RETURN v_lit_court_id;
 END IF;


 UPDATE core.lit_courts
 SET
    start_date = COALESCE(p_start_date, start_date),
    end_date = p_end_date,
    updated_at = now()
 WHERE id = p_lit_court_id;

 RETURN p_lit_court_id;
END;
$$;


--
-- Name: update_timestamp(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION update_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at := current_timestamp;
    RETURN NEW;
END;
$$;


--
-- Name: update_updated_by(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION update_updated_by() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
IF (NEW.updated_by IS NULL) THEN
NEW.updated_by := current_user;
ELSE IF (NEW.updated_by = OLD.updated_by) THEN
NEW.updated_by = '~'||OLD.updated_by;
 END IF;
END IF;
    RETURN NEW;
END;
$$;


--
-- Name: update_user(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION update_user() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
IF (NEW.updated_by = OLD.updated_by) THEN
NEW.updated_by = current_user;
ELSE IF (SUBSTRING(NEW.updated_by FROM 1 FOR 1) = '~') THEN
NEW.updated_by := SUBSTRING(NEW.updated_by FROM 2 FOR (LENGTH(NEW.updated_by)-1));
 END IF;
END IF;
    RETURN NEW;
END;
$$;


--
-- Name: updated_columns(text, date); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION updated_columns(p_table_name text, p_date_changed date) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
declare
  v_sql varchar := '';
  v_col_name text;
  v_count integer;
begin

raise notice 'DELETE: ';
for v_col_name in
  select column_name
  from information_schema.columns
  where table_name = p_table_name and table_schema = 'core_audit'
  and substr(column_name, 1, 2) = '__'
loop
  v_sql := '
   select count(*)
   from core_audit.' || p_table_name || '
   where created_at::DATE = ''' || p_date_changed || '''::DATE
   and ' || v_col_name || '= TRUE
   and action = ''D'';';
  execute v_sql into v_count;
  --raise notice 'Column: %', v_col_name;
  --raise notice 'SQL: %', v_sql;
  if (v_count > 0) then
    raise notice 'Column % updated % times.', v_col_name, v_count;
  end if;
end loop;

raise notice 'INSERT: ';
for v_col_name in
  select column_name
  from information_schema.columns
  where table_name = p_table_name and table_schema = 'core_audit'
  and substr(column_name, 1, 2) = '__'
loop
  v_sql := '
   select count(*)
   from core_audit.' || p_table_name || '
   where created_at::DATE = ''' || p_date_changed || '''::DATE
   and ' || v_col_name || '= TRUE
   and action = ''I'';';
  execute v_sql into v_count;
  --raise notice 'Column: %', v_col_name;
  --raise notice 'SQL: %', v_sql;
  if (v_count > 0) then
    raise notice 'Column % updated % times.', v_col_name, v_count;
  end if;
end loop;

raise notice 'UPDATE: ';
for v_col_name in
  select column_name
  from information_schema.columns
  where table_name = p_table_name and table_schema = 'core_audit'
  and substr(column_name, 1, 2) = '__'
loop
  v_sql := '
   select count(*)
   from core_audit.' || p_table_name || '
   where created_at::DATE = ''' || p_date_changed || '''::DATE
   and ' || v_col_name || '= TRUE
   and action = ''U'';';
  execute v_sql into v_count;
  --raise notice 'Column: %', v_col_name;
  --raise notice 'SQL: %', v_sql;
  if (v_count > 0) then
    raise notice 'Column % updated % times.', v_col_name, v_count;
  end if;
end loop;

return 'Done.';
end;
$$;


--
-- Name: upsert_lit_pat_map(integer, character varying); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION upsert_lit_pat_map(arg_lit_id integer, arg_patnum character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
   c_select_lit_pat CURSOR (
       seek_lit_id INTEGER,
       seek_patnum VARCHAR
   ) IS
       SELECT lit_id FROM core.lits_pats_map WHERE lit_id = seek_lit_id AND patnum = seek_patnum
   ;
BEGIN
    OPEN  c_select_lit_pat(arg_lit_id, arg_patnum);
    MOVE FORWARD IN c_select_lit_pat;
    CLOSE c_select_lit_pat;

    IF NOT FOUND THEN
        INSERT INTO core.lits_pats_map (
            lit_id,
            patnum
        )
        VALUES (
            arg_lit_id,
            arg_patnum
        );
    END IF;
END;
$$;


--
-- Name: uspto_practitioner_roster_alias_role_trig_func(); Type: FUNCTION; Schema: core; Owner: -
--

CREATE FUNCTION uspto_practitioner_roster_alias_role_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
/*
    1.0 anarayanan 03-Aug-2017 DS-5640: New trigger for alias_roles
*/
    IF (TG_OP = 'UPDATE') THEN
      IF (1 = 1) THEN
       IF (COALESCE(OLD.alias_id, -1) <> COALESCE(NEW.alias_id, -1)) OR ( COALESCE(OLD.role,'') <> COALESCE(NEW.role,'')) THEN
         IF OLD.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.uspto_practitioner_roster', 'alias_id', OLD.alias_id, 'D', case OLD.role when 'ATTORNEY' THEN 'uspto_registered_attorney' when 'AGENT' THEN 'uspto_registered_agent' END);
         END IF;
         IF NEW.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('core.uspto_practitioner_roster', 'alias_id', NEW.alias_id, 'I', case NEW.role when 'ATTORNEY' THEN 'uspto_registered_attorney' when 'AGENT' THEN 'uspto_registered_agent' END);
         END IF;
       END IF;
      END IF;
      RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('core.uspto_practitioner_roster', 'alias_id', OLD.alias_id, 'D', case OLD.role when 'ATTORNEY' THEN 'uspto_registered_attorney' when 'AGENT' THEN 'uspto_registered_agent' END);
        END IF;
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('core.uspto_practitioner_roster', 'alias_id', NEW.alias_id, 'I', case NEW.role when 'ATTORNEY' THEN 'uspto_registered_attorney' when 'AGENT' THEN 'uspto_registered_agent' END);
        END IF;
        RETURN NEW;
    ELSE
        RAISE EXCEPTION '[core..uspto_practitioner_roster_alias_role_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[core..uspto_practitioner_roster_alias_role_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[core..uspto_practitioner_roster_alias_role_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[core..uspto_practitioner_roster_alias_role_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


SET search_path = docdb, pg_catalog;

--
-- Name: build_constr_script(character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: docdb; Owner: -
--

CREATE FUNCTION build_constr_script(schema_name character varying, column_name character varying, idx_type character varying, not_in_table1 character varying, not_in_table2 character varying, not_in_table3 character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$DECLARE
    icount             INTEGER:=0;
    v_listing          RECORD; 
    v_result_string    varchar:=' '; 
    v_result_string2   varchar;  
    v_result         	varchar;
    v_result_num	int:=0;         	
BEGIN

-- example
-- select docdb.build_constr_script('docdb', 'pat_id', 'fk','docdb_logs','docdb_batch', 'docdb_pats');
				
for v_listing in (select distinct table_schema||'.'||table_name tname,table_name  from information_schema.tables  
                  where  table_schema =''||schema_name||''
                   and table_name not in ( ''||not_in_table1||'', ''||not_in_table2||'',''||not_in_table3||'')  ) loop

		BEGIN
			EXECUTE 'ALTER TABLE '||v_listing.tname||' ADD CONSTRAINT docdb_pats_'||v_listing.table_name||'_'||idx_type||'  FOREIGN KEY ('||column_name||') REFERENCES docdb.docdb_pats (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION;';

                    --   RAISE NOTICE 'Constraint added: [%]', 'docdb_pats_'||v_listing.table_name||'_'||idx_type;

		       v_result_string:=v_result_string||' Constraint added docdb_pats_'||v_listing.table_name||'_'||idx_type||' for table '||v_listing.tname||chr(10);

		EXCEPTION WHEN OTHERS THEN
		
			v_result_string:=v_result_string||' Constraint docdb_pats_'||v_listing.table_name||'_'||idx_type||' already EXISTS for table '||v_listing.tname||chr(10);
		END;
end loop;

return v_result_string;

end;$$;


--
-- Name: create_idx_script(character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: docdb; Owner: -
--

CREATE FUNCTION create_idx_script(schema_name character varying, column_name character varying, idx_type character varying, not_in_table1 character varying, not_in_table2 character varying, not_in_table3 character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$DECLARE
    icount             INTEGER:=0;
    v_listing          RECORD; 
    v_result_string    varchar:=' '; 
    v_result_string2   varchar;  
    v_result         	varchar;
    v_result_num	int:=0;         	
BEGIN

-- example
-- select docdb.create_idx_script('docdb_intake', 'rec_status', 'idx','docdb_logs','docdb_batch', 'bla');
--select docdb.create_idx_script('docdb_intake', 'pat_id', 'fkey','docdb_logs','docdb_batch', 'docdb_pats');
				
for v_listing in (select distinct table_schema||'.'||table_name tname,table_name  from information_schema.tables  
                  where  table_schema =''||schema_name||''
                   and table_name not in ( ''||not_in_table1||'', ''||not_in_table2||'',''||not_in_table3||'')  ) loop
					

		BEGIN
			--EXECUTE 'select max(id) from '||v_listing.tname||' ' into v_result_num;
			if idx_type = 'idx' then
				EXECUTE 'CREATE INDEX '||v_listing.table_name||'_'||column_name||'_'||idx_type||' ON '||v_listing.tname||'  USING btree ('||column_name||' )';
			else
				EXECUTE 'CREATE INDEX '||v_listing.table_name||'_'||idx_type||'_'||column_name||' ON '||v_listing.tname||'  USING btree ('||column_name||' )';
			end if;
			
                       RAISE NOTICE 'Created index for: [%]', v_listing.table_name||'_'||idx_type||'_'||column_name;

		       v_result_string:=v_result_string||' Created '||v_listing.table_name||'_'||idx_type||'_'||column_name||' for table '||v_listing.tname||chr(10);

		EXCEPTION WHEN OTHERS THEN
		
			v_result_string:=v_result_string||' Index '||v_listing.table_name||'_'||idx_type||'_'||column_name||' already EXISTS for table '||v_listing.tname||chr(10);
		END;
end loop;

return v_result_string;

end;$$;


--
-- Name: create_seq_script(character varying, character varying, character varying); Type: FUNCTION; Schema: docdb; Owner: -
--

CREATE FUNCTION create_seq_script(schema_name character varying, param1_in character varying, param2_in character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$DECLARE
    icount             INTEGER:=0;
    v_listing          RECORD; 
    v_result_string    varchar:=' '; 
    v_result_string2   varchar;  
    v_result         	varchar;
    v_result_num	int8:=0;  
    v_table_name       varchar:=''; 	
BEGIN
-- select docdb.create_seq_script('docdb_l','docdb_logs','docdb_batch');
--first param is schema, 2 other ones for the tables you don't want to apply seq for
for v_listing in (select distinct table_schema||'.'||table_name tname,table_name  from information_schema.tables  
                  where  table_schema =''||schema_name||''
                   and table_name not in ( ''||param1_in||'',''||param2_in||'')  ) loop
                   
		RAISE NOTICE 'v_listing: [%]', v_listing.tname;			

		BEGIN
			EXECUTE 'select max(id) from '||v_listing.tname||' ' into v_result_num;

			RAISE NOTICE 'v_result_num: [%]', v_result_num;

			v_table_name:= v_listing.tname;

			if v_result_num < 90000000000  then -- for child tables

				if v_listing.table_name = 'docdb_pats' then
					EXECUTE 'CREATE SEQUENCE '||v_listing.tname||'_id_seq START 900000000 ';	
				else
					EXECUTE 'CREATE SEQUENCE '||v_listing.tname||'_id_seq START 90000000000 ';	
				end if;
				EXECUTE 'ALTER TABLE '||v_listing.tname||' ALTER COLUMN id SET DEFAULT NEXTVAL('''||v_listing.tname||'_id_seq''); '; 
				v_result_string:=v_result_string||' Created seq for table '||v_listing.tname||chr(10);
			else
				v_result_string:=v_result_string||' max(id) for table '||v_listing.tname||' exceed 90,000,000,000 - please review' ||chr(10);
			end if;

		EXCEPTION WHEN OTHERS THEN
                       /*
			if v_result_num < 900000000  then -- for child tables

				if v_listing.table_name = 'docdb_pats' then
				
					EXECUTE 'ALTER SEQUENCE '||v_listing.tname||'_id_seq RESTART WITH 900000000 ';
				else				
					EXECUTE 'ALTER SEQUENCE '||v_listing.tname||'_id_seq RESTART WITH 90000000000 ';
				end if;			
				EXECUTE 'ALTER TABLE '||v_listing.tname||' ALTER COLUMN id SET DEFAULT NEXTVAL('''||v_listing.tname||'_id_seq''); ';
			
				v_result_string:=v_result_string||' RESTARTED seq '||v_listing.tname||'_id_seq WITH 9000,000,000  for table '||v_listing.tname||chr(10);
			else
				v_result_string:=v_result_string||' Seq for table '||v_listing.tname||' already exists and exceed 900,000,000 - please review' ||chr(10);
			end if;
			*/
			if v_result_num < 90000000000  then -- for child tables

				if v_table_name = 'docdb.docdb_pats' then
				
					EXECUTE 'ALTER SEQUENCE '||v_table_name||'_id_seq RESTART WITH 900000000 ';
				else				
					EXECUTE 'ALTER SEQUENCE '||v_table_name||'_id_seq RESTART WITH 90000000000 ';
				end if;			
				EXECUTE 'ALTER TABLE '||v_table_name||' ALTER COLUMN id SET DEFAULT NEXTVAL('''||v_table_name||'_id_seq''); ';
			
				v_result_string:=v_result_string||' RESTARTED seq '||v_table_name||'_id_seq WITH 90,000,000,000  for table '||v_table_name||chr(10);
			else
				v_result_string:=v_result_string||' Seq for table '||v_table_name||' already exists and exceed 90,000,000,000 - please review' ||chr(10);
			end if;
			
		END;
end loop;

return v_result_string;

end;$$;


--
-- Name: debug(text, integer); Type: FUNCTION; Schema: docdb; Owner: -
--

CREATE FUNCTION debug(p_message text, p_run_id integer DEFAULT 0) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
 PERFORM logging.debug('docdb', 'log_data', p_message, 1, 'docdb', coalesce(p_run_id, 0));
 RETURN 1;
END;
$$;


--
-- Name: docdb_amend(bigint, bigint, bigint); Type: FUNCTION; Schema: docdb; Owner: -
--

CREATE FUNCTION docdb_amend(low_in bigint, high_in bigint, batch_num bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$DECLARE
    icount     INT8:=0;
    v_count    INT8:=0;
    v_batch    text;
    v_run_id	int8:=0;
    v_not_exist integer:=0;
    v_not_exist_text text;
BEGIN
/*
1.0 26-Sep-2014 anarayanan DS-467: Set pat_family_processed flag
2.0 28-Apr-2015 tazhagan_c DS-1625 : Added debug statements to log the progress 
*/
select distinct run_id into v_run_id 
from docdb.docdb_batch 
where id=batch_num;
--RAISE NOTICE 'v_run_id: [%]', v_run_id;

v_batch := 'Batch#: '||batch_num::text||' Range ['||low_in::text||'-'||high_in::text||'] ';

  select count(d.patnum) into v_not_exist
  from docdb_intake.docdb_pats d 
  left outer join docdb.docdb_pats l
  on l.patnum=d.patnum
  where l.patnum is null
  and rec_status='A'
  and d.id >= low_in and d.id < high_in;

  if v_not_exist > 0 then
	  select array_to_string(array_agg(d.patnum),',')  into v_not_exist_text
	  from docdb_intake.docdb_pats d 
	  left outer join docdb.docdb_pats l
	  on l.patnum=d.patnum
	  where l.patnum is null
	  and rec_status='A'
	  and d.id >= low_in and d.id < high_in;


	  PERFORM docdb.debug('In docdb_amend - Updating docdb_intake.docdb_pats.rec_status=C as patents dont exists in target table for range v_low_in:'||low_in||' v_high_in:'||high_in);     

	  update docdb_intake.docdb_pats 
	  set rec_status='C', updated_at=now() 
	  where patnum in (select d.patnum  --into v_not_exist_text
	  from docdb_intake.docdb_pats d 
	  left outer join docdb.docdb_pats l
	  on l.patnum=d.patnum
	  where l.patnum is null
	  and rec_status='A'
	  and d.id >= low_in and d.id < high_in);

	  insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
	  values( batch_num,'docdb.docdb_amend',v_not_exist_text,'patents not exists in the target table, changing status to C',v_not_exist,'A',now());

        --  raise exception '-->Docdb_amend function. Following patents exists in intake with status = A but not exist in the target docdb % %: ',v_not_exist_text, batch_num using errcode = 10001;	  
  end if;
  --else
  
  		PERFORM docdb.debug('In docdb_amend - Amend docdb.docdb_pats for range v_low_in:'||low_in||' v_high_in:'||high_in);     
	       -- docdb_pats table
		update docdb.docdb_pats m 
		set       is_representative = d.is_representative,
			-- date_of_last_exchange = d.date_of_last_exchange,
			  date_of_last_exchange = case when d.date_of_last_exchange = '' then null else to_date(d.date_of_last_exchange,'YYYYMMDD') end, 
			-- date_of_previous_exchange = d.date_of_previous_exchange,
			  date_of_previous_exchange = case when d.date_of_previous_exchange= '' then null else to_date(d.date_of_previous_exchange,'YYYYMMDD') end,
			--  date_added_docdb = d.date_added_docdb,
			  date_added_docdb =  case when d.date_added_docdb = '' then null else  to_date(d.date_added_docdb,'YYYYMMDD') end, 
			  originating_office = d.originating_office,
			  status = d.status,
			  filedate = d.filedate,
			 -- issue_date = d.issue_date,
			  issue_date = case when d.issue_date = '' then null else to_date(d.issue_date,'YYYYMMDD') end,
			  title = d.title,
			  title_lang = d.title_lang,
			  family_id = d.family_id,
			  doc_number = d.stripped_patnum,
			  stripped_patnum = (case when d.country_code = 'US' then regexp_replace(d.stripped_patnum, '(^\d\d\d\d)(\d\d\d\d\d\d$)', '\10\2') else d.stripped_patnum end),
			  extended_kind_code = d.extended_kind_code,
			  app_num_intl = d.app_num_intl,
			  app_num_country = d.app_num_country,
			--  app_date = d.app_date,
			  app_date = case when d.app_date ='' then null else to_date(d.app_date,'YYYYMMDD') end, 
			  lang_of_publication = d.lang_of_publication,
			  lang_of_filing = d.lang_of_filing,
			  doc_kind_code = d.doc_kind_code,
			  publication_number = d.publication_number,
			--  publication_date = d.publication_date,
			  publication_date =  case when d.publication_date ='' then null else  to_date(d.publication_date,'YYYYMMDD') end, 
			  app_is_representative = d.app_is_representative,
			  app_kind_code = d.app_kind_code,
			  date_of_coming_into_force = d.date_of_coming_into_force,
			--  date_of_coming_into_force = case when d.date_of_coming_into_force = '' then null else to_date(d.date_of_coming_into_force,'YYYYMMDD') end,
			--  preceding_publication_date = d.preceding_publication_date,
			  preceding_publication_date = case when d.preceding_publication_date = '' then null else to_date(d.preceding_publication_date,'YYYYMMDD') end, 
			  previously_filed_app = d.previously_filed_app,
			  country_code = d.country_code,
			--  public_availability_date = d.public_availability_date,
			  public_availability_date = case when d.public_availability_date = '' then null else to_date(d.public_availability_date,'YYYYMMDD') end, 
			  public_availability_category = d.public_availability_category,
                         publication_date_history = d.publication_date_history,
			  batch_id = batch_num,
			  run_id=v_run_id,
			  pat_family_processed = (case when 
											m.app_num_intl != d.app_num_intl OR 
											m.app_date::date != to_date(d.app_date,'YYYYMMDD') OR 
											m.country_code != d.country_code OR 
											m.app_num_country != d.app_num_country 
											then
				                                false
											else
											    pat_family_processed
				                    	end),			  
			  updated_at=now()
		
		from docdb_intake.docdb_pats d 
		where d.id >= low_in and d.id < high_in
		and m.patnum=d.patnum and d.rec_status='A';

		GET DIAGNOSTICS icount = ROW_COUNT;

		insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
		values( batch_num,'docdb.docdb_amend','Amended','docdb_pats',icount,'A',now());

		-- Amended records first	         

		PERFORM docdb.debug('In docdb_amend - Create temp table ipcs_status_a for range v_low_in:'||low_in||' v_high_in:'||high_in);     

	       --drop table ipcs_status_a
                EXECUTE 'DROP TABLE IF EXISTS ipcs_status_a;';
		create temp table ipcs_status_a as
		select pat_id, max(docdb_ipcs.rec_status) from docdb_intake.docdb_ipcs 
		group by pat_id, docdb_ipcs.rec_status having docdb_ipcs.rec_status='A';  


		PERFORM docdb.debug('In docdb_amend - Amend docdb.docdb_ipcs for range v_low_in:'||low_in||' v_high_in:'||high_in);     

		with upsert as (
				delete from ipcs_status_a
				returning *		
			
		), delete_ipcs as (
				DELETE FROM docdb.docdb_ipcs d
				where d.pat_id in (
				select r.id from docdb.docdb_pats r
				join docdb_intake.docdb_pats in1 on in1.patnum=r.patnum
				join ipcs_status_a t on in1.id=t.pat_id
				where in1.rec_status='A'
				--AND r.id >= low_in and r.id < high_in
				AND in1.id >= low_in and in1.id < high_in
				)
		), ipcs_insert as (
				insert into docdb.docdb_ipcs (pat_id,sequence,ipc_ipcr_text,type,edition,batch_id,run_id,created_at,updated_at)
				select t.id,in1.sequence, in1.ipc_ipcr_text,in1.type,in1.edition,batch_num,v_run_id,now(),now()
				from docdb_intake.docdb_ipcs in1 
				join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
				join docdb.docdb_pats t on in2.patnum=t.patnum
                               where in2.id >= low_in and in2.id < high_in
				and in2.id in (SELECT pat_id FROM upsert) 
				returning * )

		insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
		select batch_num,'docdb.docdb_amend','Amended(Deleted/Inserted)','docdb_ipcs',count(*),'A',now()
		from ipcs_insert; 				
				
--RAISE NOTICE 'Records deleted from  docdb_ipc, # =  [%]', v_count;

--RAISE NOTICE 'low_in: [%]', low_in;
--RAISE NOTICE 'high_in: [%]', high_in;
		
		PERFORM docdb.debug('In docdb_amend - Create temp table titles_status_a for range v_low_in:'||low_in||' v_high_in:'||high_in);     

        --drop table titles_status_a
                EXECUTE 'DROP TABLE IF EXISTS titles_status_a;';
		create temp table titles_status_a as
		select pat_id, max(docdb_titles.rec_status) from docdb_intake.docdb_titles 
		group by pat_id, docdb_titles.rec_status having docdb_titles.rec_status='A';  

		PERFORM docdb.debug('In docdb_amend - Amend docdb.docdb_titles for range v_low_in:'||low_in||' v_high_in:'||high_in);     

		with upsert as (
				delete from titles_status_a
				returning *
		), delete_titles as (
				DELETE FROM docdb.docdb_titles d
				where d.pat_id in (
				select r.id from docdb.docdb_pats r
				join docdb_intake.docdb_pats in1 on in1.patnum=r.patnum
				join titles_status_a t on in1.id=t.pat_id
				where in1.rec_status='A'
				AND in1.id >= low_in and in1.id < high_in
				)
		) , titles_insert as (
				insert into docdb.docdb_titles (pat_id,title,lang,data_format,batch_id,run_id,created_at,updated_at)
				select t.id,in1.title, in1.lang,in1.source,batch_num,v_run_id, now(),now()
				from docdb_intake.docdb_titles in1 
				join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
				join docdb.docdb_pats t on in2.patnum=t.patnum
                               where in2.id >= low_in and in2.id < high_in				
				and in2.id in (SELECT pat_id FROM upsert)
				returning * )
				
		insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
		select batch_num,'docdb.docdb_amend','Amended(Deleted/Inserted)','docdb_titles',count(*),'A',now()
		from titles_insert; 

			      

		PERFORM docdb.debug('In docdb_amend - Create temp table abstracts_status_a for range v_low_in:'||low_in||' v_high_in:'||high_in);     

        --drop table abstracts_status_a
                EXECUTE 'DROP TABLE IF EXISTS abstracts_status_a;';
		create temp table abstracts_status_a as
		select pat_id, max(docdb_abstracts.rec_status) from docdb_intake.docdb_abstracts 
		group by pat_id, docdb_abstracts.rec_status having docdb_abstracts.rec_status='A';  

		PERFORM docdb.debug('In docdb_amend - Amend docdb.docdb_abstracts for range v_low_in:'||low_in||' v_high_in:'||high_in);     

		with upsert as (
				delete from abstracts_status_a
				returning *
		), delete_abstracts as (
				DELETE FROM docdb.docdb_abstracts d
				where d.pat_id in (
				select r.id from docdb.docdb_pats r
				join docdb_intake.docdb_pats in1 on in1.patnum=r.patnum
				join abstracts_status_a t on in1.id=t.pat_id
				where in1.rec_status='A'
				--AND r.id >= low_in and r.id < high_in
				AND in1.id >= low_in and in1.id < high_in
				)
		) , abstracts_insert as (
				insert into docdb.docdb_abstracts (pat_id,text,lang,source,country,doc_number,
					kind,date_published,status,data_format,batch_id,run_id,created_at,updated_at)
	                       select t.id,in1.text,in1.lang,in1.source,in1.country,in1.doc_number,
					in1.kind,in1.date_published,in1.status,in1.data_format,batch_num,v_run_id, now(),now()
				from docdb_intake.docdb_abstracts in1 
				join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
				join docdb.docdb_pats t on in2.patnum=t.patnum
                               where in2.id >= low_in and in2.id < high_in				
				and in2.id in (SELECT pat_id FROM upsert)
				returning * )
				
		insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
		select batch_num,'docdb.docdb_amend','Amended(Deleted/Inserted)','docdb_abstracts',count(*),'A',now()
		from abstracts_insert; 				 
				
		PERFORM docdb.debug('In docdb_amend - Create temp table classifications_status_a for range v_low_in:'||low_in||' v_high_in:'||high_in);     

        --drop table classificaions_status_a
                EXECUTE 'DROP TABLE IF EXISTS classifications_status_a;';
		create temp table classifications_status_a as
		select pat_id, max(docdb_classifications.rec_status) from docdb_intake.docdb_classifications 
		group by pat_id, docdb_classifications.rec_status having docdb_classifications.rec_status='A';  

		PERFORM docdb.debug('In docdb_amend - Amend docdb.docdb_classifications for range v_low_in:'||low_in||' v_high_in:'||high_in); 

		with upsert as (
				delete from classifications_status_a
				returning *
		), delete_classifications as (
				DELETE FROM docdb.docdb_classifications d
				where d.pat_id in (
				select r.id from docdb.docdb_pats r
				join docdb_intake.docdb_pats in1 on in1.patnum=r.patnum
				join classifications_status_a t on in1.id=t.pat_id
				where in1.rec_status='A'
				--AND r.id >= low_in and r.id < high_in
				AND in1.id >= low_in and in1.id < high_in)
		) , classifications_insert as (
				insert into docdb.docdb_classifications (pat_id,sequence,office,scheme,
					classification,batch_id,run_id,created_at,updated_at)
	                       select t.id,in1.sequence, in1.office,in1.scheme,in1.classification, 
					batch_num,v_run_id,now(),now()
				from docdb_intake.docdb_classifications in1 
				join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
				join docdb.docdb_pats t on in2.patnum=t.patnum
                               where in2.id >= low_in and in2.id < high_in				
				and in2.id in (SELECT pat_id FROM upsert)
				returning * )
				
		insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
		select batch_num,'docdb.docdb_amend','Amended(Deleted/Inserted)','docdb_classifications',count(*),'A',now()
		from classifications_insert; 	
		
		PERFORM docdb.debug('In docdb_amend - Create temp table national_classifications_status_a for range v_low_in:'||low_in||' v_high_in:'||high_in);     

        --drop table national_classificaions_status_a
                EXECUTE 'DROP TABLE IF EXISTS national_classifications_status_a;';
		create temp table national_classifications_status_a as
		select pat_id, max(docdb_national_classifications.rec_status) from docdb_intake.docdb_national_classifications 
		group by pat_id, docdb_national_classifications.rec_status having docdb_national_classifications.rec_status='A';  

		PERFORM docdb.debug('In docdb_amend - Amend docdb.docdb_national_classifications for range v_low_in:'||low_in||' v_high_in:'||high_in); 

		with upsert as (
				delete from national_classifications_status_a
				returning *
		), delete_national_classifications as (
				DELETE FROM docdb.docdb_national_classifications d
				where d.pat_id in (
				select r.id from docdb.docdb_pats r
				join docdb_intake.docdb_pats in1 on in1.patnum=r.patnum
				join national_classifications_status_a t on in1.id=t.pat_id
				where in1.rec_status='A'
				AND in1.id >= low_in and in1.id < high_in)
		) , national_classifications_insert as (
				insert into docdb.docdb_national_classifications (pat_id,classification_national,
					batch_id,run_id,created_at,updated_at)
	                       select t.id,in1.classification_national, batch_num,v_run_id,now(),now()
				from docdb_intake.docdb_national_classifications in1 
				join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
				join docdb.docdb_pats t on in2.patnum=t.patnum
                               where in2.id >= low_in and in2.id < high_in				
				and in2.id in (SELECT pat_id FROM upsert)
				returning * )
				
		insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
		select batch_num,'docdb.docdb_amend','Amended(Deleted/Inserted)','docdb_national_classifications',count(*),'A',now()
		from national_classifications_insert; 	
		
		PERFORM docdb.debug('In docdb_amend - Create temp table inventors_status_a for range v_low_in:'||low_in||' v_high_in:'||high_in);     

        --drop table inventors_status_a
                EXECUTE 'DROP TABLE IF EXISTS inventors_status_a;';
		create temp table inventors_status_a as
		select pat_id, max(docdb_inventors.rec_status) from docdb_intake.docdb_inventors 
		group by pat_id, docdb_inventors.rec_status having docdb_inventors.rec_status='A';  

		PERFORM docdb.debug('In docdb_amend - Amend docdb.docdb_inventors for range v_low_in:'||low_in||' v_high_in:'||high_in); 

		with upsert as (
				delete from inventors_status_a
				returning *
		), delete_inventors as (
				DELETE FROM docdb.docdb_inventors d
				where d.pat_id in (
				select r.id from docdb.docdb_pats r
				join docdb_intake.docdb_pats in1 on in1.patnum=r.patnum
				join inventors_status_a t on in1.id=t.pat_id
				where in1.rec_status='A'
				AND in1.id >= low_in and in1.id < high_in)
		) , inventors_insert as (
			insert into docdb.docdb_inventors (pat_id,			  
				  inventor_name,
				  sequence,
				  data_format,
				  designation,
				  status,
				  address,
				  residence,
				  designated_states,
				  deceased_inventor,
                                 batch_id,run_id,
				  updated_at,
				  created_at)
			select   t.id,
				  in1.inventor_name,
				  in1.sequence,
				  in1.data_format,
				  in1.designation,
				  in1.status,
				  in1.address,
				  in1.residence,
				  in1.designated_states,
				  in1.deceased_inventor,
                                 batch_num,v_run_id,
				  now(),
				  now()
			from docdb_intake.docdb_inventors in1 
			join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
			join docdb.docdb_pats t on in2.patnum=t.patnum
                       where in2.id >= low_in and in2.id < high_in			
			and in2.id in (SELECT pat_id FROM upsert)
		       returning * )
				
		insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
		select batch_num,'docdb.docdb_amend','Amended(Deleted/Inserted)','docdb_inventors',count(*),'A',now()
		from inventors_insert;				

		PERFORM docdb.debug('In docdb_amend - Create temp table applicants_status_a for range v_low_in:'||low_in||' v_high_in:'||high_in);     

       --drop table applicants_status_a
                EXECUTE 'DROP TABLE IF EXISTS applicants_status_a;';
		create temp table applicants_status_a as
		select pat_id, max(docdb_applicants.rec_status) from docdb_intake.docdb_applicants 
		group by pat_id, docdb_applicants.rec_status having docdb_applicants.rec_status='A';  

		PERFORM docdb.debug('In docdb_amend - Amend docdb.docdb_applicants for range v_low_in:'||low_in||' v_high_in:'||high_in); 

		with upsert as (
				delete from applicants_status_a
				returning *
		), delete_applicants as (
				DELETE FROM docdb.docdb_applicants d
				where d.pat_id in (
				select r.id from docdb.docdb_pats r
				join docdb_intake.docdb_pats in1 on in1.patnum=r.patnum
				join applicants_status_a t on in1.id=t.pat_id
				where in1.rec_status='A'
				AND in1.id >= low_in and in1.id < high_in)
		) , applicants_insert as (
			insert into docdb.docdb_applicants (pat_id,			  
				  name ,
				  country ,
				  sequence ,
				  data_format ,
				  app_type ,
				  designation ,
				  status ,
				  address ,
				  nationality ,
				  us_rights ,
				  designated_states ,
				  designated_states_as_inventor ,
                                 batch_id,run_id,
				  updated_at,
				  created_at)
			select   t.id,			  
				  in1.name ,
				  in1.country ,
				  in1.sequence ,
				  in1.data_format ,
				  in1.app_type ,
				  in1.designation ,
				  in1.status ,
				  in1.address ,
				  in1.nationality ,
				  in1.us_rights ,
				  in1.designated_states ,
				  in1.designated_states_as_inventor ,
                                 batch_num,v_run_id,
				  now(),
				  now() 
			from docdb_intake.docdb_applicants in1 
			join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
			join docdb.docdb_pats t on in2.patnum=t.patnum
                        where in2.id >= low_in and in2.id < high_in			
			and in2.id in (SELECT pat_id FROM upsert)
		       returning * )
				
		insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
		select batch_num,'docdb.docdb_amend','Amended(Deleted/Inserted)','docdb_applicants',count(*),'A',now()
		from applicants_insert;					

		PERFORM docdb.debug('In docdb_amend - Create temp table priority_claims_status_a for range v_low_in:'||low_in||' v_high_in:'||high_in);     

        --drop table priority_claims_status_a
                EXECUTE 'DROP TABLE IF EXISTS priority_claims_status_a;';
		create temp table priority_claims_status_a as
		select pat_id, max(docdb_priority_claims.rec_status) from docdb_intake.docdb_priority_claims 
		group by pat_id, docdb_priority_claims.rec_status having docdb_priority_claims.rec_status='A';  

		PERFORM docdb.debug('In docdb_amend - Amend docdb.docdb_priority_claims for range v_low_in:'||low_in||' v_high_in:'||high_in); 

		with upsert as (
				delete from priority_claims_status_a
				returning *
		), delete_priority_claims as (
				DELETE FROM docdb.docdb_priority_claims d
				where d.pat_id in (
				select r.id from docdb.docdb_pats r
				join docdb_intake.docdb_pats in1 on in1.patnum=r.patnum
				join priority_claims_status_a t on in1.id=t.pat_id
				where in1.rec_status='A'
				AND in1.id >= low_in and in1.id < high_in)
		) , priority_claims_insert as (
			insert into docdb.docdb_priority_claims (pat_id,			  
				  sequence,
				  doc_number,
				  claim_id,
				  data_format,
				  status,
				  lang,
				  country,
				  kind,
				  name,
				  office_of_filing,
				  priority_doc_requested,
				  priority_doc_attached,
				  priority_linkage_type,
				  priority_active_indicator,
				  doc_date,
                                 batch_id,run_id,
				  updated_at,
				  created_at )
			select t.id,
				  in1.sequence,
				  in1.doc_number,
				  in1.claim_id,
				  in1.data_format,
				  in1.status,
				  in1.lang,
				  in1.country,
				  in1.kind,
				  in1.name,
				  in1.office_of_filing,
				  in1.priority_doc_requested,
				  in1.priority_doc_attached,
				  in1.priority_linkage_type,
				  in1.priority_active_indicator,
				  case when in1.doc_date = '' then null else to_date(in1.doc_date,'YYYYMMDD') end, 
				 -- in1.doc_date,
                                 batch_num,v_run_id,
				  now(),
				  now()
			from docdb_intake.docdb_priority_claims in1 
			join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
			join docdb.docdb_pats t on in2.patnum=t.patnum
                        where in2.id >= low_in and in2.id < high_in			
			and in2.id in (SELECT pat_id FROM upsert)
		       returning * )
				
		insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
		select batch_num,'docdb.docdb_amend','Amended(Deleted/Inserted)','docdb_priority_claims',count(*),'A',now()
		from priority_claims_insert;				

		PERFORM docdb.debug('In docdb_amend - Create temp table citations_status_a for range v_low_in:'||low_in||' v_high_in:'||high_in);     

        --drop table citations_status_a
                EXECUTE 'DROP TABLE IF EXISTS citations_status_a;';
		create temp table citations_status_a as
		select pat_id, max(docdb_citations.rec_status) from docdb_intake.docdb_citations 
		group by pat_id, docdb_citations.rec_status having docdb_citations.rec_status='A';  

		PERFORM docdb.debug('In docdb_amend - Amend docdb.docdb_citations for range v_low_in:'||low_in||' v_high_in:'||high_in); 

		with upsert as (
				delete from citations_status_a
				returning *
		), delete_citations as (
				DELETE FROM docdb.docdb_citations d
				where d.pat_id in (
				select r.id from docdb.docdb_pats r
				join docdb_intake.docdb_pats in1 on in1.patnum=r.patnum
				join citations_status_a t on in1.id=t.pat_id
				where in1.rec_status='A'
				AND in1.id >= low_in and in1.id < high_in)
		) , citations_insert as (
			insert into docdb.docdb_citations (pat_id,			  
				  cit_id,
				  srep_phase,
				  srep_office,
				  sequence,
				  sub_id,
				  num,
				  dnum,
				  dnum_type,
				  file,
				  url,
				  lang,
				  npl_type,
				  medium,
				  country,
				  doc_number,
				  kind,
				  name,
				  date,
				  text,
				  article,
				  book,
				  online,
				  othercit,
				  rel_passage,
				  document_id,
				  refno,
				  category,
				  rel_claims,
                                 batch_id,run_id,
				  updated_at,
				  created_at  )
			select t.id,
				  in1.cit_id,
				  in1.srep_phase,
				  in1.srep_office,
				  in1.sequence,
				  in1.sub_id,
				  in1.num,
				  in1.dnum,
				  in1.dnum_type,
				  in1.file,
				  in1.url,
				  in1.lang,
				  in1.npl_type,
				  in1.medium,
				  in1.country,
				  in1.doc_number,
				  in1.kind,
				  in1.name,
				  case when in1.date = '' then null else to_date(in1.date,'YYYYMMDD') end, 
				 -- in1.date,
				  in1.text,
				  in1.article,
				  in1.book,
				  in1.online,
				  in1.othercit,
				  in1.rel_passage,
				  in1.document_id,
				  in1.refno,
				  in1.category,
				  in1.rel_claims,
                                 batch_num,v_run_id,
				  now(),
				  now()
			from docdb_intake.docdb_citations in1 
			join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
			join docdb.docdb_pats t on in2.patnum=t.patnum
                        where in2.id >= low_in and in2.id < high_in			
			and in2.id in (SELECT pat_id FROM upsert)
		       returning * )
				
		insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
		select batch_num,'docdb.docdb_amend','Amended(Deleted/Inserted)','docdb_citations',count(*),'A',now()
		from citations_insert;					

		-- now create records:
		
		PERFORM docdb.debug('In docdb_amend - Create temp table ipcs_status_c for range v_low_in:'||low_in||' v_high_in:'||high_in);     

                -- drop table ipcs_status_c
        EXECUTE 'DROP TABLE IF EXISTS ipcs_status_c;';
                
		create temp table ipcs_status_c as
		select pat_id, max(docdb_ipcs.rec_status) from docdb_intake.docdb_ipcs 
		group by pat_id, docdb_ipcs.rec_status having docdb_ipcs.rec_status='C'; 

		PERFORM docdb.debug('In docdb_amend - Insert docdb.docdb_ipcs for range v_low_in:'||low_in||' v_high_in:'||high_in); 

		insert into docdb.docdb_ipcs (pat_id,sequence,ipc_ipcr_text,type,edition,batch_id,run_id,created_at,updated_at)
		select t.id,in1.sequence, in1.ipc_ipcr_text,in1.type,in1.edition,batch_num,v_run_id, now(),now()
		from docdb_intake.docdb_ipcs in1 
		join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
		join docdb.docdb_pats t on in2.patnum=t.patnum
		--left outer join docdb.docdb_ipcs o on (t.id=o.pat_id and  o.ipc_ipcr_text= in1.ipc_ipcr_text)  -- not using it, let it fail if duplicates
		where in2.id >= low_in and in2.id < high_in
		-- and o.ipc_ipcr_text is null
		and in1.rec_status='C'
		and in2.id in (SELECT pat_id FROM ipcs_status_c);

		PERFORM docdb.debug('In docdb_amend - Create temp table classifications_status_c for range v_low_in:'||low_in||' v_high_in:'||high_in);     

		--classifications
                EXECUTE 'DROP TABLE IF EXISTS classifications_status_c;';
                		
		create temp table classifications_status_c as
		select pat_id, max(docdb_classifications.rec_status) 
		from docdb_intake.docdb_classifications 
		group by pat_id, docdb_classifications.rec_status 
		having docdb_classifications.rec_status='C'; 

		PERFORM docdb.debug('In docdb_amend - Insert docdb.docdb_classifications for range v_low_in:'||low_in||' v_high_in:'||high_in); 

		insert into docdb.docdb_classifications (pat_id,sequence,office,scheme,classification,batch_id,run_id,created_at,updated_at)
		select t.id,in1.sequence, in1.office,in1.scheme,in1.classification,batch_num,v_run_id, now(),now()
		from docdb_intake.docdb_classifications in1 
		join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
		join docdb.docdb_pats t on in2.patnum=t.patnum
		where in2.id >= low_in and in2.id < high_in
		and in1.rec_status='C'
		and in2.id in (SELECT pat_id FROM classifications_status_c);

		PERFORM docdb.debug('In docdb_amend - Create temp table national_classifications_status_c for range v_low_in:'||low_in||' v_high_in:'||high_in);     

		--national_classifications
                EXECUTE 'DROP TABLE IF EXISTS national_classifications_status_c;';
                		
		create temp table national_classifications_status_c as
		select pat_id, max(docdb_national_classifications.rec_status) 
		from docdb_intake.docdb_national_classifications 
		group by pat_id, docdb_national_classifications.rec_status 
		having docdb_national_classifications.rec_status='C'; 

		PERFORM docdb.debug('In docdb_amend - Insert docdb.docdb_national_classifications for range v_low_in:'||low_in||' v_high_in:'||high_in); 

		insert into docdb.docdb_national_classifications (pat_id,classification_national,batch_id,run_id,created_at,updated_at)
		select t.id,in1.classification_national,batch_num,v_run_id, now(),now()
		from docdb_intake.docdb_national_classifications in1 
		join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
		join docdb.docdb_pats t on in2.patnum=t.patnum
		where in2.id >= low_in and in2.id < high_in
		and in1.rec_status='C'
		and in2.id in (SELECT pat_id FROM national_classifications_status_c);		

		PERFORM docdb.debug('In docdb_amend - Create temp table titles_status_c for range v_low_in:'||low_in||' v_high_in:'||high_in);     

		--titles
                EXECUTE 'DROP TABLE IF EXISTS titles_status_c;';
                		
		create temp table titles_status_c as
		select pat_id, max(docdb_titles.rec_status) 
		from docdb_intake.docdb_titles 
		group by pat_id, docdb_titles.rec_status 
		having docdb_titles.rec_status='C'; 

		PERFORM docdb.debug('In docdb_amend - Insert docdb.docdb_titles for range v_low_in:'||low_in||' v_high_in:'||high_in); 

		with new_title_inserts as
		(insert into docdb.docdb_titles (pat_id,title,lang,data_format,batch_id,run_id,created_at,updated_at)
		select t.id,in1.title,in1.lang,in1.source,batch_num,v_run_id, now(),now()
		from docdb_intake.docdb_titles in1 
		join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
		join docdb.docdb_pats t on in2.patnum=t.patnum
		where in2.id >= low_in and in2.id < high_in
		and in1.rec_status='C'
		and in2.id in (SELECT pat_id FROM titles_status_c)
		returning * )
		update docdb.docdb_pats a set pat_family_processed=false
		from new_title_inserts b
		where a.id=b.pat_id and a.pat_family_processed is null;

		PERFORM docdb.debug('In docdb_amend - Create temp table abstracts_status_c for range v_low_in:'||low_in||' v_high_in:'||high_in);     

		--abstracts
                EXECUTE 'DROP TABLE IF EXISTS abstracts_status_c;';
                		
		create temp table abstracts_status_c as
		select pat_id, max(docdb_abstracts.rec_status) 
		from docdb_intake.docdb_abstracts 
		group by pat_id, docdb_abstracts.rec_status 
		having docdb_abstracts.rec_status='C'; 

		PERFORM docdb.debug('In docdb_amend - Insert docdb.docdb_abstracts for range v_low_in:'||low_in||' v_high_in:'||high_in); 

		insert into docdb.docdb_abstracts (pat_id,text,lang,source,country,doc_number,kind,date_published,data_format,batch_id,run_id,created_at,updated_at)
		select t.id,in1.text,in1.lang,in1.source,in1.country,in1.doc_number,in1.kind,in1.date_published,in1.data_format,batch_num,v_run_id, now(),now()
		from docdb_intake.docdb_abstracts in1 
		join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
		join docdb.docdb_pats t on in2.patnum=t.patnum
		where in2.id >= low_in and in2.id < high_in
		and in1.rec_status='C'
		and in2.id in (SELECT pat_id FROM abstracts_status_c);	

		PERFORM docdb.debug('In docdb_amend - Create temp table inventors_status_c for range v_low_in:'||low_in||' v_high_in:'||high_in);     

		--inventors
                EXECUTE 'DROP TABLE IF EXISTS inventors_status_c;';
                		
		create temp table inventors_status_c as
		select pat_id, max(docdb_inventors.rec_status) 
		from docdb_intake.docdb_inventors 
		group by pat_id, docdb_inventors.rec_status 
		having docdb_inventors.rec_status='C'; 

		PERFORM docdb.debug('In docdb_amend - Insert docdb.docdb_inventors for range v_low_in:'||low_in||' v_high_in:'||high_in); 

		insert into docdb.docdb_inventors (pat_id,
                                 inventor_name,
				  sequence,
				  data_format,
				  designation,
				  status,
				  address,
				  residence,
				  designated_states,
				  deceased_inventor,
                                 batch_id,run_id,
				  updated_at,
				  created_at)
			select   t.id,
				  in1.inventor_name,
				  in1.sequence,
				  in1.data_format,
				  in1.designation,
				  in1.status,
				  in1.address,
				  in1.residence,
				  in1.designated_states,
				  in1.deceased_inventor,
                                 batch_num,v_run_id,
				  now(),
				  now()
		from docdb_intake.docdb_inventors in1 
		join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
		join docdb.docdb_pats t on in2.patnum=t.patnum
		where in2.id >= low_in and in2.id < high_in
		and in1.rec_status='C'
		and in2.id in (SELECT pat_id FROM inventors_status_c);	

		PERFORM docdb.debug('In docdb_amend - Create temp table applicants_status_c for range v_low_in:'||low_in||' v_high_in:'||high_in);     

		--applicants
                EXECUTE 'DROP TABLE IF EXISTS applicants_status_c;';
                		
		create temp table applicants_status_c as
		select pat_id, max(docdb_applicants.rec_status) 
		from docdb_intake.docdb_applicants 
		group by pat_id, docdb_applicants.rec_status 
		having docdb_applicants.rec_status='C'; 

		PERFORM docdb.debug('In docdb_amend - Insert docdb.docdb_applicants for range v_low_in:'||low_in||' v_high_in:'||high_in); 

		insert into docdb.docdb_applicants (pat_id,				  
		                  name,
				  country,
				  sequence,
				  data_format,
				  app_type,
				  designation,
				  status,
				  address ,
				  nationality,
				  us_rights,
				  designated_states,
				  designated_states_as_inventor,
                                 batch_id,run_id,
				  updated_at,
				  created_at)
			select   t.id,			  
				  in1.name,
				  in1.country,
				  in1.sequence,
				  in1.data_format,
				  in1.app_type ,
				  in1.designation,
				  in1.status,
				  in1.address ,
				  in1.nationality,
				  in1.us_rights,
				  in1.designated_states,
				  in1.designated_states_as_inventor,
                                 batch_num,v_run_id,
				  now(),
				  now() 
		from docdb_intake.docdb_applicants in1 
		join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
		join docdb.docdb_pats t on in2.patnum=t.patnum
		where in2.id >= low_in and in2.id < high_in
		and in1.rec_status='C'
		and in2.id in (SELECT pat_id FROM applicants_status_c);

		PERFORM docdb.debug('In docdb_amend - Create temp table citations_status_c for range v_low_in:'||low_in||' v_high_in:'||high_in);     

		--citations
                EXECUTE 'DROP TABLE IF EXISTS citations_status_c;';
                		
		create temp table citations_status_c as
		select pat_id, max(docdb_citations.rec_status) 
		from docdb_intake.docdb_citations 
		group by pat_id, docdb_citations.rec_status 
		having docdb_citations.rec_status='C'; 

		PERFORM docdb.debug('In docdb_amend - Insert docdb.docdb_citations for range v_low_in:'||low_in||' v_high_in:'||high_in); 

		insert into docdb.docdb_citations (pat_id,				  
		                  cit_id,
				  srep_phase,
				  srep_office,
				  sequence,
				  sub_id,
				  num,
				  dnum,
				  dnum_type,
				  file,
				  url,
				  lang,
				  npl_type,
				  medium,
				  country,
				  doc_number,
				  kind,
				  name,
				  date,
				  text,
				  article,
				  book,
				  online,
				  othercit,
				  rel_passage,
				  document_id,
				  refno,
				  category,
				  rel_claims,
                                 batch_id,run_id,
				  updated_at,
				  created_at  )
			select t.id,
				  in1.cit_id,
				  in1.srep_phase,
				  in1.srep_office,
				  in1.sequence,
				  in1.sub_id,
				  in1.num,
				  in1.dnum,
				  in1.dnum_type,
				  in1.file,
				  in1.url,
				  in1.lang,
				  in1.npl_type,
				  in1.medium,
				  in1.country,
				  in1.doc_number,
				  in1.kind,
				  in1.name,
				  case when in1.date = '' then null else to_date(in1.date,'YYYYMMDD') end, 
				 -- in1.date,
				  in1.text,
				  in1.article,
				  in1.book,
				  in1.online,
				  in1.othercit,
				  in1.rel_passage,
				  in1.document_id,
				  in1.refno,
				  in1.category,
				  in1.rel_claims,
                                 batch_num,v_run_id,
				  now(),
				  now()
		from docdb_intake.docdb_citations in1 
		join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
		join docdb.docdb_pats t on in2.patnum=t.patnum
		where in2.id >= low_in and in2.id < high_in
		and in1.rec_status='C'
		and in2.id in (SELECT pat_id FROM citations_status_c);	

		PERFORM docdb.debug('In docdb_amend - Create temp table priority_claims_status_c for range v_low_in:'||low_in||' v_high_in:'||high_in);     

		--priority_claims
                EXECUTE 'DROP TABLE IF EXISTS priority_claims_status_c;';
                		
		create temp table priority_claims_status_c as
		select pat_id, max(docdb_priority_claims.rec_status) 
		from docdb_intake.docdb_priority_claims 
		group by pat_id, docdb_priority_claims.rec_status 
		having docdb_priority_claims.rec_status='C'; 

		PERFORM docdb.debug('In docdb_amend - Insert docdb.docdb_priority_claims for range v_low_in:'||low_in||' v_high_in:'||high_in); 

		insert into docdb.docdb_priority_claims (pat_id,				  
		                  sequence,
				  doc_number,
				  claim_id,
				  data_format,
				  status,
				  lang,
				  country,
				  kind,
				  name,
				  office_of_filing,
				  priority_doc_requested,
				  priority_doc_attached,
				  priority_linkage_type,
				  priority_active_indicator,
				  doc_date,
                                 batch_id,run_id,
				  updated_at,
				  created_at )
			select t.id,
				  in1.sequence,
				  in1.doc_number,
				  in1.claim_id,
				  in1.data_format,
				  in1.status,
				  in1.lang,
				  in1.country,
				  in1.kind,
				  in1.name,
				  in1.office_of_filing,
				  in1.priority_doc_requested,
				  in1.priority_doc_attached,
				  in1.priority_linkage_type,
				  in1.priority_active_indicator,
				  case when in1.doc_date = '' then null else to_date(in1.doc_date,'YYYYMMDD') end, 
				--  in1.doc_date,
                                 batch_num,v_run_id,
				  now(),
				  now()
		from docdb_intake.docdb_priority_claims in1 
		join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
		join docdb.docdb_pats t on in2.patnum=t.patnum
		where in2.id >= low_in and in2.id < high_in
		and in1.rec_status='C'
		and in2.id in (SELECT pat_id FROM priority_claims_status_c);																					
--end if;

return 'Batch: '||batch_num::text||' Amended: Success!';
/*
GET DIAGNOSTICS icount = ROW_COUNT;
	INSERT INTO docdb.logs (step, table_name, action, status, count, date_created) 
	VALUES ( 4, 'core.pat_references','Insert '||low_in||'-'||high_in||'', 'Completed',icount, now()); 

*/

end;$_$;


--
-- Name: docdb_create(integer, integer, integer); Type: FUNCTION; Schema: docdb; Owner: -
--

CREATE FUNCTION docdb_create(low_in integer, high_in integer, batch_num integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$DECLARE
    icount     INTEGER:=0;
    v_count    INTEGER:=0;
    v_batch    text;
    v_run_id   integer;
    v_batch_id   int8;
    v_not_exist  integer:=0; 
    v_not_exist_text text:='';
BEGIN
/*
1.0 26-Sep-2014 anarayanan DS-467: Set pat_family_processed flag
2.0 28-Apr-2015 tazhagan_c DS-1625 : Added debug statements to log the progress
*/

--EXECUTE 'DROP TABLE IF EXISTS temp_refs;'; 
  v_batch := 'Batch#: '||batch_num::text||' Range ['||low_in::text||'-'||high_in::text||'] ';
  v_batch_id:= batch_num;

  select distinct run_id into v_run_id 
  from docdb.docdb_batch 
  where id=v_batch_id;

-- added to take care of missing pat from target

  select count(d.patnum) into v_not_exist
  from docdb_intake.docdb_pats d 
  left outer join docdb.docdb_pats l
  on l.patnum=d.patnum
  where l.patnum is null
  and rec_status='A'
  and d.id >= low_in and d.id < high_in;

  if v_not_exist > 0 then
	  select array_to_string(array_agg(d.patnum),',')  into v_not_exist_text
	  from docdb_intake.docdb_pats d 
	  left outer join docdb.docdb_pats l
	  on l.patnum=d.patnum
	  where l.patnum is null
	  and rec_status='A'
	  and d.id >= low_in and d.id < high_in;

	  PERFORM docdb.debug('In docdb_create - Updating docdb_intake.docdb_pats.rec_status=C as patents dont exists in target table for range v_low_in:'||low_in||' v_high_in:'||high_in);     

	  update docdb_intake.docdb_pats 
	  set rec_status='C', updated_at=now() 
	  where patnum in (select d.patnum  --into v_not_exist_text
	  from docdb_intake.docdb_pats d 
	  left outer join docdb.docdb_pats l
	  on l.patnum=d.patnum
	  where l.patnum is null
	  and rec_status='A'
	  and d.id >= low_in and d.id < high_in);

	  insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
	  values( batch_num,'docdb.docdb_amend',v_not_exist_text,'patents not exists in the target table, changing status to C',v_not_exist,'A',now());
  end if;


  select count(*) into v_count
  from  docdb_intake.docdb_pats ip
  where ip.id >= low_in and ip.id < high_in
	and ip.rec_status='C';

  if v_count = 0 then

        PERFORM docdb.debug('In docdb_create - No records to create for range v_low_in:'||low_in||' v_high_in:'||high_in);     

		insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
		values (v_batch_id,'docdb.docdb_create','No action','No records to create for range ['||low_in::text||'-'||high_in::text||'] ',0,'C',now());
  else

  		PERFORM docdb.debug('In docdb_create - Creating new records as per the intake for range v_low_in:'||low_in||' v_high_in:'||high_in);     

    WITH rec_update as (
	update docdb.docdb_pats m 
	set     is_representative = d.is_representative, 
		date_of_last_exchange = case when d.date_of_last_exchange = '' then null else to_date(d.date_of_last_exchange,'YYYYMMDD') end, 
		date_of_previous_exchange = case when d.date_of_previous_exchange= '' then null else to_date(d.date_of_previous_exchange,'YYYYMMDD') end,
		date_added_docdb =  case when d.date_added_docdb = '' then null else  to_date(d.date_added_docdb,'YYYYMMDD') end, 
		originating_office = d.originating_office,
		status = d.status,
		filedate = d.filedate,
		issue_date = case when d.issue_date = '' then null else to_date(d.issue_date,'YYYYMMDD') end,
		title = d.title,
		title_lang = d.title_lang,
		family_id = d.family_id,
		doc_number = d.stripped_patnum,
		stripped_patnum = (case when d.country_code = 'US' then regexp_replace(d.stripped_patnum, '(^\d\d\d\d)(\d\d\d\d\d\d$)', '\10\2') else d.stripped_patnum end),
		extended_kind_code = d.extended_kind_code,
		app_num_intl = d.app_num_intl,
		app_num_country = d.app_num_country,
		app_date = case when d.app_date ='' then null else to_date(d.app_date,'YYYYMMDD') end, 
		lang_of_publication = d.lang_of_publication,
		lang_of_filing = d.lang_of_filing,
		doc_kind_code = d.doc_kind_code,
		publication_number = d.publication_number,
		publication_date =  case when d.publication_date ='' then null else  to_date(d.publication_date,'YYYYMMDD') end, 
		app_is_representative = d.app_is_representative,
		app_kind_code = d.app_kind_code,
		date_of_coming_into_force = d.date_of_coming_into_force,
		preceding_publication_date = case when d.preceding_publication_date = '' then null else to_date(d.preceding_publication_date,'YYYYMMDD') end, 
		previously_filed_app = d.previously_filed_app,
		country_code = d.country_code,
		public_availability_date = case when d.public_availability_date = '' then null else to_date(d.public_availability_date,'YYYYMMDD') end, 
		public_availability_category = d.public_availability_category,
		publication_date_history = d.publication_date_history,
		batch_id = batch_num,
		run_id=v_run_id,
		pat_family_processed = (case when 
									m.app_num_intl != d.app_num_intl OR 
									m.app_date::date != to_date(d.app_date,'YYYYMMDD') OR 
									m.country_code != d.country_code OR 
									m.app_num_country != d.app_num_country 
									then
		                                false
									else
									    true
		                    	end),		
		updated_at=now()

	from docdb_intake.docdb_pats d 
	where m.patnum=d.patnum and d.rec_status='C'
		and d.id >= low_in and d.id < high_in
        RETURNING m.*

    ),  
    rec_insert as (
	insert into docdb.docdb_pats (id,
			  patnum ,
			  is_representative ,
			  date_of_last_exchange ,
			  date_of_previous_exchange ,
			  date_added_docdb ,
			  originating_office ,
			  status ,
			  filedate ,
			  issue_date ,
			  title ,
			  title_lang ,
			  family_id ,
			  doc_number,
			  stripped_patnum ,
			  extended_kind_code ,
			  app_num_intl ,
			  app_num_country ,
			  app_date ,
			  lang_of_publication ,
			  lang_of_filing ,
			  doc_kind_code ,
			  publication_number ,
			  publication_date ,
			  app_is_representative ,
			  app_kind_code ,
			  date_of_coming_into_force ,
			  preceding_publication_date ,
			  previously_filed_app ,
			  country_code ,
			  public_availability_date ,
			  public_availability_category ,
			  batch_id,run_id,
			  publication_date_history,
			  updated_at,
			  created_at,
			  pat_family_processed )
	select nextval('docdb.docdb_pats_id_seq'),
			  in1.patnum ,
			  in1.is_representative ,
                          case when in1.date_of_last_exchange = '' then null else to_date(in1.date_of_last_exchange,'YYYYMMDD') end,  
                          case when in1.date_of_previous_exchange= '' then null else to_date(in1.date_of_previous_exchange,'YYYYMMDD') end,
                          case when in1.date_added_docdb = '' then null else  to_date(in1.date_added_docdb,'YYYYMMDD') end,  
			  in1.originating_office ,
			  in1.status ,
			  in1.filedate ,
                          case when in1.issue_date = '' then null else to_date(in1.issue_date,'YYYYMMDD') end,
			  in1.title ,
			  in1.title_lang ,
			  in1.family_id ,
			  in1.stripped_patnum ,
			  (case when in1.country_code = 'US' then regexp_replace(in1.stripped_patnum, '(^\d\d\d\d)(\d\d\d\d\d\d$)', '\10\2') else in1.stripped_patnum end) ,
			  in1.extended_kind_code ,
			  in1.app_num_intl ,
			  in1.app_num_country ,
                          case when in1.app_date ='' then null else to_date(in1.app_date,'YYYYMMDD') end, 
			  in1.lang_of_publication ,
			  in1.lang_of_filing ,
			  in1.doc_kind_code ,
			  in1.publication_number ,
                          case when in1.publication_date ='' then null else  to_date(in1.publication_date,'YYYYMMDD') end, 
			  in1.app_is_representative ,
			  in1.app_kind_code ,
			  in1.date_of_coming_into_force ,
                          case when in1.preceding_publication_date = '' then null else to_date(in1.preceding_publication_date,'YYYYMMDD') end,  
			  in1.previously_filed_app ,
			  in1.country_code ,
                          case when in1.public_availability_date = '' then null else to_date(in1.public_availability_date,'YYYYMMDD') end, 
			  in1.public_availability_category,
			  v_batch_id,v_run_id,
			  in1.publication_date_history,
			  now(),
			  now(),
			  false --pat_family_processed
	from docdb_intake.docdb_pats in1 
	where in1.patnum not in (select b.patnum from rec_update b)	
		and in1.id >= low_in and in1.id < high_in
		and  in1.rec_status='C'
	RETURNING *
    )
    , pats_log as (
		insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
		select v_batch_id,'docdb.docdb_create','Created','docdb_pats',count(*),'C',now() 
		from rec_insert )
    , ipc_insert as (
		insert into docdb.docdb_ipcs (pat_id,sequence,ipc_ipcr_text,type,edition,batch_id,run_id,updated_at,created_at)
		select t.id,in1.sequence, in1.ipc_ipcr_text,in1.type,in1.edition,batch_num,v_run_id,now(),now() 
		from docdb_intake.docdb_ipcs in1 
		join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
		join rec_insert t on in2.patnum=t.patnum 
		returning * )
    , ipcs_log as (
		insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
		select v_batch_id,'docdb.docdb_create','Created','docdb_ipcs',count(*),'C',now() 
		from ipc_insert )		
    , titles_insert as (
		insert into docdb.docdb_titles (pat_id,title,lang,data_format,batch_id,run_id,created_at,updated_at)
				select t.id,in1.title, in1.lang,in1.source,batch_num,v_run_id, now(),now()
		from docdb_intake.docdb_titles in1 
		join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
		join rec_insert t on in2.patnum=t.patnum 
		returning * )
    , titles_log as (
		insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
		select v_batch_id,'docdb.docdb_create','Created','docdb_titles',count(*),'C',now() 
		from titles_insert )	
    , classifications_insert as (
		insert into docdb.docdb_classifications (pat_id,sequence,office,scheme,classification,batch_id,run_id,updated_at,created_at)
		select t.id,in1.sequence, in1.office,in1.scheme,in1.classification,batch_num,v_run_id,now(),now() 
		from docdb_intake.docdb_classifications in1 
		join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
		join rec_insert t on in2.patnum=t.patnum 
		returning * )
    , classifications_log as (
		insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
		select v_batch_id,'docdb.docdb_create','Created','docdb_classifications',count(*),'C',now() 
		from classifications_insert )	
    , natl_classifications_insert as (
		insert into docdb.docdb_national_classifications (pat_id,classification_national,batch_id,run_id,updated_at,created_at)
		select t.id,in1.classification_national,batch_num,v_run_id,now(),now() 
		from docdb_intake.docdb_national_classifications in1 
		join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
		join rec_insert t on in2.patnum=t.patnum 
		returning * )
    , natl_classifications_log as (
		insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
		select v_batch_id,'docdb.docdb_create','Created','docdb_national_classifications',count(*),'C',now() 
		from natl_classifications_insert )	
    , priority_claims_insert as (
		insert into docdb.docdb_priority_claims (  pat_id,
			  sequence,
			  doc_number,
			  claim_id,
			  data_format,
			  status,
			  lang,
			  country,
			  kind,
			  name,
			  office_of_filing,
			  priority_doc_requested,
			  priority_doc_attached,
			  priority_linkage_type,
			  priority_active_indicator,
			  doc_date,
			  batch_id,run_id,
			  updated_at,
			  created_at )
		select t.id,
			  in1.sequence,
			  in1.doc_number,
			  in1.claim_id,
			  in1.data_format,
			  in1.status,
			  in1.lang,
			  in1.country,
			  in1.kind,
			  in1.name,
			  in1.office_of_filing,
			  in1.priority_doc_requested,
			  in1.priority_doc_attached,
			  in1.priority_linkage_type,
			  in1.priority_active_indicator,
			  case when in1.doc_date = '' then null else to_date(in1.doc_date,'YYYYMMDD') end, 
			  v_batch_id,v_run_id,
			  now(),
			  now()
		from docdb_intake.docdb_priority_claims in1 
		join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
		join rec_insert t on in2.patnum=t.patnum 
		returning * )
    , priority_claims_log as (
		insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
		select batch_num,'docdb.docdb_create','Created','docdb_priority_claims',count(*),'C',now() 
		from priority_claims_insert )	
		-- new
    , citations_insert as (
		insert into docdb.docdb_citations (  pat_id,
				  cit_id,
				  srep_phase,
				  srep_office,
				  sequence,
				  sub_id,
				  num,
				  dnum,
				  dnum_type,
				  file,
				  url,
				  lang,
				  npl_type,
				  medium,
				  country,
				  doc_number,
				  kind,
				  name,
				  date,
				  text,
				  article,
				  book,
				  online,
				  othercit,
				  rel_passage,
				  document_id,
				  refno,
				  category,
				  rel_claims,
				  batch_id,run_id,
				  updated_at,
				  created_at  )
			select    t.id,
				  in1.cit_id,
				  in1.srep_phase,
				  in1.srep_office,
				  in1.sequence,
				  in1.sub_id,
				  in1.num,
				  in1.dnum,
				  in1.dnum_type,
				  in1.file,
				  in1.url,
				  in1.lang,
				  in1.npl_type,
				  in1.medium,
				  in1.country,
				  in1.doc_number,
				  in1.kind,
				  in1.name,
				  case when in1.date = '' then null else to_date(in1.date,'YYYYMMDD') end, 
				--  in1.date,
				  in1.text,
				  in1.article,
				  in1.book,
				  in1.online,
				  in1.othercit,
				  in1.rel_passage,
				  in1.document_id,
				  in1.refno,
				  in1.category,
				  in1.rel_claims,
				  v_batch_id,v_run_id,
				  now(),
				  now()
		from docdb_intake.docdb_citations in1 
		join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
		join rec_insert t on in2.patnum=t.patnum 
		returning * )
    , citations_log as (
		insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
		select v_batch_id,'docdb.docdb_create','Created','docdb_citations',count(*),'C',now() 
		from citations_insert )					  
    , inventors_insert as (
		insert into docdb.docdb_inventors (  pat_id,
			  inventor_name,
			  sequence,
			  data_format,
			  designation,
			  status,
			  address,
			  residence,
			  designated_states,
			  deceased_inventor,
			  batch_id,run_id,
			  updated_at,
			  created_at)
		select t.id,
			  in1.inventor_name,
			  in1.sequence,
			  in1.data_format,
			  in1.designation,
			  in1.status,
			  in1.address,
			  in1.residence,
			  in1.designated_states,
			  in1.deceased_inventor,
			  v_batch_id,v_run_id,
			  now(),
			  now()
		from docdb_intake.docdb_inventors in1 
		join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
		join rec_insert t on in2.patnum=t.patnum 
		returning * )
    , inventors_log as (
		insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
		select v_batch_id,'docdb.docdb_create','Created','docdb_inventors',count(*),'C',now() 
		from inventors_insert )			
    , applicants_insert as (
		insert into docdb.docdb_applicants (  pat_id,
			  name ,
			  country ,
			  sequence ,
			  data_format ,
			  app_type ,
			  designation ,
			  status ,
			  address ,
			  nationality ,
			  us_rights ,
			  designated_states ,
			  designated_states_as_inventor ,
			  batch_id,run_id,
			  updated_at,
			  created_at)
		select   t.id,			  
			  in1.name ,
			  in1.country ,
			  in1.sequence ,
			  in1.data_format ,
			  in1.app_type ,
			  in1.designation ,
			  in1.status ,
			  in1.address ,
			  in1.nationality ,
			  in1.us_rights ,
			  in1.designated_states ,
			  in1.designated_states_as_inventor ,
			  v_batch_id,v_run_id,
			  now(),
			  now() 
		from docdb_intake.docdb_applicants in1 
		join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
		join rec_insert t on in2.patnum=t.patnum 
		returning * )
    , applicants_log as (
		insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
		select v_batch_id,'docdb.docdb_create','Created','docdb_applicants',count(*),'C',now() 
		from applicants_insert )	
    , abstracts_insert as (
		insert into docdb.docdb_abstracts (pat_id,text,lang,source,country,doc_number,
			kind,date_published,status,data_format,batch_id,run_id,created_at)
		select t.id,in1.text,in1.lang,in1.source,in1.country,in1.doc_number,in1.kind,
			in1.date_published,in1.status,in1.data_format,v_batch_id,v_run_id,now()
		from docdb_intake.docdb_abstracts in1 
		join docdb_intake.docdb_pats in2 on in1.pat_id=in2.id 
		join rec_insert t on in2.patnum=t.patnum
		returning * )
    insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
    select v_batch_id,'docdb.docdb_create','Created','docdb_abstracts',count(*),'C',now() 
    from abstracts_insert;
  end if;	

  return 'Batch: '||v_batch_id::text||' Created: Success!';

end;$_$;


--
-- Name: docdb_delete(integer, integer, integer); Type: FUNCTION; Schema: docdb; Owner: -
--

CREATE FUNCTION docdb_delete(low_in integer, high_in integer, batch_num integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$DECLARE
    icount     INTEGER:=0;
    v_count    INTEGER:=0;
    v_batch    text;
    v_batch_id int8;
BEGIN
/*
1.0 anarayanan 25-Sep-2014 DS-454 : Added delete statements for pat_family_pats
2.0 28-Apr-2015 tazhagan_c DS-1625 : Added debug statements to log the progress
*/
v_batch_id:=batch_num;
v_batch := 'Batch#: '||v_batch_id||' Range ['||low_in::text||'-'||high_in::text||'] ';

        select count(*) into v_count
	from docdb.docdb_pats p 
	join docdb_intake.docdb_pats ip
	on p.patnum=ip.patnum 
	and ip.id >= low_in and ip.id < high_in
	and ip.rec_status='D';
	
        if v_count = 0 then
        
        PERFORM docdb.debug('In docdb_delete - No records to delete for range v_low_in:'||low_in||' v_high_in:'||high_in); 

		insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
		values (v_batch_id,'docdb.docdb_delete','No action','No records to delete for range ['||low_in::text||'-'||high_in::text||'] ',0,'D',now());
        else

        PERFORM docdb.debug('In docdb_delete - Deleting from docdb_pats for range v_low_in:'||low_in||' v_high_in:'||high_in); 
		
		with rec_delete as (

			delete from docdb.docdb_pats p 
			    using docdb_intake.docdb_pats ip
			    where p.patnum=ip.patnum 
			    and ip.id >= low_in and ip.id < high_in
			    and ip.rec_status='D' 

			returning p.*

			), pats_log as (
			insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
			select v_batch_id,'docdb.docdb_delete','Deleted','docdb_pats',count(*),'D',now()
			from rec_delete 
						
			), ipcs_del as (
			delete from docdb.docdb_ipcs where pat_id in (SELECT id FROM rec_delete) returning * )

			, ipcs_log as (
			insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
			select v_batch_id,'docdb.docdb_delete','Deleted','docdb_ipcs',count(*),'D',now()
			from ipcs_del ) 			
			
			, classifications_del as (
			delete from docdb.docdb_classifications where pat_id in (SELECT id FROM rec_delete) returning * )

			, classifications_log as (
			insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
			select v_batch_id,'docdb.docdb_delete','Deleted','docdb_classifications',count(*),'D',now()
			from classifications_del ) 

			, natl_classifications_del as (
			delete from docdb.docdb_national_classifications where pat_id in (SELECT id FROM rec_delete) returning * )

			, natl_classifications_log as (
			insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
			select v_batch_id,'docdb.docdb_delete','Deleted','docdb_national_classifications',count(*),'D',now()
			from natl_classifications_del ) 
			
			, citations_del as (
			delete from docdb.docdb_citations where pat_id in (SELECT id FROM rec_delete) returning * )

			, citations_log as (
			insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
			select v_batch_id,'docdb.docdb_delete','Deleted','docdb_citations',count(*),'D',now()
			from citations_del ) 	
				
		       , applicants_del as (
			delete from docdb.docdb_applicants where pat_id in (SELECT id FROM rec_delete) returning * )

			, applicants_log as (
			insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
			select v_batch_id,'docdb.docdb_delete','Deleted','docdb_applicants',count(*),'D',now()
			from applicants_del ) 	
			
		       , invenors_del as (
			delete from docdb.docdb_inventors where pat_id in (SELECT id FROM rec_delete) returning * )

			, invenors_log as (
			insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
			select v_batch_id,'docdb.docdb_delete','Deleted','docdb_invenors',count(*),'D',now()
			from invenors_del ) 

		       , titles_del as (
			delete from docdb.docdb_titles where pat_id in (SELECT id FROM rec_delete) returning * )

			, titles_log as (
			insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
			select v_batch_id,'docdb.docdb_delete','Deleted','docdb_titles',count(*),'D',now()
			from titles_del ) 
			
		       , priority_claims_del as (
			delete from docdb.docdb_priority_claims where pat_id in (SELECT id FROM rec_delete) returning * )

			, priority_claims_log as (
			insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
			select v_batch_id,'docdb.docdb_delete','Deleted','docdb_priority_claims',count(*),'D',now()
			from priority_claims_del ) 			

			, abstracts_del as (	
			delete from docdb.docdb_abstracts where pat_id in (SELECT id FROM rec_delete) returning * ) 
			
			, family_del as (
			delete from docdb_families.pat_family_pats where pat_id in (SELECT id FROM rec_delete) returning * )
						
			insert into docdb.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
			select v_batch_id,'docdb.docdb_delete','Deleted','docdb_abstracts',count(*),'D',now()
			from abstracts_del;
        end if;
        
return 'Batch: '||v_batch_id||' Deleted: Success!';

end;$$;


--
-- Name: docdb_delete_by_pat_id(integer); Type: FUNCTION; Schema: docdb; Owner: -
--

CREATE FUNCTION docdb_delete_by_pat_id(pat_id integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$DECLARE
    icount     INTEGER:=0;
    v_count    INTEGER:=0;
    v_batch    text;
    v_pat_id   int8;
BEGIN
/*
1.0 anarayanan 25-Sep-2014 DS-454 : Added delete statements for pat_family_pats
*/
v_pat_id:= pat_id;
-- hold on to it
	--select x --into v_temp_text 
         --     from dblink( config.dblink_connection('test2.coredb'), 'SELECT docdb_l.create_amend_docdb('||200000107||','||200000107||');')  as temp(x text);	

--EXECUTE 'DROP TABLE IF EXISTS temp_refs;'; 

        select count(*) into v_count
	from docdb.docdb_pats p 
	where p.id =v_pat_id;
	
        if v_count = 0 then
		insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
		values (v_pat_id,'docdb_l.docdb_delete','No action','No records to delete  ',0,'D',now());
        else
		with rec_delete as (

			delete from docdb.docdb_pats p 
			    where p.id=v_pat_id
			returning p.*

			), pats_log as (
			insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
			select v_pat_id,'docdb_l.docdb_delete','Deleted','docdb_pats',count(*),'D',now()
			from rec_delete 
						
			), ipcs_del as (
			delete from docdb.docdb_ipcs where docdb_ipcs.pat_id in (SELECT id FROM rec_delete) returning * )

			, ipcs_log as (
			insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
			select v_pat_id,'docdb_l.docdb_delete','Deleted','docdb_ipcs',count(*),'D',now()
			from ipcs_del ) 			
			
			, classifications_del as (
			delete from docdb.docdb_classifications where docdb_classifications.pat_id in (SELECT id FROM rec_delete) returning * )

			, classifications_log as (
			insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
			select v_pat_id,'docdb_l.docdb_delete','Deleted','docdb_classifications',count(*),'D',now()
			from classifications_del ) 

			, natl_classifications_del as (
			delete from docdb.docdb_national_classifications where docdb_national_classifications.pat_id in (SELECT id FROM rec_delete) returning * )

			, natl_classifications_log as (
			insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
			select v_pat_id,'docdb_l.docdb_delete','Deleted','docdb_national_classifications',count(*),'D',now()
			from natl_classifications_del ) 
			
			, citations_del as (
			delete from docdb.docdb_citations where docdb_citations.pat_id in (SELECT id FROM rec_delete) returning * )

			, citations_log as (
			insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
			select v_pat_id,'docdb_l.docdb_delete','Deleted','docdb_citations',count(*),'D',now()
			from citations_del ) 	
				
		       , applicants_del as (
			delete from docdb.docdb_applicants where docdb_applicants.pat_id in (SELECT id FROM rec_delete) returning * )

			, applicants_log as (
			insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
			select v_pat_id,'docdb_l.docdb_delete','Deleted','docdb_applicants',count(*),'D',now()
			from applicants_del ) 	
			
		       , invenors_del as (
			delete from docdb.docdb_inventors where docdb_inventors.pat_id in (SELECT id FROM rec_delete) returning * )

			, invenors_log as (
			insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
			select v_pat_id,'docdb_l.docdb_delete','Deleted','docdb_invenors',count(*),'D',now()
			from invenors_del ) 

		       , titles_del as (
			delete from docdb.docdb_titles where docdb_titles.pat_id in (SELECT id FROM rec_delete) returning * )

			, titles_log as (
			insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
			select v_pat_id,'docdb_l.docdb_delete','Deleted','docdb_titles',count(*),'D',now()
			from titles_del ) 
			
		       , priority_claims_del as (
			delete from docdb.docdb_priority_claims where docdb_priority_claims.pat_id in (SELECT id FROM rec_delete) returning * )

			, priority_claims_log as (
			insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
			select v_pat_id,'docdb_l.docdb_delete','Deleted','docdb_priority_claims',count(*),'D',now()
			from priority_claims_del ) 			

			, abstracts_del as (	
			delete from docdb.docdb_abstracts where docdb_abstracts.pat_id in (SELECT id FROM rec_delete) returning * ) 
			
			, family_del as (
			delete from docdb_families.pat_family_pats where pat_family_pats.pat_id in (SELECT id FROM rec_delete) returning * )
						
			insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
			select v_pat_id,'docdb_l.docdb_delete','Deleted','docdb_abstracts',count(*),'D',now()
			from abstracts_del;
        end if;
        
return 'pat_id: '||v_pat_id||' Deleted: Success!';
 
end;$$;


--
-- Name: docdb_delete_by_pat_id(integer, character varying); Type: FUNCTION; Schema: docdb; Owner: -
--

CREATE FUNCTION docdb_delete_by_pat_id(pat_id integer, ischema character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$DECLARE
    icount     INTEGER:=0;
    v_count    INTEGER:=0;
    v_batch    text;
    v_pat_id   int8;
BEGIN
/*
1.0 anarayanan 25-Sep-2014 DS-454 : Added delete statements for pat_family_pats
*/
v_pat_id:= pat_id;

if ischema is not null and ischema ='docdb_intake' then
       select count(*) into v_count
from docdb_intake.docdb_pats p
where p.id =v_pat_id;

        if v_count = 0 then
insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
values (v_pat_id,'docdb.docdb_delete_dups','No action','No records to delete in docdb_intake',0,'D',now());
        else
with rec_delete as (

delete from docdb_intake.docdb_pats p
    where p.id=v_pat_id
returning p.*

), pats_log as (
insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
select v_pat_id,'docdb.docdb_delete_dups','Deleted','docdb_intake.docdb_pats',count(*),'D',now()
from rec_delete

), ipcs_del as (
delete from docdb_intake.docdb_ipcs where docdb_ipcs.pat_id in (SELECT id FROM rec_delete) returning * )

, ipcs_log as (
insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
select v_pat_id,'docdb.docdb_delete_dups','Deleted','docdb_intake.docdb_ipcs',count(*),'D',now()
from ipcs_del )

, classifications_del as (
delete from docdb_intake.docdb_classifications where docdb_classifications.pat_id in (SELECT id FROM rec_delete) returning * )

, classifications_log as (
insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
select v_pat_id,'docdb.docdb_delete_dups','Deleted','docdb_intake.docdb_classifications',count(*),'D',now()
from classifications_del )

, natl_classifications_del as (
delete from docdb_intake.docdb_national_classifications where docdb_national_classifications.pat_id in (SELECT id FROM rec_delete) returning * )

, natl_classifications_log as (
insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
select v_pat_id,'docdb.docdb_delete_dups','Deleted','docdb_intake.docdb_national_classifications',count(*),'D',now()
from natl_classifications_del )

, citations_del as (
delete from docdb_intake.docdb_citations where docdb_citations.pat_id in (SELECT id FROM rec_delete) returning * )

, citations_log as (
insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
select v_pat_id,'docdb.docdb_delete_dups','Deleted','docdb_intake.docdb_citations',count(*),'D',now()
from citations_del )

       , applicants_del as (
delete from docdb_intake.docdb_applicants where docdb_applicants.pat_id in (SELECT id FROM rec_delete) returning * )

, applicants_log as (
insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
select v_pat_id,'docdb.docdb_delete_dups','Deleted','docdb_intake.docdb_applicants',count(*),'D',now()
from applicants_del )

       , invenors_del as (
delete from docdb_intake.docdb_inventors where docdb_inventors.pat_id in (SELECT id FROM rec_delete) returning * )

, invenors_log as (
insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
select v_pat_id,'docdb.docdb_delete_dups','Deleted','docdb_intake.docdb_invenors',count(*),'D',now()
from invenors_del )

       , titles_del as (
delete from docdb_intake.docdb_titles where docdb_titles.pat_id in (SELECT id FROM rec_delete) returning * )

, titles_log as (
insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
select v_pat_id,'docdb.docdb_delete_dups','Deleted','docdb_intake.docdb_titles',count(*),'D',now()
from titles_del )

       , priority_claims_del as (
delete from docdb_intake.docdb_priority_claims where docdb_priority_claims.pat_id in (SELECT id FROM rec_delete) returning * )

, priority_claims_log as (
insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
select v_pat_id,'docdb.docdb_delete_dups','Deleted','docdb_intake.docdb_priority_claims',count(*),'D',now()
from priority_claims_del )

, abstracts_del as (
delete from docdb_intake.docdb_abstracts where docdb_abstracts.pat_id in (SELECT id FROM rec_delete) returning * )

, family_del as (
delete from docdb_families.intake_pat_family_pats where intake_pat_family_pats.pat_id in (SELECT id FROM rec_delete) returning * )

insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
select v_pat_id,'docdb.docdb_delete_dups','Deleted','docdb_intake.docdb_abstracts',count(*),'D',now()
from abstracts_del;
        end if;
else
        select count(*) into v_count
from docdb.docdb_pats p
where p.id =v_pat_id;

        if v_count = 0 then
insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
values (v_pat_id,'docdb.docdb_delete_dups','No action','No records to delete',0,'D',now());
        else
with rec_delete as (

delete from docdb.docdb_pats p
    where p.id=v_pat_id
returning p.*

), pats_log as (
insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
select v_pat_id,'docdb.docdb_delete_dups','Deleted','docdb_pats',count(*),'D',now()
from rec_delete

), ipcs_del as (
delete from docdb.docdb_ipcs where docdb_ipcs.pat_id in (SELECT id FROM rec_delete) returning * )

, ipcs_log as (
insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
select v_pat_id,'docdb.docdb_delete_dups','Deleted','docdb_ipcs',count(*),'D',now()
from ipcs_del )

, classifications_del as (
delete from docdb.docdb_classifications where docdb_classifications.pat_id in (SELECT id FROM rec_delete) returning * )

, classifications_log as (
insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
select v_pat_id,'docdb.docdb_delete_dups','Deleted','docdb_classifications',count(*),'D',now()
from classifications_del )

, natl_classifications_del as (
delete from docdb.docdb_national_classifications where docdb_national_classifications.pat_id in (SELECT id FROM rec_delete) returning * )

, natl_classifications_log as (
insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
select v_pat_id,'docdb.docdb_delete_dups','Deleted','docdb_national_classifications',count(*),'D',now()
from natl_classifications_del )

, citations_del as (
delete from docdb.docdb_citations where docdb_citations.pat_id in (SELECT id FROM rec_delete) returning * )

, citations_log as (
insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
select v_pat_id,'docdb.docdb_delete_dups','Deleted','docdb_citations',count(*),'D',now()
from citations_del )

       , applicants_del as (
delete from docdb.docdb_applicants where docdb_applicants.pat_id in (SELECT id FROM rec_delete) returning * )

, applicants_log as (
insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
select v_pat_id,'docdb.docdb_delete_dups','Deleted','docdb_applicants',count(*),'D',now()
from applicants_del )

       , invenors_del as (
delete from docdb.docdb_inventors where docdb_inventors.pat_id in (SELECT id FROM rec_delete) returning * )

, invenors_log as (
insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
select v_pat_id,'docdb.docdb_delete_dups','Deleted','docdb_invenors',count(*),'D',now()
from invenors_del )

       , titles_del as (
delete from docdb.docdb_titles where docdb_titles.pat_id in (SELECT id FROM rec_delete) returning * )

, titles_log as (
insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
select v_pat_id,'docdb.docdb_delete_dups','Deleted','docdb_titles',count(*),'D',now()
from titles_del )

       , priority_claims_del as (
delete from docdb.docdb_priority_claims where docdb_priority_claims.pat_id in (SELECT id FROM rec_delete) returning * )

, priority_claims_log as (
insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
select v_pat_id,'docdb.docdb_delete_dups','Deleted','docdb_priority_claims',count(*),'D',now()
from priority_claims_del )

, abstracts_del as (
delete from docdb.docdb_abstracts where docdb_abstracts.pat_id in (SELECT id FROM rec_delete) returning * )

, family_del as (
delete from docdb_families.pat_family_pats where pat_family_pats.pat_id in (SELECT id FROM rec_delete) returning * )

insert into tds_etl_app.docdb_logs (batch_id,procedure,action,table_name,total_processed,status,created_at)
select v_pat_id,'docdb.docdb_delete_dups','Deleted','docdb_abstracts',count(*),'D',now()
from abstracts_del;
        end if;
end if;

return 'pat_id: '||v_pat_id||' Deleted: Success!';
/*
GET DIAGNOSTICS icount = ROW_COUNT;
INSERT INTO docdb_l.logs (step, table_name, action, status, count, date_created)
VALUES ( 4, 'core.pat_references','Insert '||low_in||'-'||high_in||'', 'Completed',icount, now());

*/
--EXECUTE 'DROP TABLE IF EXISTS temp_refs;';
end;$$;


--
-- Name: docdb_delete_dups(character varying); Type: FUNCTION; Schema: docdb; Owner: -
--

CREATE FUNCTION docdb_delete_dups(patnum character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$DECLARE
    icount     INTEGER:=0;
    v_count    INTEGER:=0;
    v_list     record;
    v_patnum   record;
    vpatnum    varchar;
    v_keep     int8;
BEGIN

if patnum is not null then
	vpatnum:=patnum;

		select max(id) into v_keep
		from docdb.docdb_pats
		where docdb_pats.patnum=vpatnum;
		
		for v_patnum in (select issue_date, id from docdb.docdb_pats
				 where docdb_pats.patnum=vpatnum and id <> v_keep 
				 order by id desc) loop
				 
					update docdb.docdb_pats set
					publication_date_history=publication_date_history||v_patnum.issue_date||'; ',
					updated_at=now()
					where docdb_pats.id=v_keep;

					perform docdb.docdb_delete_by_pat_id(v_patnum.id);
		end loop;								
else
	for v_list in (select docdb_pats.patnum,count(*) from docdb.docdb_pats
		group by docdb_pats.patnum having count(*) >1 ) loop
		
			select max(id) into v_keep
			from docdb.docdb_pats
			where docdb_pats.patnum=v_list.patnum;
			
			for v_patnum in (select issue_date, id from docdb.docdb_pats
				         where docdb_pats.patnum=v_list.patnum and docdb_pats.id <> v_keep 
				         order by docdb_pats.id desc) loop
				         
						update docdb.docdb_pats set
						publication_date_history=publication_date_history||v_patnum.issue_date||'; ',
						updated_at=now()
						where docdb_pats.id=v_keep;

						perform docdb.docdb_delete_by_pat_id(v_patnum.id);
			end loop;								
	end loop;
end if;
        
return ' Deleted: Success!';


end;$$;


--
-- Name: docdb_delete_dups(character varying, character varying); Type: FUNCTION; Schema: docdb; Owner: -
--

CREATE FUNCTION docdb_delete_dups(patnum character varying, ischema character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$DECLARE
    icount     INTEGER:=0;
    v_count    INTEGER:=0;
    v_list     record;
    v_patnum   record;
    v_schema   varchar:='';
    vpatnum    varchar:='';
    v_keep     int8;
BEGIN

if ischema is not null then
	v_schema:=ischema;
	if patnum is not null then
		vpatnum:=patnum;
		

			select max(id) into v_keep
			from docdb_intake.docdb_pats
			where docdb_pats.patnum=vpatnum;
			
			for v_patnum in (select issue_date, id from docdb_intake.docdb_pats
					 where docdb_pats.patnum=vpatnum and id <> v_keep 
					 order by id desc) loop
					 
						update docdb_intake.docdb_pats set
						publication_date_history=publication_date_history||v_patnum.issue_date||'; ',
						updated_at=now()
						where docdb_pats.id=v_keep;

						perform docdb.docdb_delete_by_pat_id(v_patnum.id, v_schema);
			end loop;								
	else
		for v_list in (select docdb_pats.patnum,count(*) from docdb_intake.docdb_pats
			group by docdb_pats.patnum having count(*) >1 ) loop
			
				select max(id) into v_keep
				from docdb_intake.docdb_pats
				where docdb_pats.patnum=v_list.patnum;
				
				for v_patnum in (select docdb_pats.issue_date, docdb_pats.id from docdb_intake.docdb_pats
						 where docdb_pats.patnum=v_list.patnum and docdb_pats.id <> v_keep 
						 order by docdb_pats.id desc) loop
						 
							update docdb_intake.docdb_pats set
							publication_date_history=publication_date_history||v_patnum.issue_date||'; ',
							updated_at=now()
							where docdb_pats.id=v_keep;

							perform docdb.docdb_delete_by_pat_id(v_patnum.id,v_schema);
				end loop;								
		end loop;
	end if;
else

	if patnum is not null then
		vpatnum:=patnum;

			select max(id) into v_keep
			from docdb.docdb_pats
			where docdb_pats.patnum=vpatnum;
			
			for v_patnum in (select issue_date, id from docdb.docdb_pats
					 where docdb_pats.patnum=vpatnum and id <> v_keep 
					 order by id desc) loop
					 
						update docdb.docdb_pats set
						publication_date_history=publication_date_history||v_patnum.issue_date||'; ',
						updated_at=now()
						where docdb_pats.id=v_keep;

						perform docdb.docdb_delete_by_pat_id(v_patnum.id);
			end loop;								
	else
		for v_list in (select docdb_pats.patnum,count(*) from docdb.docdb_pats
			group by docdb_pats.patnum having count(*) >1 ) loop
			
				select max(id) into v_keep
				from docdb.docdb_pats
				where docdb_pats.patnum=v_list.patnum;
				
				for v_patnum in (select docdb_pats.issue_date, docdb_pats.id from docdb.docdb_pats
						 where docdb_pats.patnum=v_list.patnum and docdb_pats.id <> v_keep 
						 order by docdb_pats.id desc) loop
						 
							update docdb.docdb_pats set
							publication_date_history=publication_date_history||v_patnum.issue_date||'; ',
							updated_at=now()
							where docdb_pats.id=v_keep;

							perform docdb.docdb_delete_by_pat_id(v_patnum.id);
				end loop;								
		end loop;
	end if;
end if; -- if schema is not null
        
return ' Deleted: Success!';


end;$$;


--
-- Name: docdb_get_batch_id(character varying, character varying, integer, integer, integer); Type: FUNCTION; Schema: docdb; Owner: -
--

CREATE FUNCTION docdb_get_batch_id(info character varying, fname character varying, low_in integer, high_in integer, brun_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$DECLARE
v_id     	integer:=0;
v_brun_id     	int8:=0;
BEGIN
v_brun_id:=brun_id;

insert into docdb.docdb_batch(run_id,info,range,procedure,created_at,updated_at) 
values (v_brun_id,info,low_in::text||'-'||high_in::text,fname,now(),now())
returning id into v_id;

RETURN v_id;
END;$$;


--
-- Name: docdb_intake_stats(character varying); Type: FUNCTION; Schema: docdb; Owner: -
--

CREATE FUNCTION docdb_intake_stats(param_in character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$DECLARE
    icount             INTEGER:=0;
    v_listing          RECORD; 
    v_result_string    varchar:='';  
    v_result         	varchar;
    v_result2          varchar;
BEGIN
--select docdb.docdb_intake_stats('docdb_intake');

EXECUTE 'select min(id)::text from '||param_in||'.docdb_pats  ' into v_result;
v_result_string:=v_result_string||v_result||' - min(id) in '||param_in||'.docdb_pats '||chr(10);

EXECUTE 'select max(id)::text from '||param_in||'.docdb_pats  ' into v_result;
v_result_string:=v_result_string||v_result||' - max(id) in '||param_in||'.docdb_pats '||chr(10)||chr(10);
             
v_result_string:=v_result_string||' Totals for each intake table: '||chr(10);

for v_listing in (select table_schema||'.'||table_name tname from information_schema.tables  
                 where table_schema = ''||param_in||'' and table_name like 'docdb%' 
                 order by table_name) loop
                
                 EXECUTE 'select count(*)::text from '||v_listing.tname||'' into v_result;
                 v_result_string:=v_result_string||v_result||' - #  records in '||v_listing.tname||' '||chr(10);
	         icount:=icount + 1;

end loop;
/* commenting it for 20% upload, all statuses are C
v_result_string:=v_result_string||' Totals for each status per table: '||chr(10)||chr(10);

EXECUTE 'select count(*)::text from '||param_in||'.docdb_pats where rec_status=''D'' ' into v_result;
                 v_result_string:=v_result_string||v_result||' - #  records in '||param_in||'.docdb_pats with status D'||chr(10);

for v_listing in (select table_schema||'.'||table_name tname from information_schema.tables  
                 where table_schema = ''||param_in||'' and table_name like 'docdb%' 
                -- and table_name not in ('pat_collections','pat_government_interests')
                 order by table_name) loop
                
                 EXECUTE 'select count(*)::text from '||v_listing.tname||' where rec_status=''A'' ' into v_result;
                 v_result_string:=v_result_string||v_result||' - #  records in '||v_listing.tname||' with status A'||chr(10);
                 
                 EXECUTE 'select count(*)::text from '||v_listing.tname||' where rec_status=''C'' ' into v_result;
                 v_result_string:=v_result_string||v_result||' - #  records in '||v_listing.tname||' with status C'||chr(10);                 
	         icount:=icount + 1;

end loop;
*/
return v_result_string;

end;$$;


--
-- Name: docdb_pats_pat_family_processed_trig_func(); Type: FUNCTION; Schema: docdb; Owner: -
--

CREATE FUNCTION docdb_pats_pat_family_processed_trig_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$ 

DECLARE 
	v_count INTEGER;
BEGIN 
/*
 1.0 tazhagan_c 23-Apr-2015 DS-1536 : Trigger to set pat_family_processed flag according to the changes in docdb.docdb_titles table

pat_family_processed=true : a pat_family already exists for that patnum
pat_family_processed is null : pat_family cannot be created for that id since no title is available now in docdb.docdb_titles
pat_family_processed=false : pat_family can be created now/new record and it is ready for processing

*/
    IF (TG_OP = 'INSERT') THEN 
        
			UPDATE docdb.docdb_pats SET pat_family_processed=false 
			WHERE id = NEW.pat_id 
			AND pat_family_processed is NULL;
		
	    RETURN NEW;
    END IF;

    IF (TG_OP = 'DELETE') THEN 
		
		SELECT count(1) INTO v_count
		FROM docdb.docdb_titles WHERE pat_id = OLD.pat_id; 
		
		IF v_count = 0 THEN
			UPDATE docdb.docdb_pats SET pat_family_processed=false 
			WHERE id = OLD.pat_id 
			AND pat_family_processed = true;
		END IF;
		
        RETURN OLD;
    END IF; 

EXCEPTION 
    WHEN data_exception THEN
        RAISE EXCEPTION '[docdb.docdb_pats_pat_family_processed_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[docdb.docdb_pats_pat_family_processed_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[docdb.docdb_pats_pat_family_processed_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: docdb_priority_claim_delete_trig_func(); Type: FUNCTION; Schema: docdb; Owner: -
--

CREATE FUNCTION docdb_priority_claim_delete_trig_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
 v_count INT := 0;
BEGIN
    IF (TG_OP = 'UPDATE') THEN
      RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
     IF OLD.data_format = 'docdb' THEN
      UPDATE docdb.docdb_pats set pat_family_processed = false WHERE id = OLD.pat_id;
     END IF;
     RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
     RETURN NEW;
    ELSE
        RAISE EXCEPTION '[docdb..docdb_priority_claim_delete_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[docdb..docdb_priority_claim_delete_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[docdb..docdb_priority_claim_delete_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[docdb..docdb_priority_claim_delete_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: docdb_run_all(integer, integer, integer); Type: FUNCTION; Schema: docdb; Owner: -
--

CREATE FUNCTION docdb_run_all(low_in integer, high_in integer, run_id integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$DECLARE
v_return       text:='';
v_temp_text    text;  
v_interval 	integer:=20000; -- for now
v_run_id 	integer:=0;
v_high_in  	integer:=0;
v_low_in   	integer:=0;
v_high     	integer:=0;
v_low      	integer:=0;
v_dups          integer:=0;
v_max_range     integer:=0;

BEGIN
v_run_id:=run_id;

select count(patnum) into v_dups
from (select patnum,count(*) from docdb_intake.docdb_pats
group by patnum
having count(*) >1) bla;

if v_dups > 0 then
             select x into v_temp_text 
              from dblink( config.dblink_connection('coredb'), 'SELECT docdb.docdb_delete_dups(null,''docdb_intake'');') 
              as temp(x text);	

	--perform docdb.docdb_delete_dups(null,'docdb_intake');
end if;

if (low_in is null and high_in is null) then
	EXECUTE 'select min(id)::text from docdb_intake.docdb_pats' into v_low_in;
        EXECUTE 'select (max(id)+1)::text from docdb_intake.docdb_pats' into v_high_in;        
else
	v_low_in:= low_in;
	if high_in is null then
             EXECUTE 'select (max(id)+1)::text from docdb_intake.docdb_pats' into v_high_in;    
	else
	     v_high_in:= high_in;
	end if;
	v_low:=low_in;
end if;
if v_high_in <> 0 then
     v_max_range:=case when round(v_high_in/v_interval)=0 then 1 else round(v_high_in/v_interval)+1 end;    
end if;

    FOR i IN 1..v_max_range LOOP
        v_high:= v_low_in + v_interval*i; 
        if v_high <= v_high_in THEN

             select x into v_temp_text 
              from dblink( config.dblink_connection('coredb'), 'SELECT docdb.docdb_run_batch('||v_low||','||v_high||','||v_run_id||');') 
              as temp(x text);	
              
              v_return:=v_return||'Completed range: '||v_low||'-'||v_high||' '||chr(10);
              v_low:=v_high;
              i:= i + 1;
        else  -- 
		v_high:= v_low_in + v_interval*(i-1);
		if (v_high_in - v_high) > 0 then

			select x into v_temp_text 
			from dblink( config.dblink_connection('coredb'), 'SELECT docdb.docdb_run_batch('||v_low||','||(v_high + (v_high_in - v_high))||','||v_run_id||');') 
			as temp(x text);	
			v_return:=v_return||'Completed range: '||v_low||'-'||(v_high + (v_high_in - v_high))::text||' '||chr(10);
			EXIT;
		end if;
              
        end if;  

    END LOOP;
    RETURN v_return;
END;$$;


--
-- Name: docdb_run_batch(integer, integer, integer); Type: FUNCTION; Schema: docdb; Owner: -
--

CREATE FUNCTION docdb_run_batch(low_in integer, high_in integer, brun_id integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*
1.0 anarayanan/tazhagan_c 28-Apr-2015 DS-1625 : Added debug statements to log the progress
*/DECLARE
v_return       text:='';
v_temp_text    text;  
v_interval 	integer:=20000; -- range
v_high_in  	integer:=0;
v_low_in   	integer:=0;
v_id     	integer:=0;
v_brun_id     	integer:=0;
v_text		text;

BEGIN
v_low_in:= low_in;
v_high_in:= high_in;
v_brun_id:=brun_id;

v_text:='Database:'||current_database()||' Schema:'||current_schema()||' User:'||current_user;

    --  select x into v_id from dblink( config.dblink_connection('test2.coredb'), 
   --   'SELECT docdb.docdb_get_batch_id('''||v_text||''',''docdb.docdb_run_batch'', '||v_low_in||','||v_high_in||','||v_brun_id||');') as temp(x integer);

      v_id:=docdb.docdb_get_batch_id(v_text,'docdb.docdb_run_batch', v_low_in,v_high_in,v_brun_id);

--RAISE NOTICE 'v_id: [%]', v_id;
      PERFORM docdb.debug('docdb_run_batch v_id:' || v_id||' v_low_in:'||v_low_in||' v_high_in:'||v_high_in, v_brun_id);     

      PERFORM docdb.docdb_delete(v_low_in,v_high_in,v_id);
      PERFORM docdb.debug('docdb_run_batch After docdb_delete' , v_brun_id);
--RAISE NOTICE 'delete completed: [%]',v_low_in||' '||v_high_in||' '||v_id;
      PERFORM docdb.docdb_create(v_low_in,v_high_in,v_id);
      PERFORM docdb.debug('docdb_run_batch After docdb_create' , v_brun_id);
--RAISE NOTICE 'create completed: %]',v_low_in||' '||v_high_in||' '||v_id;
      PERFORM docdb.docdb_amend(v_low_in,v_high_in,v_id);
      PERFORM docdb.debug('docdb_run_batch After docdb_amend' , v_brun_id);
--RAISE NOTICE 'amend completed: [%]',v_low_in||' '||v_high_in||' '||v_id;
    
      	
     v_return:=v_return||' Batch '||v_id||' processed';

    RETURN v_return;
END;$$;


--
-- Name: log_data_partition_trigger(); Type: FUNCTION; Schema: docdb; Owner: -
--

CREATE FUNCTION log_data_partition_trigger() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
    DECLARE
        v_this_month timestamp;
        v_next_month timestamp;
        v_table_name varchar;
        v_schema_table_name varchar;
        v_drop_table_name varchar;
    BEGIN
        v_this_month := to_char(current_timestamp, 'yyyy-mm-') || '01';
        v_next_month := to_char(current_timestamp + interval '1 month', 'yyyy-mm-') || '01';
        v_table_name := 'log_data_' || to_char(current_timestamp, 'yyyymm');
        v_schema_table_name := 'docdb.log_data_' || to_char(current_timestamp, 'yyyymm');
        v_drop_table_name := 'docdb.log_data_' || to_char(current_timestamp - interval '12 months', 'yyyymm');

        EXECUTE 'INSERT INTO ' || v_schema_table_name ||' VALUES (($1).*)' USING NEW ;
        RETURN NULL;

    EXCEPTION
        WHEN undefined_table THEN
            EXECUTE 'CREATE TABLE IF NOT EXISTS ' || v_schema_table_name || ' ( CHECK ( (created_at >= ''' || v_this_month || ''') AND (created_at < ''' || v_next_month || ''') )) INHERITS (docdb.log_data)';
            EXECUTE 'CREATE INDEX ' || v_table_name || '_created_at_idx ON ' || v_schema_table_name  || '(created_at)';
            EXECUTE 'CREATE INDEX ' || v_table_name || '_created_app_run_idx ON ' || v_schema_table_name  || '(app_id, run_id)';
            EXECUTE 'DROP TABLE IF EXISTS ' || v_drop_table_name;
            EXECUTE 'INSERT INTO ' || v_schema_table_name ||' VALUES (($1).*)' USING NEW ;
            RETURN NULL;
    END;
    $_$;


SET search_path = ptab, pg_catalog;

--
-- Name: case_status_change_tr_function(); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION case_status_change_tr_function() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

  /*
  1.0 vpemamraju 16-06-2015 DS-4140 New trigger to capture changes in case status
  */
  IF (TG_OP = 'UPDATE') THEN

    IF  coalesce(old.status, '') != coalesce(new.status, '') THEN
      insert into ptab.ptab_case_status_changes(ptab_case_id,case_status,date_entered,created_at,created_by,updated_at,updated_by)
      select NEW.id,NEW.status,clock_timestamp(),clock_timestamp(),current_user,clock_timestamp(),current_user;
    END IF;

  ELSIF (TG_OP = 'INSERT') THEN
      insert into ptab.ptab_case_status_changes(ptab_case_id,case_status,date_entered,created_at,created_by,updated_at,updated_by)
      select NEW.id,NEW.status,clock_timestamp(),clock_timestamp(),current_user,clock_timestamp(),current_user;

  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: delete_ptab_parties_tab(integer, integer); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION delete_ptab_parties_tab(p_ptab_parties_id integer, p_ptab_case_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$ DECLARE
  deleted_rows INTEGER := 0 ;
BEGIN
  /*
  1.0 2015-02-19 aprakash_c DS-809: New Function delete_ptab_parties_tab Created for deleting the existing entries in ptab_parties
  */
  DELETE
  FROM
    ptab.ptab_parties
  WHERE
  ID = p_ptab_parties_id AND ptab_case_id=p_ptab_case_id ; GET DIAGNOSTICS deleted_rows = ROW_COUNT ;
IF deleted_rows > 0 THEN
  RETURN p_ptab_parties_id ;
ELSE
  RETURN - 1 ;
END
IF ; EXCEPTION
WHEN OTHERS THEN
  RAISE NOTICE '% %',
  SQLSTATE,
  sqlerrm ; RETURN - 1 ;
END ; $$;


--
-- Name: find_ptab_case_type(integer[], character varying[]); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION find_ptab_case_type(p_ptab_ids integer[] DEFAULT NULL::integer[], p_case_nums character varying[] DEFAULT NULL::character varying[]) RETURNS TABLE(ptab_id integer, case_num character varying, case_type_name character varying, case_type_id integer)
    LANGUAGE plpgsql
    AS $_$
DECLARE
  v_sql text := '';
BEGIN

/*

1.1 anarayanan 10-May-2016 DS-3425 : Created this API based on core.find_lit_case_type
1.2 anarayanan 25-May-2016 DS-3425 : Set type as Pending Review when no PO found with a mapped entity.
2.0 tazhagan_c 25-Jul-2017 DS-5624 : Include Likely Patent Owner also while calculating ptab_case_type value
3.0 tazhagan_c 02-Aug-2017 DS-5697 : Change of precedence for inventor case type and remove Real Party in Interest from all case type calculations
3.1 tazhagan_c 07-Aug-2017 DS-5697 : Changes as per the comments by Ed. Pending review (instead of Operating Company) should be the case type when no condition matches

*/

  v_sql := '
    WITH in_ptabs AS (
      SELECT
        pc. ID AS ptab_id,
        pc.case_num,
        pc.filing_date
      FROM
        ptab.ptab_cases pc
      WHERE
      ( $1 IS NULL  AND $2 IS NULL )
      OR pc. ID = ANY ($1)
      OR pc.case_num = ANY ($2)
      ),
      all_parties AS (
      SELECT
        ip.ptab_id,
        ip.case_num,
        aed.ent_id,
        aed.ent_type_id,
        et.name as ent_type,
        ppt.name as ptab_party_type
      FROM
        in_ptabs ip
      INNER JOIN ptab.ptab_parties pp ON ip.ptab_id = pp.ptab_case_id AND pp.missing_from_source_date IS NULL
      INNER JOIN ptab.ptab_party_types ppt ON pp.ptab_party_type_id = ppt.id and ppt.name in (''Patent Owner'',''Petitioner'')
      INNER JOIN core.alias_ent_details aed ON pp.alias_id = aed.alias_id
      LEFT JOIN core.ent_types et ON aed.ent_type_id = et.id
        UNION
      SELECT
        ip.ptab_id,
        ip.case_num,
        aed.ent_id,
        aed.ent_type_id,
        et.name as ent_type,
        ''Patent Owner'' as ptab_party_type
      FROM
        in_ptabs ip
      INNER JOIN rpx_reporting.all_ptab ap ON ip.ptab_id = ap.ptab_case_id
      INNER JOIN core.alias_ent_details aed ON aed.alias_id = ANY(ap.patent_owner_alias_ids)
      LEFT JOIN core.ent_types et ON aed.ent_type_id = et.id
      WHERE ap.is_likely_patent_owner
      ),
      no_po_as_pr AS (
      SELECT
        ip.ptab_id,
        ip.case_num,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        in_ptabs ip
      INNER JOIN core.lit_types lt ON (lt. NAME = ''Pending Review'')
      WHERE NOT EXISTS
        (
        SELECT 1 FROM all_parties ap WHERE ap.ptab_party_type in (''Patent Owner'') AND ap.ptab_id = ip.ptab_id AND ap.ent_id is not null
        )
      GROUP BY 1,2,3,4
     ),
     npe AS (
      SELECT
        ip.ptab_id,
        ip.case_num,
        ip.filing_date,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        in_ptabs ip
      INNER JOIN all_parties ap ON ip.ptab_id = ap.ptab_id
      INNER JOIN core.ent_subtypes_map esm ON
      (
        esm.ent_id = ap.ent_id
        AND ip.filing_date BETWEEN COALESCE (esm.start_date,''1900-01-01'') AND COALESCE (esm.end_date, ''3000-01-01'')
      )
      INNER JOIN core.ent_subtypes es ON (es. ID = esm.ent_subtype_id AND es. NAME = ''NPE'')
      INNER JOIN core.lit_types lt ON (lt. NAME = ''NPE'')
      WHERE NOT EXISTS (SELECT 1 FROM no_po_as_pr pr where pr.ptab_id = ip.ptab_id)
      GROUP BY 1,2,3,4,5
    ),
     plc AS (
      SELECT
        ip.ptab_id,
        ip.case_num,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        (
          SELECT ptab_id, case_num, filing_date FROM in_ptabs EXCEPT
          SELECT ptab_id, case_num, filing_date FROM npe
        ) ip
      INNER JOIN all_parties ap ON
        (
        ap.ptab_id = ip.ptab_id
        AND ap.ptab_party_type in (''Patent Owner'')
        )
      INNER JOIN core.lit_types lt ON (lt. NAME = ''Patent Licensing Company'')
      INNER JOIN core.ent_subtypes_map esm ON
      (
        esm.ent_id = ap.ent_id
        AND ip.filing_date BETWEEN COALESCE (esm.start_date,''1900-01-01'') AND COALESCE (esm.end_date, ''3000-01-01'')
      )
      INNER JOIN core.ent_subtypes es ON (es. ID = esm.ent_subtype_id AND es. NAME = ''Patent Licensing Company'')
      WHERE NOT EXISTS (SELECT 1 FROM no_po_as_pr pr where pr.ptab_id = ip.ptab_id)
      GROUP BY 1,2,3,4
    ),
     university AS (
      SELECT
        ip.ptab_id,
        ip.case_num,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        (
          SELECT ptab_id, case_num FROM in_ptabs EXCEPT
          SELECT ptab_id, case_num FROM npe EXCEPT
          SELECT ptab_id, case_num FROM plc
        ) ip
      INNER JOIN all_parties ap ON
        (
        ap.ptab_id = ip.ptab_id
        AND ap.ptab_party_type in (''Patent Owner'')
        AND ap.ent_type IN (''University'')
        )
      INNER JOIN core.lit_types lt ON (lt. NAME = ''UNI'')
      WHERE NOT EXISTS (SELECT 1 FROM no_po_as_pr pr where pr.ptab_id = ip.ptab_id)
      GROUP BY 1,2,3,4
    ),
     oc AS (
      SELECT
        ip.ptab_id,
        ip.case_num,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        (
          SELECT ptab_id, case_num FROM in_ptabs EXCEPT
          SELECT ptab_id, case_num FROM npe EXCEPT
          SELECT ptab_id, case_num FROM plc EXCEPT
          SELECT ptab_id, case_num FROM university
        ) ip
      INNER JOIN all_parties ap ON
        (
        ap.ptab_id = ip.ptab_id
        )
      AND ap.ptab_party_type in (''Patent Owner'')
        AND ap.ent_type IN (''Company'')
        INNER JOIN core.lit_types lt ON (lt. NAME = ''Operating Company'')
      WHERE NOT EXISTS (SELECT 1 FROM no_po_as_pr pr where pr.ptab_id = ip.ptab_id)
      GROUP BY 1,2,3,4
    ),
     inventor AS (
      SELECT
        ip.ptab_id,
        ip.case_num,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        (
          SELECT ptab_id, case_num FROM in_ptabs EXCEPT
          SELECT ptab_id, case_num FROM npe EXCEPT
          SELECT ptab_id, case_num FROM plc EXCEPT
          SELECT ptab_id, case_num FROM university EXCEPT
          SELECT ptab_id, case_num FROM oc
        ) ip
      INNER JOIN all_parties ap ON
        (
        ap.ptab_id = ip.ptab_id
        AND ap.ptab_party_type in (''Patent Owner'')
        AND ap.ent_type IN (''Individual'')
        )
      INNER JOIN ptab.ptab_cases pc ON pc. ID = ip.ptab_id
      INNER JOIN core.pats ON (
        pats.app_num_country = ''US'' || pc.application_num
        AND pc.stripped_patnum IS NULL
        OR pats.stripped_patnum = pc.stripped_patnum
      )
      INNER JOIN core.aliases al_all ON al_all.ent_id = ap.ent_id
      INNER JOIN core.pats_aliases_map pam ON (pam.pat_id = pats. ID)
      INNER JOIN core.aliases pa ON (
        pa. ID = pam.alias_id
        AND pa.core_name = al_all.core_name
      )
      INNER JOIN core.pats_aliases_relationship_types part ON (part. ID = pam.pats_aliases_relationship_type_id AND part. NAME = ''Inventor'')
      INNER JOIN core.lit_types lt ON (lt. NAME = ''INV'')
      WHERE NOT EXISTS (SELECT 1 FROM no_po_as_pr pr where pr.ptab_id = ip.ptab_id)
      AND NOT EXISTS (
        SELECT 1 FROM all_parties ap
        WHERE ap.ptab_id = ip.ptab_id
        AND ap.ptab_party_type in (''Patent Owner'')
        AND ap.ent_type <> ''Individual''
      )
      GROUP BY 1,2,3,4
    ),
     gov AS (
      SELECT
        ip.ptab_id,
        ip.case_num,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        (
          SELECT ptab_id, case_num FROM in_ptabs EXCEPT
          SELECT ptab_id, case_num FROM npe EXCEPT
          SELECT ptab_id, case_num FROM plc EXCEPT
          SELECT ptab_id, case_num FROM university EXCEPT
          SELECT ptab_id, case_num FROM oc EXCEPT
          SELECT ptab_id, case_num FROM inventor
        ) ip
      INNER JOIN all_parties ap ON
        (
        ap.ptab_id = ip.ptab_id
        AND ap.ptab_party_type in ( ''Patent Owner'')
        AND ap.ent_type IN (''Government'')
        )
      INNER JOIN core.lit_types lt ON (lt. NAME = ''Government'')
    WHERE
      NOT EXISTS (
        SELECT
          1
        FROM
          all_parties ap
        WHERE
          ap.ptab_id = ip.ptab_id
        AND ap.ptab_party_type in (''Patent Owner'')
        AND ap.ent_type <> ''Government''
      )
      AND NOT EXISTS (SELECT 1 FROM no_po_as_pr pr where pr.ptab_id = ip.ptab_id)
      GROUP BY 1,2,3,4
    ),
     pending_review AS (
      SELECT
        ip.ptab_id,
        ip.case_num,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        (
          SELECT ptab_id, case_num FROM in_ptabs EXCEPT
          SELECT ptab_id, case_num FROM npe EXCEPT
          SELECT ptab_id, case_num FROM plc EXCEPT
          SELECT ptab_id, case_num FROM university EXCEPT
          SELECT ptab_id, case_num FROM oc EXCEPT
          SELECT ptab_id, case_num FROM inventor EXCEPT
          SELECT ptab_id, case_num FROM gov
        ) ip
        INNER JOIN core.lit_types lt ON (lt.name=''Pending Review'')
        WHERE NOT EXISTS (SELECT 1 FROM no_po_as_pr pr where pr.ptab_id = ip.ptab_id)
    )
    SELECT ptab_id, case_num, case_type_name, case_type_id FROM no_po_as_pr UNION ALL
    SELECT ptab_id, case_num, case_type_name, case_type_id FROM npe UNION ALL
    SELECT ptab_id, case_num, case_type_name, case_type_id FROM plc UNION ALL
    SELECT ptab_id, case_num, case_type_name, case_type_id FROM university UNION ALL
    SELECT ptab_id, case_num, case_type_name, case_type_id FROM oc UNION ALL
    SELECT ptab_id, case_num, case_type_name, case_type_id FROM inventor UNION ALL
    SELECT ptab_id, case_num, case_type_name, case_type_id FROM gov UNION ALL
    SELECT ptab_id, case_num, case_type_name, case_type_id FROM pending_review
    ORDER BY 1';

RETURN QUERY EXECUTE v_sql USING p_ptab_ids, p_case_nums;

EXCEPTION WHEN OTHERS THEN RAISE;
END;
$_$;


--
-- Name: find_ptab_case_type_new(integer[], character varying[]); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION find_ptab_case_type_new(p_ptab_ids integer[] DEFAULT NULL::integer[], p_case_nums character varying[] DEFAULT NULL::character varying[]) RETURNS TABLE(ptab_id integer, case_num character varying, case_type_name character varying, case_type_id integer)
    LANGUAGE plpgsql
    AS $_$
DECLARE
  v_sql text := '';
BEGIN

/*

1.1 anarayanan 10-May-2016 DS-3425 : Created this API based on core.find_lit_case_type
1.2 anarayanan 25-May-2016 DS-3425 : Set type as Pending Review when no PO found with a mapped entity.
2.0 tazhagan_c 25-Jul-2017 DS-5624 : Include Likely Patent Owner also while calculating ptab_case_type value
3.0 tazhagan_c 02-Aug-2017 DS-5697 : Change of precedence for inventor case type and remove Real Party in Interest from all case type calculations
3.1 tazhagan_c 07-Aug-2017 DS-5697 : Changes as per the comments by Ed. Pending review (instead of Operating Company) should be the case type when no condition matches

*/

  v_sql := '
    WITH in_ptabs AS (
      SELECT
        pc. ID AS ptab_id,
        pc.case_num,
        pc.filing_date
      FROM
        ptab.ptab_cases pc
      WHERE
      ( $1 IS NULL  AND $2 IS NULL )
      OR pc. ID = ANY ($1)
      OR pc.case_num = ANY ($2)
      ),
      all_parties AS (
      SELECT
        ip.ptab_id,
        ip.case_num,
        aed.ent_id,
        aed.ent_type_id,
        et.name as ent_type,
        ppt.name as ptab_party_type
      FROM
        in_ptabs ip
      INNER JOIN ptab.ptab_parties pp ON ip.ptab_id = pp.ptab_case_id AND pp.missing_from_source_date IS NULL
      INNER JOIN ptab.ptab_party_types ppt ON pp.ptab_party_type_id = ppt.id and ppt.name in (''Patent Owner'',''Petitioner'')
      INNER JOIN core.alias_ent_details aed ON pp.alias_id = aed.alias_id
      LEFT JOIN core.ent_types et ON aed.ent_type_id = et.id
        UNION
      SELECT
        ip.ptab_id,
        ip.case_num,
        aed.ent_id,
        aed.ent_type_id,
        et.name as ent_type,
        ''Patent Owner'' as ptab_party_type
      FROM
        in_ptabs ip
      INNER JOIN rpx_reporting.all_ptab ap ON ip.ptab_id = ap.ptab_case_id
      INNER JOIN core.alias_ent_details aed ON aed.alias_id = ANY(ap.patent_owner_alias_ids)
      LEFT JOIN core.ent_types et ON aed.ent_type_id = et.id
      WHERE ap.is_likely_patent_owner
      ),
      no_po_as_pr AS (
      SELECT
        ip.ptab_id,
        ip.case_num,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        in_ptabs ip
      INNER JOIN core.lit_types lt ON (lt. NAME = ''Pending Review'')
      WHERE NOT EXISTS
        (
        SELECT 1 FROM all_parties ap WHERE ap.ptab_party_type in (''Patent Owner'') AND ap.ptab_id = ip.ptab_id AND ap.ent_id is not null
        )
      GROUP BY 1,2,3,4
     ),
     npe AS (
      SELECT
        ip.ptab_id,
        ip.case_num,
        ip.filing_date,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        in_ptabs ip
      INNER JOIN all_parties ap ON ip.ptab_id = ap.ptab_id
      INNER JOIN core.ent_subtypes_map esm ON
      (
        esm.ent_id = ap.ent_id
        AND ip.filing_date BETWEEN COALESCE (esm.start_date,''1900-01-01'') AND COALESCE (esm.end_date, ''3000-01-01'')
      )
      INNER JOIN core.ent_subtypes es ON (es. ID = esm.ent_subtype_id AND es. NAME = ''NPE'')
      INNER JOIN core.lit_types lt ON (lt. NAME = ''NPE'')
      WHERE NOT EXISTS (SELECT 1 FROM no_po_as_pr pr where pr.ptab_id = ip.ptab_id)
      GROUP BY 1,2,3,4,5
    ),
     plc AS (
      SELECT
        ip.ptab_id,
        ip.case_num,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        (
          SELECT ptab_id, case_num, filing_date FROM in_ptabs EXCEPT
          SELECT ptab_id, case_num, filing_date FROM npe
        ) ip
      INNER JOIN all_parties ap ON
        (
        ap.ptab_id = ip.ptab_id
        AND ap.ptab_party_type in (''Patent Owner'')
        )
      INNER JOIN core.lit_types lt ON (lt. NAME = ''Patent Licensing Company'')
      INNER JOIN core.ent_subtypes_map esm ON
      (
        esm.ent_id = ap.ent_id
        AND ip.filing_date BETWEEN COALESCE (esm.start_date,''1900-01-01'') AND COALESCE (esm.end_date, ''3000-01-01'')
      )
      INNER JOIN core.ent_subtypes es ON (es. ID = esm.ent_subtype_id AND es. NAME = ''Patent Licensing Company'')
      WHERE NOT EXISTS (SELECT 1 FROM no_po_as_pr pr where pr.ptab_id = ip.ptab_id)
      GROUP BY 1,2,3,4
    ),
     university AS (
      SELECT
        ip.ptab_id,
        ip.case_num,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        (
          SELECT ptab_id, case_num FROM in_ptabs EXCEPT
          SELECT ptab_id, case_num FROM npe EXCEPT
          SELECT ptab_id, case_num FROM plc
        ) ip
      INNER JOIN all_parties ap ON
        (
        ap.ptab_id = ip.ptab_id
        AND ap.ptab_party_type in (''Patent Owner'')
        AND ap.ent_type IN (''University'')
        )
      INNER JOIN core.lit_types lt ON (lt. NAME = ''UNI'')
      WHERE NOT EXISTS (SELECT 1 FROM no_po_as_pr pr where pr.ptab_id = ip.ptab_id)
      GROUP BY 1,2,3,4
    ),
     oc AS (
      SELECT
        ip.ptab_id,
        ip.case_num,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        (
          SELECT ptab_id, case_num FROM in_ptabs EXCEPT
          SELECT ptab_id, case_num FROM npe EXCEPT
          SELECT ptab_id, case_num FROM plc EXCEPT
          SELECT ptab_id, case_num FROM university
        ) ip
      INNER JOIN all_parties ap ON
        (
        ap.ptab_id = ip.ptab_id
        )
      AND ap.ptab_party_type in (''Patent Owner'')
        AND ap.ent_type IN (''Company'')
        INNER JOIN core.lit_types lt ON (lt. NAME = ''Operating Company'')
      WHERE NOT EXISTS (SELECT 1 FROM no_po_as_pr pr where pr.ptab_id = ip.ptab_id)
      GROUP BY 1,2,3,4
    ),
     inventor AS (
      SELECT
        ip.ptab_id,
        ip.case_num,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        (
          SELECT ptab_id, case_num FROM in_ptabs EXCEPT
          SELECT ptab_id, case_num FROM npe EXCEPT
          SELECT ptab_id, case_num FROM plc EXCEPT
          SELECT ptab_id, case_num FROM university EXCEPT
          SELECT ptab_id, case_num FROM oc
        ) ip
      INNER JOIN all_parties ap ON
        (
        ap.ptab_id = ip.ptab_id
        AND ap.ptab_party_type in (''Patent Owner'')
        AND ap.ent_type IN (''Individual'')
        )
      INNER JOIN ptab.ptab_cases pc ON pc. ID = ip.ptab_id
      INNER JOIN core.pats ON (
        pats.app_num_country = ''US'' || pc.application_num
        AND pc.stripped_patnum IS NULL
        OR pats.stripped_patnum = pc.stripped_patnum
      )
      INNER JOIN core.aliases al_all ON al_all.ent_id = ap.ent_id
      INNER JOIN core.pats_aliases_map pam ON (pam.pat_id = pats. ID)
      INNER JOIN core.aliases pa ON (
        pa. ID = pam.alias_id
        AND pa.core_name = al_all.core_name
      )
      INNER JOIN core.pats_aliases_relationship_types part ON (part. ID = pam.pats_aliases_relationship_type_id AND part. NAME = ''Inventor'')
      INNER JOIN core.lit_types lt ON (lt. NAME = ''INV'')
      WHERE NOT EXISTS (SELECT 1 FROM no_po_as_pr pr where pr.ptab_id = ip.ptab_id)
      AND NOT EXISTS (
        SELECT 1 FROM all_parties ap
        WHERE ap.ptab_id = ip.ptab_id
        AND ap.ptab_party_type in (''Patent Owner'')
        AND ap.ent_type <> ''Individual''
      )
      GROUP BY 1,2,3,4
    ),
     gov AS (
      SELECT
        ip.ptab_id,
        ip.case_num,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        (
          SELECT ptab_id, case_num FROM in_ptabs EXCEPT
          SELECT ptab_id, case_num FROM npe EXCEPT
          SELECT ptab_id, case_num FROM plc EXCEPT
          SELECT ptab_id, case_num FROM university EXCEPT
          SELECT ptab_id, case_num FROM oc EXCEPT
          SELECT ptab_id, case_num FROM inventor
        ) ip
      INNER JOIN all_parties ap ON
        (
        ap.ptab_id = ip.ptab_id
        AND ap.ptab_party_type in ( ''Patent Owner'')
        AND ap.ent_type IN (''Government'')
        )
      INNER JOIN core.lit_types lt ON (lt. NAME = ''Government'')
    WHERE
      NOT EXISTS (
        SELECT
          1
        FROM
          all_parties ap
        WHERE
          ap.ptab_id = ip.ptab_id
        AND ap.ptab_party_type in (''Patent Owner'')
        AND ap.ent_type <> ''Government''
      )
      AND NOT EXISTS (SELECT 1 FROM no_po_as_pr pr where pr.ptab_id = ip.ptab_id)
      GROUP BY 1,2,3,4
    ),
     pending_review AS (
      SELECT
        ip.ptab_id,
        ip.case_num,
        lt. NAME AS case_type_name,
        lt. ID AS case_type_id
      FROM
        (
          SELECT ptab_id, case_num FROM in_ptabs EXCEPT
          SELECT ptab_id, case_num FROM npe EXCEPT
          SELECT ptab_id, case_num FROM plc EXCEPT
          SELECT ptab_id, case_num FROM university EXCEPT
          SELECT ptab_id, case_num FROM oc EXCEPT
          SELECT ptab_id, case_num FROM inventor EXCEPT
          SELECT ptab_id, case_num FROM gov
        ) ip
        INNER JOIN core.lit_types lt ON (lt.name=''Pending Review'')
        WHERE NOT EXISTS (SELECT 1 FROM no_po_as_pr pr where pr.ptab_id = ip.ptab_id)
    )
    SELECT ptab_id, case_num, case_type_name, case_type_id FROM no_po_as_pr UNION ALL
    SELECT ptab_id, case_num, case_type_name, case_type_id FROM npe UNION ALL
    SELECT ptab_id, case_num, case_type_name, case_type_id FROM plc UNION ALL
    SELECT ptab_id, case_num, case_type_name, case_type_id FROM university UNION ALL
    SELECT ptab_id, case_num, case_type_name, case_type_id FROM oc UNION ALL
    SELECT ptab_id, case_num, case_type_name, case_type_id FROM inventor UNION ALL
    SELECT ptab_id, case_num, case_type_name, case_type_id FROM gov UNION ALL
    SELECT ptab_id, case_num, case_type_name, case_type_id FROM pending_review
    ORDER BY 1';

RETURN QUERY EXECUTE v_sql USING p_ptab_ids, p_case_nums;

EXCEPTION WHEN OTHERS THEN RAISE;
END;
$_$;


--
-- Name: get_new_updated_cases(integer); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION get_new_updated_cases(p_job_id integer DEFAULT 0) RETURNS TABLE(case_num character varying)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$ 
    DECLARE v_new_ptab_start_time TIMESTAMP := NULL;
BEGIN
/*
1.0 vpemmaraju 04-Dec-2015 DS-2882 : Gets case_nums which have undergone updates or are new cases 
*/
 SELECT now()   INTO v_new_ptab_start_time;
RETURN QUERY
WITH
    t AS
    (
        SELECT to_timestamp(property_value, 'YYYY/MM/DD HH24:MI:SS.US') AS old_start_time
        FROM    ptab.ptab_etl_properties
        WHERE  property_name = 'PTAB_START_TIME'
    )
    ,   upd AS
    ( 
        UPDATE ptab.ptab_etl_properties
        SET  property_value = v_new_ptab_start_time::VARCHAR ,
                updated_at=clock_timestamp(),
                job_id=COALESCE(p_job_id,0)
        WHERE property_name = 'PTAB_START_TIME' AND property_datatype = 'TIMESTAMP'
    )
SELECT
    cd.case_num
FROM  ptab_staging.ptab_case_details cd ,t
WHERE   updated_at >=t.old_start_time - INTERVAL '30 minutes' --its ok if we get last processed cases.ETL will take care of it.
GROUP BY   cd.case_num
UNION
SELECT c.case_num
FROM     ptab_staging.ptab_cases c,t
WHERE   updated_at >=t.old_start_time - INTERVAL '30 minutes' --its ok if we get last processed cases.ETL will take care of it.
GROUP BY   c.case_num ;  
		
END;
$$;


--
-- Name: get_ptab_campaign_details(integer); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION get_ptab_campaign_details(p_ptab_campaign_id integer) RETURNS TABLE(campaign_name text, rep_patent_owner_id integer, rep_patent_owner_name character varying, rep_patent_owner_id_type text)
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
v_sql text := '';
BEGIN
    /*
    1.0 anarayanan 31-Oct-2016 DS-4530 Campaign details for a ptab campaign

    Usage
    SELECT * FROM ptab.get_ptab_campaign_details (2002490)
    */
    v_sql := '
        WITH rep_patnum AS (
            SELECT
                ptab_camp.ptab_campaign_id AS campaign_id,
                MIN (
                    COALESCE (
                        pc.stripped_patnum,
                        pc.application_num
                    )
                ) AS rep_patnum,
                MIN (pc.case_num) AS rep_case_num
            FROM
                lit_campaigns.ptab_campaigns ptab_camp
            INNER JOIN ptab.ptab_cases pc ON pc. ID = ptab_camp.ptab_case_id
            WHERE
                ptab_camp.lit_campaign_id IS NULL
            AND ptab_camp.ptab_campaign_id = $1
            GROUP BY
                ptab_camp.ptab_campaign_id
        ),
         rep_po AS (
            SELECT
                ptab_camp.ptab_campaign_id AS campaign_id,
                COALESCE (aed.ent_id, aed.alias_id *- 1) AS rep_po_id,
                COALESCE (aed.ent_name, aed.alias_name) AS rep_po_name
            FROM
                lit_campaigns.ptab_campaigns ptab_camp
            INNER JOIN ptab.ptab_parties pp ON pp.ptab_case_id = ptab_camp.ptab_case_id
            INNER JOIN ptab.ptab_party_types ppt ON (
                ppt. ID = pp.ptab_party_type_id
                AND ppt. NAME = ''Patent Owner''
            )
            INNER JOIN core.alias_ent_details aed ON aed.alias_id = pp.alias_id
            WHERE
                ptab_camp.lit_campaign_id IS NULL
            AND ptab_camp.ptab_campaign_id = $1
            GROUP BY
                1,
                2,
                3
            ORDER BY
                COUNT (DISTINCT ptab_camp.ptab_case_id) DESC
            LIMIT 1
        ) SELECT
            COALESCE (
                rep_po.rep_po_name,
                rp.rep_case_num
            ) || '' ('' || core.format_patnum (rp.rep_patnum) || '')'' AS campaign_name,
            rep_po.rep_po_id,
            rep_po.rep_po_name,
            (
                CASE
                WHEN rep_po.rep_po_id > 0 THEN
                    ''ENT''
                ELSE
                    ''ALS''
                END
            ) AS rep_po_id_type
        FROM
            rep_patnum rp
        LEFT JOIN rep_po ON rp.campaign_id = rep_po.campaign_id
    ';

    RETURN QUERY EXECUTE v_sql USING p_ptab_campaign_id;

EXCEPTION
    WHEN OTHERS THEN
        RAISE;
END;
$_$;


--
-- Name: get_ptab_case_name(integer); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION get_ptab_case_name(ptab_case_id integer) RETURNS TABLE(case_name text, long_case_name text, stripped_patnum text)
    LANGUAGE plpgsql
    AS $_$
/*
1.0 tazhagan_c 06-Feb-2015 DS-1137 : Create API to get the ptab case name as per the ticket
1.1 tazhagan_c 09-Feb-2015 DS-1137 : If there are no patent owners, leave out "v. patent owner name" (e.g. ptab_id = 130)
1.2 tazhagan_c 20-Feb-2015 DS-1216 : If stripped_patnum is null then use application_num from ptab prefixed with US and join to core.pats on app_num_country and get the stripped_patnum from there and use for title.
1.3 tazhagan_c 27-Feb-2015 DS-1284 : For long_case_name , 1) Remove ' 2) Display patnum instead of stripped_patnum 3) If Patnum is null, display application_num both for case_name and long_case_name
1.4 aprakash_c/tazhagan_c 06-Nov-2015 DS-2727 : Certain PTAB names have 'et all' instead of 'et al'
1.5 aprakash_c 08-Dec-2015 DS-2897 : patent owners logic change
*/
DECLARE
v_sql text := '';
BEGIN
v_sql := '
WITH ptab_cases AS
(
  SELECT
pc. ID,
coalesce(pats.stripped_patnum,pc.application_num) stripped_patnum,
coalesce(pats.patnum,pc.application_num) patnum,
pc.ptab_case_type_id
FROM
ptab.ptab_cases pc
LEFT JOIN core.pats pats ON (pc.country_code = pats.country_code AND pc.stripped_patnum = pats.stripped_patnum)
WHERE pc.id = $1
),
ptab_dtls AS (
SELECT
pc. ID,
CASE
WHEN COUNT ( DISTINCT
CASE
WHEN ppt. NAME = ''Petitioner'' THEN
COALESCE (al.ent_id, al. ID)
ELSE
NULL
END
) > 1 THEN
'' et al''
ELSE
''''
END AS et_all,
CASE
WHEN COUNT ( DISTINCT
CASE
WHEN ppt. NAME = ''Patent Owner'' THEN
COALESCE (al.ent_id, al. ID)
ELSE
NULL
END
) > 1 THEN
'' et al''
ELSE
''''
END AS et_all_po,
COALESCE(
MIN (
CASE
WHEN ppt. NAME = ''Petitioner''
AND is_primary THEN
COALESCE (ents. NAME, al. NAME, '''')
ELSE
NULL
END
),
MIN (
CASE
WHEN ppt. NAME = ''Petitioner''
THEN
COALESCE (ents. NAME, al. NAME, '''')
ELSE
NULL
END
)
) AS pet_name,
COALESCE(
MIN (
CASE
WHEN ppt. NAME = ''Patent Owner''
AND is_primary THEN
'' v. '' || COALESCE (ents. NAME, al. NAME, '''')
ELSE
NULL
END
),
MIN (
CASE
WHEN ppt. NAME = ''Patent Owner'' THEN
'' v. '' || COALESCE (ents. NAME, al. NAME, '''')
ELSE
NULL
END
)
) AS po_name,
COALESCE (MIN(pc.stripped_patnum), '''') AS stripped_patnum,
COALESCE (MIN(pc.patnum), '''') AS patnum,
COALESCE (MIN(pct.case_type), '''') AS case_type
FROM
ptab_cases pc
INNER JOIN ptab.ptab_parties pp ON (pp.ptab_case_id = pc. ID)
INNER JOIN ptab.ptab_party_types ppt ON (ppt. ID = pp.ptab_party_type_id)
INNER JOIN core.aliases al ON (al. ID = pp.alias_id)
LEFT JOIN core.ents ON (ents. ID = al.ent_id)
INNER JOIN ptab.ptab_case_types pct ON (pc.ptab_case_type_id = pct. ID)
GROUP BY
pc. ID
) SELECT
(coalesce(pet_name,'''') || et_all || coalesce(po_name,'''') || et_all_po || '' '' || case_type || '' of '''''' || RIGHT (stripped_patnum, 3))::text AS case_name,
(coalesce(pet_name,'''') || et_all || coalesce(po_name,'''') || et_all_po || '' '' || case_type || '' of '' ||patnum)::text AS long_name,
patnum as stripped_patnum
FROM
ptab_dtls
';
  RETURN QUERY
EXECUTE v_sql using ptab_case_id;
EXCEPTION
    WHEN OTHERS THEN
        RAISE;
END;
$_$;


--
-- Name: get_ptab_lit_campaign(integer[], character varying); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION get_ptab_lit_campaign(p_ptab_case_id integer[] DEFAULT NULL::integer[], p_stripped_patnum character varying DEFAULT NULL::character varying) RETURNS TABLE(ptab_case_id integer, campaign_id integer)
    LANGUAGE plpgsql
    AS $_$
DECLARE
v_sql text := '';
BEGIN
    /*
    1.0 anarayanan  05-Mar-2015 DS-1338 : Find campaign_id for the ptab.
    2.0 aprakash_c 16-06-2015 DS-1809 modified input to accept array of ptab_case and stripped patnum
    3.0 anarayanan 04-Apr-2017 DS-5093: Campaign Logic Updates
    4.0 aprakash_c 05-Apr-2017 DS-5090: added missing from souce date condition
    */
    v_sql := '
        WITH ptab_pats AS (
            SELECT
                pc. ID,
                pc.filing_date,
                MIN (
                    CASE
                    WHEN pc.stripped_patnum = pfp_all.stripped_patnum THEN
                        pats. ID
                    END
                ) AS pat_id,
                ARRAY_AGG (pats. ID) AS pat_ids
            FROM
                ptab.ptab_cases pc
            INNER JOIN docdb_families.pat_family_pats pfp_drv ON (
                pfp_drv.stripped_patnum = pc.stripped_patnum
                AND pfp_drv.country_code = pc.country_code
                AND pc.country_code = ''US''
            )
            INNER JOIN docdb_families.pat_family_pats pfp_all ON (
                pfp_all.pat_family_id = pfp_drv.pat_family_id
                AND pfp_all.country_code = ''US''
            )
            INNER JOIN core.pats ON pats.stripped_patnum = pfp_all.stripped_patnum
            WHERE
                (pc. ID = ANY ($1)
            OR pc.stripped_patnum = $2)
            AND missing_from_source_date IS NULL
            GROUP BY
                1
            UNION ALL
                SELECT
                    pc. ID,
                    pc.filing_date,
                    pats. ID AS pat_id,
                    ARRAY [ pats. ID ] AS pat_ids
                FROM
                    ptab.ptab_cases pc
                INNER JOIN core.pats ON pats.stripped_patnum = pc.stripped_patnum
                WHERE
                    NOT EXISTS (
                        SELECT
                            1
                        FROM
                            docdb_families.pat_family_pats pfp_drv
                        WHERE
                            (
                                pfp_drv.stripped_patnum = pc.stripped_patnum
                                AND pfp_drv.country_code = pc.country_code
                                AND pc.country_code = ''US''
                            )
                    )
                AND   (pc. ID = ANY ($1)
                OR pc.stripped_patnum = $2)
                AND missing_from_source_date IS NULL
        ),
         ptab_dir_assn_results AS (
            SELECT
                *, COUNT (*) OVER (PARTITION BY ptab_case_id) camp_count
            FROM
                (
                    SELECT
                        pp. ID AS ptab_case_id,
                        pp.pat_id,
                        pp.filing_date,
                        cm.campaign_id,
                        cm.camp_start_date,
                        uniq (
                            sort (
                                cm.lit_defendants || cm.itc_defendants
                            )
                        ) AS camp_defendants,
                        RANK () OVER (
                            PARTITION BY pp. ID
                            ORDER BY
                                (
                                    CASE
                                    WHEN ARRAY [ pp.pat_id ]&& cm.camp_pats_ids THEN
                                        0
                                    ELSE
                                        1
                                    END
                                ),
                                (
                                    CASE
                                    WHEN cm.camp_start_date < pp.filing_date THEN
                                        0
                                    ELSE
                                        1
                                    END
                                )
                        ) rnk
                    FROM
                        ptab_pats pp
                    INNER JOIN lit_campaigns.campaign_metrics cm ON cm.camp_pats_ids && pp.pat_ids
                    INNER JOIN lit_campaigns.campaigns camp ON camp. ID = cm.campaign_id
                ) T
            WHERE
                rnk = 1
        ),
         choose_camp_by_def AS (
            SELECT
                ptab_case_id,
                campaign_id,
                COUNT (*) OVER (PARTITION BY ptab_case_id) AS camp_count
            FROM
                (
                    SELECT
                        dar.ptab_case_id,
                        dar.campaign_id,
                        array_length(
                            uniq (
                                sort (
                                    ARRAY_AGG (aed.ultimate_parent_id) & MIN (camp_defendants)
                                )
                            ),
                            1
                        ) def_cnt,
                        MAX (dar.camp_start_date) camp_start_date,
                        RANK () OVER (
                            PARTITION BY dar.ptab_case_id
                            ORDER BY
                                array_length(
                                    uniq (
                                        sort (
                                            ARRAY_AGG (aed.ultimate_parent_id) & MIN (camp_defendants)
                                        )
                                    ),
                                    1
                                ) DESC,
                                MAX (dar.camp_start_date) DESC,
                                dar.campaign_id DESC
                        ) AS rnk
                    FROM
                        ptab_dir_assn_results dar
                    INNER JOIN ptab.ptab_parties pp ON pp.ptab_case_id = dar.ptab_case_id
                    AND pp.ptab_party_type_id = 1
                    INNER JOIN core.alias_ent_details aed ON aed.alias_id = pp.alias_id
                    WHERE
                        camp_count > 1
                    GROUP BY
                        1,
                        2
                ) T
            WHERE
                rnk = 1
        ) SELECT
            ptab_case_id,
            campaign_id
        FROM
            ptab_dir_assn_results
        WHERE
            camp_count = 1
        UNION ALL
            SELECT
                ptab_case_id,
                campaign_id
            FROM
                choose_camp_by_def
    ';

    RETURN QUERY EXECUTE v_sql USING p_ptab_case_id,p_stripped_patnum;

EXCEPTION
    WHEN OTHERS THEN
        RAISE;
END;
$_$;


--
-- Name: get_ptab_parties(integer); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION get_ptab_parties(p_ptab_case_id integer) RETURNS TABLE(ptab_party_id integer, ptab_party_type_id integer, alias_id integer, alias_name character varying, ent_id integer, entity_name character varying, ptab_party_type_name character varying)
    LANGUAGE plpgsql
    AS $$
  	  DECLARE
  	  /*
  	     Returns alias info and entity info for the ptab parties on this case.
  	     Usage example:
  	     select * from ptab.get_ptab_parties(355);
  	  	 1.0 vsolomakha DS-2926 - Create a new API function to return all ptab_parties mapped alias information
  	  	 2.0 anarayanan Ds-2926 - Added new output field and converted aliases to INNER JOIN
  	   */
  	  BEGIN
  	    RETURN QUERY
  	      select p.id as ptab_party_id,
  	             p.ptab_party_type_id,
  	             al.id as alias_id,
  	             al.name as alias_name,
  	             ents.id as ent_id,
  	             ents.name as entity_name,
  	  					 ppt.name as ptab_party_type_name
  	      from ptab.ptab_parties p
  	      inner join core.aliases al on p.alias_id = al.id
  	  		inner join ptab.ptab_party_types ppt on ppt.id = p.ptab_party_type_id
  	      left outer join core.ents on al.ent_id = ents.id
  	      where p.ptab_case_id = p_ptab_case_id;

  	  EXCEPTION
  	      WHEN OTHERS THEN
  	          RAISE;
  	  END;
  	  $$;


--
-- Name: get_ptab_ptab_campaign(integer, character varying); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION get_ptab_ptab_campaign(p_ptab_case_id integer DEFAULT NULL::integer, p_stripped_patnum character varying DEFAULT NULL::character varying) RETURNS TABLE(campaign_id integer)
    LANGUAGE plpgsql
    AS $_$
DECLARE
v_sql text := '';
BEGIN
    /*
    anarayanan  05-Mar-2015 DS-1338 : Find campaign_id for the ptab.
    aprakash_c 16-06-2015 DS-1809 modified input to accept stripped patnum
    */
    v_sql := '
        WITH ptab_pats AS (
            SELECT
                pfp_all.stripped_patnum
            FROM
                ptab.ptab_cases pc
            INNER JOIN docdb_families.pat_family_pats pfp_drv ON (
                pfp_drv.stripped_patnum = pc.stripped_patnum
                AND pfp_drv.country_code = pc.country_code
                AND pc.country_code = ''US''
            )
            INNER JOIN docdb_families.pat_family_pats pfp_all ON (
                pfp_all.pat_family_id = pfp_drv.pat_family_id
                AND pfp_all.country_code = ''US''
            )
            WHERE
                pc. ID = $1
            OR pc.stripped_patnum = $2
            GROUP BY
                1
            UNION
                SELECT
                    COALESCE (
                        pc.stripped_patnum,
                        pc.application_num
                    )
                FROM
                    ptab.ptab_cases pc
                WHERE
                    pc. ID = $1
                OR pc.stripped_patnum = $2
        ),
         rel_ptabs AS (
            SELECT
                pc. ID ptab_id
            FROM
                ptab.ptab_cases pc
            INNER JOIN ptab_pats pp ON (
                pp.stripped_patnum = pc.stripped_patnum
                AND pc.country_code = ''US''
            )
            UNION ALL
                SELECT
                    pc. ID ptab_id
                FROM
                    ptab.ptab_cases pc
                INNER JOIN ptab_pats pp ON (
                    pc.stripped_patnum IS NULL
                    AND pc.application_num = pp.stripped_patnum
                )
        ) SELECT
            MIN (ptab_id)+2000000
        FROM
            rel_ptabs
    ';

    RETURN QUERY EXECUTE v_sql USING p_ptab_case_id,p_stripped_patnum;

EXCEPTION
    WHEN OTHERS THEN
        RAISE;
END;
$_$;


--
-- Name: i_ptab_case_details(character varying); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION i_ptab_case_details(p_case_num character varying DEFAULT NULL::character varying) RETURNS TABLE(ptab_case_id integer, ptab_case_num character varying, ptab_case_detail_party_type_id integer, doc_name character varying, doc_type character varying, exhibit_num integer, filing_date date, availability character varying, document_path character varying, attachment_handle character varying, attachment_url character varying, missing_from_source_date date, attachment_name character varying)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
BEGIN
/*
1.0 aprakash_c 14-Oct-2015 DS-2453 : created a interface function source as ptab_staging
2.0 aprakash_c 11-Nov-2015 DS-2750 : added case_num as a input param and renamed the API
3.0 vpemmaraju 19-Nov-2015 DS-2750 : added case_num to output and using view instead of table as source.
4.0 vpemmaraju 10-Feb-2016 DS-3260 & DS-3272: Logic to populate null values in exhibit number and filing date.
4.1 vpemmaraju 09-May-2016 DS-3679: added field missing_from_source_date..
4.2 vpemmaraju 14-July-2016		  : comparing filing_party using trim and lower. since new site provides data in different case.
4.3 vpemmaraju 19-July-2016	DS-4131: added attachment_name
*/
 RETURN QUERY

  with base as (       	SELECT
		pc. ID AS ptab_case_id,
		pcd.case_num,
		pcpt. ID AS ptab_case_detail_party_type_id,
		pcd.doc_name,
		pcd.doc_type,
		pcd.exhibit_num,
		coalesce(pcd.filing_date,now()) as filing_date, --DS-3269
		pcd.availability,
		NULL :: CHARACTER VARYING AS document_path,
		pcd.attachment_handle,
		pcd.attachment_url,
		pcd.missing_from_source_date,
		pcd.attachment_name
	FROM
		ptab_staging.ptab_case_details pcd
	INNER JOIN ptab.ptab_cases pc ON pc.case_num = pcd.case_num
	LEFT JOIN ptab.ptab_case_detail_party_types pcpt ON trim(lower(pcpt. NAME)) = trim(lower(pcd.filing_party))
	WHERE pcd. case_num = coalesce(p_case_num, pcd. case_num)
), m1 as
(
--Review text of docket entry to see if text begins with ‘Exhibit%’, if it does, use this to help set Exhibit Number / Paper Number
select case ad[2]~'^[0-9]+$'
when true then trim(ad[2])::integer
else null end  as new_exhibit_num,* from (select string_to_array(c.doc_name,' ') ad,case_num,c.attachment_handle from ptab_staging.ptab_Case_details c
where  lower(c.doc_name)  like 'exhibit%' and c.case_num=p_case_num)x
), m1_a as
(
--for the cases which satisfies Method 1 only but we could not extract anything from doc_name
select row_number() over(partition by a.case_num,a.filing_party order by ccd.filing_date asc)+m_e_n as new_exhibit_num,m_e_n,ccd.case_num
,ccd.attachment_handle from
(
select cd.case_num,coalesce(max(cd.exhibit_num),0) m_e_n,cd.filing_party from ptab_staging.ptab_Case_details cd
where  lower(cd.doc_type)='exhibit' and cd.case_num=p_case_num
group by cd.case_num,cd.filing_party
)a left join ptab_staging.ptab_Case_details ccd on a.case_num=ccd.case_num and a.filing_party=ccd.filing_party
where ccd.attachment_handle not in  (select m1.attachment_handle from m1 where m1.new_exhibit_num is not null)
and ccd.exhibit_num is null
)
,m2 as
(
--When Document Type = ‘Exhibit’ and text of docket entry does not start with ‘Exhibit%’ then find the most
--recently filed ‘Exhibit’ that is currently listed on the docket with the same Filing Party and add 1
select row_number() over(partition by a.case_num,a.filing_party order by ccd.filing_date asc)+m_e_n as new_exhibit_num,m_e_n
,ccd.attachment_handle,ccd.case_num from
(
--talk to ed we used max.
select cd.case_num,coalesce(max(cd.exhibit_num),0) m_e_n,cd.filing_party from ptab_staging.ptab_Case_details cd
where lower(cd.doc_type)='exhibit' and lower(cd.doc_name) not like 'exhibit%' and cd.case_num=p_case_num
and  not exists (select 1 from m1 where m1.attachment_handle=cd.attachment_handle and m1.new_exhibit_num is not null)
group by 1,3
)a left join ptab_staging.ptab_Case_details ccd on a.case_num=ccd.case_num and a.filing_party=ccd.filing_party
where ccd.exhibit_num is null  and  lower(ccd.doc_type)='exhibit' and lower(ccd.doc_name) not like 'exhibit%'
),m3 as
(
--When Document Type = Anything other than Exhibit, then find the most recently filed non-exhibit on the docket and add 1
select  row_number() over(partition by a.case_num order by cd.filing_date asc)+m_e_n as new_exhibit_num,cd.attachment_handle,cd.case_num from
(select c.case_num,coalesce(max(c.exhibit_num),0) m_e_n from ptab_staging.ptab_Case_details c
where lower(c.doc_type)!='exhibit' and c.case_num=p_case_num
group by c.case_num
)a left join ptab_staging.ptab_Case_details cd on a.case_num=cd.case_num and lower(cd.doc_type)!='exhibit'
where cd.exhibit_num is null
)
select
--m1.new_exhibit_num,m2.new_exhibit_num,m3.new_exhibit_num,m1_a.new_exhibit_num,
--base.exhibit_num,
base.ptab_case_id,
base.case_num,
base.ptab_case_detail_party_type_id,
base.doc_name,
base.doc_type,
coalesce( base.exhibit_num ,coalesce(m1_a.new_exhibit_num,coalesce(m1.new_exhibit_num,coalesce(m2.new_exhibit_num,m3.new_exhibit_num))))::integer as exhibit_num,
base.filing_date::date,
base.availability,
NULL :: CHARACTER VARYING AS document_path,
base.attachment_handle,
base.attachment_url,
base.missing_from_source_date ,
base.attachment_name
from base
left join m1 on base.case_num=m1.case_num and base.attachment_handle=m1.attachment_handle
left join m1_a on base.case_num=m1_a.case_num and base.attachment_handle=m1_a.attachment_handle
left join m2 on base.case_num=m2.case_num and base.attachment_handle=m2.attachment_handle
left join m3 on base.case_num=m3.case_num and base.attachment_handle=m3.attachment_handle;


END;
$_$;


--
-- Name: i_ptab_cases(character varying); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION i_ptab_cases(p_case_num character varying DEFAULT NULL::character varying) RETURNS TABLE(case_num character varying, filing_date date, institution_decision_date date, stripped_patnum character varying, country_code character varying, application_num character varying, status character varying, tech_center character varying, ptab_case_type_id integer, notice_date date, reason_for_notice_filing_date character varying, petitioner_application_num character varying, petitioner_stripped_patnum character varying, petitioner_tech_center character varying, missing_from_source_date date)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
/*
1.0 aprakash_c 14-Oct-2015 DS-2453 : created a interface function source as ptab_staging
2.0 aprakash_c 11-Nov-2015 DS-2750 : added case_num as a input param and renamed the API
3.0 vpemmaraju 06-Jun-2016 DS-3867: Add columns to ptab_cases to store additional dates.
3.1 vpemmaraju 26-Dec-2016 DS-4701 : Add Petitioner Fields from new ptab case page to the ptab_cases table
3.2 vpemmaraju 13-Mar-2017 DS-4977 : Add missing_from_source_date to the ptab_cases table
*/
 RETURN QUERY
with t1 as (
        select  spc.case_num
                ,coalesce(pc.reason_for_notice_filing_date,'') as reason_for_notice_filing_date
                ,min(spcd.filing_date) as notice_filing_date
        from  ptab_staging.ptab_cases spc
              left join ptab.ptab_cases  pc on spc.case_num=pc.case_num
              left join ptab_staging.ptab_case_details spcd on spcd.case_num=pc.case_num
        where spcd.doc_type = 'Notice of Filing Date Accorded to Petition'
			and lower(spcd.doc_name) != 'expunged'
            and spc.case_num =coalesce(p_case_num,spc.case_num)
        group by 1,2
)
 select
        pc.case_num,
		pc.filing_date,
		pc.institution_decision_date,
		pc.stripped_patnum,
		'US'::character varying as country_code,
		replace(pc.application_num,'/','')::varchar as application_num,
		pc.status,
		pc.tech_center,
		(select id from ptab.ptab_Case_types where case_type=substring(pc.case_num,1,3)) as ptab_case_type_id
		,pnd.notice_filing_date as notice_date
		,case
            when coalesce(c.reason_for_notice_filing_date,'') in ('Logic','Manual','N/A','DCL') then c.reason_for_notice_filing_date
            when pnd.notice_filing_date is NULL then 'TBD'
            when pnd.notice_filing_date is not null then 'Logic'
            else 'UNKNOWN'::varchar
        end  as reason_for_notice_filing_date
        ,replace(pc.petitioner_application_num,'/','')::varchar as petitioner_application_num
        ,pc.petitioner_stripped_patnum
        ,pc.petitioner_tech_center
	 ,pc.missing_from_source_date
 from  ptab_staging.ptab_cases as pc
       left join ptab.ptab_cases c on pc.case_num=c.case_num
       LEFT JOIN t1 as pnd on pnd.case_num = pc.case_num
 WHERE pc.case_num =coalesce(p_case_num,pc.case_num)
;


END;
$$;


--
-- Name: i_ptab_parties(character varying); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION i_ptab_parties(p_case_num character varying DEFAULT NULL::character varying) RETURNS TABLE(data_source character varying, case_num character varying, alias_name character varying, alias_id integer, ptab_party_type_id integer)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
v_petitioner integer;
v_patent_owner integer;
BEGIN
/*
1.0 vpemmaraju 5-Nov-2015 DS-2729 : Interface Function for ptab_parties using ptab_staging tables
1.1 vpemmaraju 7-Dec-2015 DS-2892: De-dupe PTAB parties from DB and PTAB ETL using Ent ID and PTAB Party Role
1.3 vpemmaraju 27-Jan-2016 DS-3185: Filter out null aliases from ptab and docblaster
1.4 vpemmaraju 29-feb-2016 DS-3305: missing capturing ptab parties. because alias is created in first run and in the second run the join works with core.aliases and we get the data.
1.5 vpemmmaraju 17-may-2016 DS-3782: using row_number instead of rank since same source can have more than one alias belonging to same ent_id. using rank was inserting multiple aliases. row_number will restrict it to only one record.
1.6 ateja   13-Dec-2016 DS-4676: use ldc instead of lit_docs.
*/
/* Notes

 Adding corner case that is not covered. will be implemented in future if this really becomes an issue.
  Example:
 Day1 : Ptab site has  case-xyz , patent owner and alias 123
 Day2:  Ed's team says that 123 should be replaced with 345 --> so we add record in data_dcl.ptab_parties_add  with 345 and in data_dcl.ptab_parties_delete 123
 Day3: ptab site now updates the data case-xyz, patent owner,456
           This will now result in 2 records in target. one with new change 456 and one from the data_dcl.patb_parties_add. so target will have 345 and 456.
 */

 select core.find_or_create_alias(petitioner) into v_petitioner
    from ptab_staging.v_ptab_cases  vc
        where vc.case_num=p_case_num;

         select core.find_or_create_alias(patent_owner) into v_patent_owner
    from ptab_staging.v_ptab_cases  vc
        where vc.case_num=p_case_num;

 RETURN QUERY
  with c as(
        select 'ptab'::varchar as src, 1 as pr ,p_case_num as case_num, v_petitioner as alias_id,
        (select id from ptab.ptab_party_types where name='Petitioner') as ptab_party_type_id
        where v_petitioner is not null
union
        select 'ptab'::varchar as src,1 as pr ,p_case_num as case_num , v_patent_owner as alias_id,
        (select id from ptab.ptab_party_types where name='Patent Owner') as ptab_party_type_id
      where v_patent_owner is not null
union
        select distinct 'docblaster'::varchar as src, 2 as pr, c.case_num, p.alias_id as ptab_party_alias_id,
         pt.id
        from ldc.lit_docs_ptab_parties p
        inner join ptab.ptab_cases c on p.ptab_case_id=c.id
        left join core.aliases a on a.id=p.alias_id
        left join ptab.ptab_party_types pt on pt.name=p.party_role
        where c.case_num=p_case_num and p.alias_id is not null
    )
   select fin.data_source,fin.case_num, fin.alias_name,fin.final_alias_id as alias_id,fin.ptab_party_type_id from
 (select a.name as alias_name,  row_number() over(partition by a.ent_id,x.ptab_party_type_id order by pr asc,x.alias_id asc) as rnk,
 x.src as data_source,
 x.case_num,x.final_alias_id,x.ptab_party_type_id
  from
 (select coalesce(s.split_alias_id,c.alias_id)::integer as final_alias_id  -- Split aliases if mapping present
 ,*
 from c
 left join data_dcl.aliases_split s on c.alias_id=s.original_alias_id
 where coalesce(s.action_flag,'')!='D'  -- -- if the case is new and the alias split is already available we use it and hence we do not have to insert the concatenated alias
  )x inner join core.aliases a on x.final_alias_id=a.id
    )fin where rnk=1;
END;
$$;


--
-- Name: insert_ptab_parties_tab(integer, integer, character varying, character varying, character varying); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION insert_ptab_parties_tab(p_ptab_case_id integer DEFAULT NULL::integer, p_ptab_party_type_id integer DEFAULT NULL::integer, p_party_name character varying DEFAULT NULL::character varying, p_created_by character varying DEFAULT 'docs_app'::character varying, p_updated_by character varying DEFAULT 'docs_app'::character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$ DECLARE
	v_ptab_parties_id INTEGER := NULL ; v_alias_id INTEGER DEFAULT NULL ; v_is_primary BOOLEAN DEFAULT FALSE ; v_count INTEGER := 0 ;
BEGIN
	/*
	1.0 2015-02-19 aprakash_c DS-809: New Function insert_ptab_parties_tab Created for inserting records in to ptab_parties
	1.1 2015-02-24 aprakash_c DS-1192: Added the validation points for input parameters
	1.2 2016-01-26 vpemmaraju DS_3173 : changed the default user to docs_app
	*/
	--Validate the input parameters
	SELECT
	SUM (cnt) INTO v_ptab_parties_id
	FROM
	((SELECT
			COUNT (ID) cnt
		FROM
			ptab.ptab_party_types
		WHERE
			ID = p_ptab_party_type_id)
	UNION ALL
	(SELECT
			COUNT (ID) cnt
		FROM
			ptab.ptab_cases
		WHERE
			ID = p_ptab_case_id))T;
	IF v_ptab_parties_id = 2 THEN
	--Get the alias name from p_party_name
		SELECT
			* INTO v_alias_id
		FROM
			core.find_or_create_alias (p_party_name) ; INSERT INTO ptab.ptab_parties (
				ID,
				ptab_case_id,
				ptab_party_type_id,
				alias_id,
				created_by,
				updated_by,
				is_primary
			)
		VALUES
			(
				DEFAULT,
				p_ptab_case_id,
				p_ptab_party_type_id,
				v_alias_id,
				p_created_by,
				p_updated_by,
				v_is_primary
			) RETURNING ID INTO v_ptab_parties_id ; RETURN v_ptab_parties_id ;
	ELSE
		RETURN - 1 ; raise EXCEPTION 'Error (insert_ptab_parties_tab): parameters given as input is not valid ptab_party_type_id:% ptab_case_id=%',
		p_ptab_party_type_id, p_ptab_case_id ;
	END
	IF ; EXCEPTION
		WHEN OTHERS THEN
			RAISE NOTICE '% %',
			SQLSTATE,
			sqlerrm ; RETURN - 1 ;
END ; $$;


--
-- Name: ipr_data_trig_func(); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION ipr_data_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
    DECLARE

    BEGIN
        IF (TG_OP = 'UPDATE') THEN
            NEW.updated_at := Now();
            RETURN NEW;
        ELSIF (TG_OP = 'DELETE') THEN
            RETURN OLD;
        ELSIF (TG_OP = 'INSERT') THEN
            NEW.created_at := Now();
            NEW.updated_at := Now();
            RETURN NEW;
        ELSE
            RAISE WARNING '[ptab.ipr_data_trig_func] - Other action occurred: %, at %',TG_OP,now();
            RETURN NULL;
        END IF;

    EXCEPTION
        WHEN data_exception THEN
            RAISE WARNING '[ptab.ipr_data_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
            RETURN NULL;
        WHEN unique_violation THEN
            RAISE WARNING '[ptab.ipr_data_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
            RETURN NULL;
        WHEN OTHERS THEN
            RAISE WARNING '[ptab.ipr_data_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
            RETURN NULL;
    END;
$$;


--
-- Name: ps_ptab_cases_dcl(character varying); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION ps_ptab_cases_dcl(p_case_num character varying) RETURNS TABLE(case_num character varying, filing_date date, institution_decision_date date, stripped_patnum character varying, country_code character varying, application_num character varying, status character varying, tech_center character varying, ptab_case_type_id integer, notice_date date, reason_for_notice_filing_date character varying, petitioner_application_num character varying, petitioner_stripped_patnum character varying, petitioner_tech_center character varying, missing_from_source_date date, is_open boolean)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
/*
1.1 vpemmaraju 15-Mar-2016 DS-3436 : ETL DCL function updated to have corrected institution_decision_date from ptab_field_corrections table
1.2 vpemmaraju 07-Jun-2016 DS-3867 : add notice_date and reason_for_notice_filing_date
1.3 vpemmaraju 26-Dec-2016 DS-4701 : Add Petitioner Fields from new ptab case page to the ptab_cases table
1.4 vpemmaraju 13-Mar-2017 DS-4977 : Add missing_from_source_date to the ptab_cases table
1.4 vpemmaraju 13-Apr-2017 DS-5017 : Add is_open to the ptab_cases table
*/
BEGIN
RETURN QUERY
SELECT
	src.case_num,
	src.filing_date,
	data_dcl.get_ptab_case_institution_decision_date_after_dcl(p_case_num,coalesce(src.institution_decision_date::varchar,'1970-01-01'))::date,
	data_dcl.get_ptab_case_stripped_patnum_after_dcl(p_case_num,src.stripped_patnum) as stripped_patnum, --DS-3111
	src.country_code,
	data_dcl.get_ptab_case_application_num_after_dcl(p_case_num,src.application_num) as application_num, --DS-3111
	data_dcl.get_ptab_case_status_after_dcl (p_case_num,src.status) as status,
	src.tech_center,
	src.ptab_case_type_id,
	data_dcl.get_ptab_case_notice_date_after_dcl(p_case_num,src.notice_date) as notice_date, --DS-3912
	data_dcl.get_ptab_case_reason_for_notice_filing_date_after_dcl(p_case_num,src.reason_for_notice_filing_date) as reason_for_notice_filing_date, --DS-3912
	src.petitioner_application_num,
	src.petitioner_stripped_patnum,
	src.petitioner_tech_center,
	src.missing_from_source_date,
	case --DS-5017
		when lower(trim(data_dcl.get_ptab_case_status_after_dcl (p_case_num,src.status) )) in ('adverse judgment after institution','adverse judgment before institution','defective petition','final written decision','institution denied','institution vacated','joined','settlement after institution','settlement before institution','terminated','terminated after institution','terminated before institution','termination before institution','trial denied') then false
		when lower(trim(data_dcl.get_ptab_case_status_after_dcl (p_case_num,src.status) )) in ('incomplete petition','filing date accorded','notice of filing date accorded','petition filed','po response filed','sealed','trial instituted','waiver filed') then True
		else True -- any new status shoud be defaulted to Open.
	end as is_open
FROM (
	select  c.case_num,
	c.filing_date,
	c.institution_decision_date,
	c.stripped_patnum,
	c.country_code,
	c.application_num,
	c.status,
	c.tech_center,
	c.ptab_case_type_id,
	c.notice_date,
	c.reason_for_notice_filing_date,
	c.petitioner_application_num,
	c.petitioner_stripped_patnum,
	c.petitioner_tech_center,
	c.missing_from_source_date
	FROM ptab.i_ptab_cases(p_case_num) c
) src;
END;
$$;


--
-- Name: ps_ptab_parties_dcl(character varying); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION ps_ptab_parties_dcl(p_case_num character varying) RETURNS TABLE(data_source character varying, case_num character varying, alias_id integer, ptab_party_type_id integer)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
/*
1.0 vpemmaraju 16-Nov-2015 DS-2729 : Correction layer on top of ptab_parties interface 
*/
/*
Notes: we will use the add and delete tables to capture the corrections since the case num to parites is one to many relationship.
when ever there is change requested for party type or aliases_id for a party type we have to capture them correctly in add and delete tables.
*/
 RETURN QUERY 
        
         SELECT
                src.data_source,
                src.case_num,
                src.alias_id,
                src.ptab_party_type_id
    FROM (
       select  c.data_source,c.case_num,c.alias_id, c.ptab_party_type_id
	FROM ptab.i_ptab_parties(p_case_num) c  -- we use the docblaster data in the interface.
	where not exists 
	   (SELECT 1 FROM data_dcl.ptab_parties_delete pd  WHERE c.case_num=pd.case_num and c.alias_id=pd.alias_id and c.ptab_party_type_id=pd.ptab_party_type_id)
      UNION
     select  'correction' as data_source,pc.case_num, pc.alias_id, pc.ptab_party_type_id
     FROM data_dcl.ptab_parties_add pc where pc.case_num=p_case_num AND pc.is_active = true
     ) src;
END;
$$;


--
-- Name: ptab_case_details_dcl(character varying); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION ptab_case_details_dcl(p_case_num character varying) RETURNS TABLE(ptab_case_id integer, ptab_case_num character varying, ptab_case_detail_party_type_id integer, doc_name character varying, doc_type character varying, exhibit_num integer, filing_date date, availability character varying, document_path character varying, attachment_handle character varying, attachment_url character varying, missing_from_source_date date, attachment_name character varying)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
/*
 1.0 2016-02-12 vpemmaraju DS-3272: New Function which retruns the data from interface function after applying field corrections..
 1.1 2016-05-09 vpemmaraju DS-3679: added field missing_from_source_date..
 1.2 2016-07-20 vpemmaraju DS-4131: added attachment_name
 1.3 2016-09-01 vpemmaraju DS-4265: Change in the petition doc_type override logic. this was earlier done in upsert_ptab_case_details, later moved to this function when working on DS-4286 ( DCL for doc_type)
 1.3 2016-09-01 vpemmaraju DS-4286: DCL for doc_type
*/
 RETURN QUERY
select
	src.ptab_case_id
	,src.ptab_case_num
	,src.ptab_case_detail_party_type_id
	,src.doc_name
	,data_dcl.get_ptab_case_detail_doc_type_after_dcl(src.attachment_handle,
		ptab_staging.derive_case_details_doc_type(src.attachment_handle,src.doc_type))as doc_type
		--this function of derive_case_details_doc_type was earlier in upsert_ptab_case_details
		--later removed it from there and added here when DCL was requested as part of DS-4286
	,data_dcl.get_ptab_case_detail_exhibit_num_after_dcl(src.attachment_handle,src.exhibit_num::integer) as exhibit_num
	,data_dcl.get_ptab_case_detail_filing_date_after_dcl(src.attachment_handle,src.filing_date) as filing_date
	,src.availability
	,src.document_path
	,src.attachment_handle
	,src.attachment_url
	,src.missing_from_source_date
	,src.attachment_name
FROM (
       select c.ptab_case_id
        ,c.ptab_case_num
		,c.ptab_case_detail_party_type_id
		,c.doc_name
		,c.doc_type
		,c.exhibit_num
		,c.filing_date
		,c.availability
		,c.document_path
		,c.attachment_handle
		,c.attachment_url
		,c.missing_from_source_date
		,c.attachment_name
	FROM ptab.i_ptab_case_details(p_case_num) c
    ) src;
END;
$$;


--
-- Name: ptab_expert_alias_role_trig_func(); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION ptab_expert_alias_role_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
    IF (TG_OP = 'UPDATE') THEN
      IF (1 = 1) THEN
       IF (COALESCE(OLD.expert_alias_id, -1) <> COALESCE(NEW.expert_alias_id, -1)) OR (1 <> 1) THEN
         IF OLD.expert_alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('ptab.ptab_expert_info', 'expert_alias_id', OLD.expert_alias_id, 'D', 'ptab_expert');
         END IF;
         IF NEW.expert_alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('ptab.ptab_expert_info', 'expert_alias_id', NEW.expert_alias_id, 'I', 'ptab_expert');
         END IF;
       END IF;
      END IF;
      RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('ptab.ptab_expert_info', 'expert_alias_id', OLD.expert_alias_id, 'D', 'ptab_expert');
        END IF;
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('ptab.ptab_expert_info', 'expert_alias_id', NEW.expert_alias_id, 'I', 'ptab_expert');
        END IF;
        RETURN NEW;
    ELSE
        RAISE EXCEPTION '[ptab..ptab_expert_alias_role_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[ptab..ptab_expert_alias_role_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[ptab..ptab_expert_alias_role_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[ptab..ptab_expert_alias_role_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: ptab_judge_alias_role_trig_func(); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION ptab_judge_alias_role_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
    IF (TG_OP = 'UPDATE') THEN
      IF (1 = 1) THEN
       IF (COALESCE(OLD.judge_alias_id, -1) <> COALESCE(NEW.judge_alias_id, -1)) OR (1 <> 1) THEN
         IF OLD.judge_alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('ptab.ptab_judges_map', 'judge_alias_id', OLD.judge_alias_id, 'D', 'ptab_judge');
         END IF;
         IF NEW.judge_alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('ptab.ptab_judges_map', 'judge_alias_id', NEW.judge_alias_id, 'I', 'ptab_judge');
         END IF;
       END IF;
      END IF;
      RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('ptab.ptab_judges_map', 'judge_alias_id', OLD.judge_alias_id, 'D', 'ptab_judge');
        END IF;
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('ptab.ptab_judges_map', 'judge_alias_id', NEW.judge_alias_id, 'I', 'ptab_judge');
        END IF;
        RETURN NEW;
    ELSE
        RAISE EXCEPTION '[ptab..ptab_judge_alias_role_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[ptab..ptab_judge_alias_role_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[ptab..ptab_judge_alias_role_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[ptab..ptab_judge_alias_role_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: ptab_parties_update_campaign_tr_function(); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION ptab_parties_update_campaign_tr_function() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

  /*
  1.0 aprakash_c 25-04-2017 DS-1809 New trigger created
  */
   IF (TG_OP = 'UPDATE') THEN
    IF  (coalesce(old.ptab_case_id, -1) != coalesce(new.ptab_case_id, -1) OR coalesce(old.alias_id, -1) != coalesce(new.alias_id, -1)) THEN
      UPDATE lit_campaigns.ptab_campaigns
	  SET needs_processing = TRUE,
	  updated_by = current_user
	  WHERE ptab_case_id IN (NEW. ptab_case_id, OLD.ptab_case_id);
    END IF;
  ELSIF (TG_OP = 'INSERT') THEN
      UPDATE lit_campaigns.ptab_campaigns
	  SET needs_processing = TRUE,
	  updated_by = current_user
	  WHERE ptab_case_id = NEW. ptab_case_id;
  ELSE
      UPDATE lit_campaigns.ptab_campaigns
	  SET needs_processing = TRUE,
	  updated_by = current_user
	  WHERE ptab_case_id = OLD. ptab_case_id;
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: ptab_party_alias_role_trig_func(); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION ptab_party_alias_role_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
    IF (TG_OP = 'UPDATE') THEN
      IF (1 = 1) THEN
       IF (COALESCE(OLD.alias_id, -1) <> COALESCE(NEW.alias_id, -1)) OR (1 <> 1) THEN
         IF OLD.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('ptab.ptab_parties', 'alias_id', OLD.alias_id, 'D', 'ptab_party');
         END IF;
         IF NEW.alias_id is NOT NULL THEN
          PERFORM core.update_alias_role('ptab.ptab_parties', 'alias_id', NEW.alias_id, 'I', 'ptab_party');
         END IF;
       END IF;
      END IF;
      RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('ptab.ptab_parties', 'alias_id', OLD.alias_id, 'D', 'ptab_party');
        END IF;
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        IF (1=1) THEN
         PERFORM core.update_alias_role('ptab.ptab_parties', 'alias_id', NEW.alias_id, 'I', 'ptab_party');
        END IF;
        RETURN NEW;
    ELSE
        RAISE EXCEPTION '[ptab..ptab_party_alias_role_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[ptab..ptab_party_alias_role_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[ptab..ptab_party_alias_role_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[ptab..ptab_party_alias_role_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: update_campaign_tr_function(); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION update_campaign_tr_function() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

  /*
  1.0 aprakash_c 16-06-2015 DS-1809 New trigger created
  2.0 aprakash_c 23-06-2015 Updated API to capture the changes and update lit_campaigns.ptab_campaigns
  */
   IF (TG_OP = 'UPDATE') THEN
    IF  coalesce(old.stripped_patnum, '') != coalesce(new.stripped_patnum, '') THEN
      UPDATE lit_campaigns.ptab_campaigns
	  SET needs_processing = TRUE,
	  updated_by = current_user
	  WHERE ptab_case_id = NEW. ID;
    END IF;
  ELSIF (TG_OP = 'INSERT') THEN
      INSERT INTO lit_campaigns.ptab_campaigns
	  (ptab_case_id,lit_campaign_id, ptab_campaign_id, needs_processing,created_by,updated_by)
	  VALUES
	  (NEW.id, NULL,NULL, TRUE, current_user, current_user);
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: update_ptab_parties_tab(integer, integer, integer, character varying, character varying); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION update_ptab_parties_tab(p_ptab_parties_id integer, p_ptab_case_id integer DEFAULT NULL::integer, p_ptab_party_type_id integer DEFAULT NULL::integer, p_party_name character varying DEFAULT NULL::character varying, p_updated_by character varying DEFAULT 'docs_app'::character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$ DECLARE
	updated_rows INTEGER := 0 ;
	v_alias_id INTEGER DEFAULT NULL;
BEGIN
	/*
	1.0 2015-02-19 aprakash_c DS-1192: New Function update_ptab_parties_tab Created for editing the existing entries in ptab_parties
	1.1 2016-01-26 vpemmaraju DS_3173 : changed the default user to docs_app
	*/
	SELECT * INTO v_alias_id FROM core.find_or_create_alias(p_party_name);

	UPDATE ptab.ptab_parties
	SET ptab_case_id = COALESCE(p_ptab_case_id,ptab_case_id),
	 ptab_party_type_id = COALESCE(p_ptab_party_type_id,ptab_party_type_id),
	 alias_id = COALESCE(v_alias_id,alias_id),
	 updated_by = p_updated_by
	WHERE
	 ID = p_ptab_parties_id ; GET DIAGNOSTICS updated_rows = ROW_COUNT ;
IF updated_rows > 0 THEN
	RETURN p_ptab_parties_id ;
ELSE
	RETURN - 1 ;
END
IF ; EXCEPTION
WHEN OTHERS THEN
	RAISE NOTICE '% %',
	SQLSTATE,
	sqlerrm ; RETURN - 1 ;
END ; $$;


--
-- Name: update_timestamp(); Type: FUNCTION; Schema: ptab; Owner: -
--

CREATE FUNCTION update_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at := current_timestamp;
    RETURN NEW;
END;
$$;


SET search_path = public, pg_catalog;

--
-- Name: arr_subtract(anyarray, anyarray); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION arr_subtract(anyarray, anyarray) RETURNS anyarray
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
SELECT ARRAY(
    SELECT A
    FROM UNNEST ($1) A
    WHERE A <> ALL ($2)
  );
$_$;


--
-- Name: bitand(bigint, bigint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION bitand(bigint, bigint) RETURNS bigint
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT $1 & $2; $_$;


--
-- Name: commit_by_dblink(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION commit_by_dblink(arg_name text, arg_sql text) RETURNS void
    LANGUAGE plpgsql STRICT SECURITY DEFINER
    AS $$
BEGIN
    PERFORM public.get_dblink_connection(arg_name);
    PERFORM public.dblink_exec(arg_name, 'BEGIN;' || arg_sql || ';COMMIT;');
END;
$$;


--
-- Name: cosh(double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cosh(double precision) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT (exp($1) + exp(-$1)) / 2; $_$;


--
-- Name: create_all_audit_partition_tables_sf(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION create_all_audit_partition_tables_sf(p_to_schema text, p_partition_key text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_tables		TEXT[];
    v_to_schema		TEXT := COALESCE(p_to_schema, 'sf_audit');
    v_partition_key	TEXT := COALESCE(p_partition_key, 'par_key');
    v_owner			TEXT := 'rj';

    v_sql_result TEXT := '';
    v_full_query TEXT := '';
    tab TEXT;

BEGIN
    v_tables := ARRAY['accountx',
                      'acquisition_opportunity__c',
                      'acquisition_patent_families',
                      'contentdocument',
                      'contentversion',
                      'oma_patent__c',
                      'opportunity_litigation__c',
                      'organizationx',
                      'product_or_service__c',
                      'userx'
                      ];

    FOREACH tab IN ARRAY v_tables
    LOOP
        EXECUTE('SELECT core_audit.create_audit_partition_tables(''' || tab || ''', ''' || v_to_schema || ''', ''' || v_partition_key || ''', FALSE, ''' || v_owner || ''');') INTO v_sql_result ;
        v_full_query = v_full_query || v_sql_result || chr(10) ;
        v_full_query = v_full_query || '---------------------------------------------------' || chr(10) || chr(10) ;
    END LOOP;

    RETURN v_full_query;

END;
$$;


--
-- Name: create_configured_indexes(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION create_configured_indexes(i_schema character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
 rd RECORD;
BEGIN

 for rd in
 SELECT
    relname,
    a.attname as cname,
    pg_catalog.format_type(a.atttypid, a.atttypmod) as datatype
  FROM
    pg_catalog.pg_attribute a
  JOIN
    (SELECT c.oid,c.*,n.*
     FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace) c ON a.attrelid=c.oid
  WHERE a.attnum > 0
  AND NOT a.attisdropped
  AND nspname = i_schema
  AND relname not like '%_inc'
  AND (a.attname like '%_id' or a.attname like '%patnum%' or a.attname like '%case_key%' or a.attname like '%_uid%')
  AND a.attname not in ('stg_id', 'id', 'created_at', 'updated_at', 'created_by', 'updated_by')
  AND relkind = 'r' Loop
   BEGIN
    ---RAISE NOTICE 'Creating % index for %', rd.cname, rd.relname;
    EXECUTE 'create index idx_' || rd.relname || '_' || rd.cname || ' on ' || i_schema || '.' || rd.relname || '( ' || rd.cname || ');';
   EXCEPTION
    when others then
     RAISE NOTICE 'Error when creating indexes: %', sqlerrm;
   END;
 end loop;

 return 1;
END;
$$;


--
-- Name: get_dblink_connection(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION get_dblink_connection(arg_name text) RETURNS void
    LANGUAGE plpgsql STRICT SECURITY DEFINER
    AS $$
DECLARE
    open_connections    TEXT[];
    dblink_handle       TEXT;
BEGIN
    open_connections = public.dblink_get_connections();

    IF open_connections @> ('{' || arg_name || '}')::TEXT[] THEN
        RETURN;
    END IF;

    SELECT public.dblink_connect( arg_name, (SELECT config.dblink_connection(arg_name)) ) INTO dblink_handle;
END;
$$;


--
-- Name: get_entity_sub_tree(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION get_entity_sub_tree(p_ent_id integer) RETURNS SETOF record
    LANGUAGE sql SECURITY DEFINER
    AS $_$
------------------The FINAL query: Find the top node, and then traverse its sub tree
WITH RECURSIVE my_tree1(ent_id, related_ent_id, id, lvl1) AS
	( ----FIND THE TOP NODE ----
		SELECT ent_id, related_ent_id,et.id id,1 lvl1
		FROM core.ent_relationships et
		WHERE ent_id in ($1)
	  UNION ALL
		SELECT et.ent_id, et.related_ent_id,et.id id, mt1.lvl1+1 lvl1
		FROM core.ent_relationships et
		JOIN my_tree1 mt1 on mt1.ent_id=et.related_ent_id --->traverse UP the tree
		WHERE mt1.id<>et.id
	)
		SELECT mt1.ent_id ent_id, mt1.related_ent_id related_ent_id, mt1.lvl1 ent_level
		FROM my_tree1 mt1
$_$;


--
-- Name: get_entity_tree(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION get_entity_tree(p_ent_id integer) RETURNS SETOF record
    LANGUAGE sql SECURITY DEFINER
    AS $_$
------------------The FINAL query: Find the top node, and then traverse its sub tree
WITH RECURSIVE my_tree2(ent_id, related_ent_id, id ,lvl2) AS
(----Traverse the whole tree ----
SELECT ent_id, related_ent_id, id, 1 lvl2
from
(WITH RECURSIVE my_tree1(ent_id, related_ent_id, id, lvl1) AS
	( ----FIND THE TOP NODE ----
		SELECT ent_id, related_ent_id,et.id id,1 lvl1
		FROM core.ent_relationships et
		WHERE ent_id in ($1)
	  UNION ALL
		SELECT et.ent_id, et.related_ent_id,et.id id, mt1.lvl1+1 lvl1
		FROM core.ent_relationships et
		JOIN my_tree1 mt1 on mt1.related_ent_id=et.ent_id --->traverse UP the tree
		WHERE mt1.id<>et.id
	)
		SELECT mt1.ent_id, mt1.related_ent_id,mt1.lvl1,id, max(mt1.lvl1) over () max_lvl
		FROM my_tree1 mt1
 ) a
where a.lvl1=a.max_lvl
 UNION ALL
    SELECT et.ent_id, et.related_ent_id,  et.id id, mt2.lvl2+1 lvl2
    FROM core.ent_relationships et
    JOIN my_tree2 mt2 on mt2.ent_id=et.related_ent_id --->traverse DOWN the tree
	where et.id!=mt2.id
 )
select mt2.ent_id ent_id,mt2.related_ent_id related_ent_id, mt2.lvl2 ent_level
from my_tree2 mt2
$_$;


--
-- Name: get_entity_ultimate_parent(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION get_entity_ultimate_parent(p_ent_id integer) RETURNS SETOF record
    LANGUAGE sql SECURITY DEFINER
    AS $$
select ent_id , related_ent_id, ent_level
FROM(
WITH RECURSIVE my_tree1(ent_id, related_ent_id, id, lvl1) AS
	( ----FIND THE TOP NODE ----
		SELECT ent_id, related_ent_id,et.id id,0 lvl1
		FROM core.ent_relationships et
		WHERE ent_id in (328818)
	  UNION ALL
		SELECT et.ent_id, et.related_ent_id,et.id id, mt1.lvl1+1 lvl1
		FROM core.ent_relationships et
		JOIN my_tree1 mt1 on mt1.related_ent_id=et.ent_id --->traverse UP the tree
		WHERE mt1.id<>et.id
	)
		SELECT mt1.ent_id ent_id, mt1.related_ent_id related_ent_id,mt1.lvl1 ent_level, max(mt1.lvl1) over () max_lvl
		FROM my_tree1 mt1
) mt1
where max_lvl = ent_level
$$;


--
-- Name: get_patent_info(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION get_patent_info() RETURNS SETOF core.cp_core_etl_patent
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	core_patent public.cp_core_etl_patent;
BEGIN
	for core_patent in
	(
			WITH portfolio_patents as
				(
						SELECT DISTINCT patnum
						from dblink
						( config.dblink_connection('rawdb.dblink_cp_etl'),
						'
							SELECT
								p.patent_no patnum
							FROM sf20.acquisition_opportunity ao
							INNER JOIN  sf20.oma_patent op on ao.id=op.acquisition_opportunity
							LEFT OUTER JOIN sf20.patent p on op.patent=p."id"
							WHERE
								ao.isdeleted = ''false''
							AND	op.isdeleted = ''false''
							AND	p.isdeleted  = ''false''
							AND ao.recordtypeid like ''012Q00000004dzw%''
							AND ao.confidentiality_level != ''Highly Confidential''
						'
						) as pat(patnum text)
				)
				SELECT DISTINCT
						pat.title,
						pat.app_filing_date application_date,
						pat.publication_date,
						pat.id core_db_patent_id,
						pat.patnum core_db_patnum,
						substring(pat.patnum from 3 for 7) patnum,
						false application,
						public.inventors_for_patent(pat.id) inventor
				FROM core.pats pat, portfolio_patents pp
				WHERE pat.patnum=pp.patnum
	) LOOP
		return next core_patent;
	end loop;
END;
$$;


--
-- Name: get_related_views(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION get_related_views(p_schema_name character varying, p_table_name character varying DEFAULT NULL::character varying) RETURNS SETOF related_views_type
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 rd1 RECORD;
 rd public.related_views_type%rowtype;
BEGIN

FOR rd1 in (SELECT nspname, relname FROM pg_class pc JOIN pg_namespace pn ON pn.oid = pc.relnamespace  WHERE pn.nspname::varchar = p_schema_name AND pc.relname::varchar = coalesce(p_table_name, pc.relname::varchar)) Loop
 FOR rd in (
     WITH RECURSIVE tree AS (
     SELECT distinct dependee.relname child_view, dependent.relname parent_view, ne.nspname as child_schema, nt.nspname as parent_schema, dependent.relkind as object_type
     FROM pg_depend
     JOIN pg_rewrite ON pg_depend.objid = pg_rewrite.oid
     JOIN pg_class as dependee ON pg_rewrite.ev_class = dependee.oid
     JOIN pg_class as dependent ON pg_depend.refobjid = dependent.oid
     JOIN pg_namespace ne ON ne.oid = dependee.relnamespace
     JOIN pg_namespace nt ON nt.oid = dependent.relnamespace
     WHERE dependent.relname::varchar = rd1.relname
           AND nt.nspname::varchar = p_schema_name
     UNION
     SELECT distinct dependee.relname child_view, dependent.relname parent_view, ne.nspname as child_schema, nt.nspname as parent_schema, dependent.relkind as object_type
     FROM pg_depend
     JOIN pg_rewrite ON pg_depend.objid = pg_rewrite.oid
     JOIN pg_class as dependee ON pg_rewrite.ev_class = dependee.oid
     JOIN pg_class as dependent ON pg_depend.refobjid = dependent.oid
     JOIN pg_namespace ne ON ne.oid = dependee.relnamespace
     JOIN pg_namespace nt ON nt.oid = dependent.relnamespace
     JOIN tree ON (tree.child_view = dependent.relname and tree.child_schema = nt.nspname)
     )
     select distinct parent_schema::varchar, parent_view::varchar, child_schema::varchar, child_view::varchar, object_type::varchar
     from tree
     ) LOOP
     return next rd;
 END LOOP;
END LOOP;
END;
$$;


--
-- Name: get_tab_grants(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION get_tab_grants(p_schema_name character varying, p_owner character varying, p_table_name character varying DEFAULT NULL::character varying) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_text text := '';
BEGIN
select array_to_string(array_agg(grant_text), ';')
into v_text
from (
select 'grant ' || all_grants || case when p_table_name is null then ' on all tables in schema ' || table_schema   else ' on table ' || table_schema || '.' || p_table_name  end || ' to ' || all_grantees || ';' as grant_text
from (
select array_to_string(array_agg(grantee), ',') as all_grantees, all_grants, table_schema
from (
  select array_to_string(array_agg(privilege_type::varchar), ',')::varchar as all_grants, grantee, table_schema
  from (
   select distinct table_schema::varchar, privilege_type::varchar, grantee::varchar
   from  information_schema.role_table_grants
   WHERE table_schema::text = p_schema_name::text and grantee::text <> p_owner::text and table_name::text = (coalesce(p_table_name, table_name))::text
  ) t
  group by table_schema,  grantee
)t
group by all_grants, table_schema
) t
) t;
 return v_text;
END;
$$;


--
-- Name: get_view_syntax(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION get_view_syntax(p_schema_name character varying, p_view_name character varying) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 rd RECORD;
 v_create_view text := '';
BEGIN
 for rd in (select viewname,viewowner, schemaname, definition from pg_views where schemaname::varchar =  p_schema_name AND viewname::varchar =  p_view_name) loop
   v_create_view := '';
   v_create_view := v_create_view || ' create or replace view ' || rd.schemaname || '.' || rd.viewname || ' as ' || rd.definition || ';';
   v_create_view := v_create_view || ' alter view ' || rd.schemaname || '.' || rd.viewname || ' owner to ' || rd.viewowner || ';';
   v_create_view := v_create_view || coalesce(public.get_tab_grants(rd.schemaname::varchar, rd.viewowner::varchar, rd.viewname::varchar), '');
   if v_create_view is NULL then
    RAISE NOTICE 'view name: %', rd.viewname;
   end if;
   return v_create_view;
 end loop;
END;
$$;


--
-- Name: grant_access(text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION grant_access(schema_name text, role_name text, priv_list text DEFAULT 'SELECT'::text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
        IF priv_list = 'SELECT' then
                EXECUTE 'GRANT USAGE ON SCHEMA ' || schema_name || ' TO ' || role_name;
        ELSE
                EXECUTE 'GRANT ALL ON SCHEMA ' || schema_name || ' TO ' || role_name;
                RAISE NOTICE 'GROUP/ROLE % was granted read-write access to schema %', role_name, schema_name;
        END IF;

        EXECUTE 'GRANT ' || priv_list || ' ON ALL TABLES IN SCHEMA ' || schema_name || ' TO ' || role_name;
        EXECUTE 'GRANT SELECT ON ALL SEQUENCES IN SCHEMA ' || schema_name || ' TO ' || role_name;
        EXECUTE 'GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA ' || schema_name || ' TO ' || role_name;
        RAISE NOTICE 'GROUP/ROLE % was granted % on all tables in schema %', role_name, priv_list, schema_name;
END;
$$;


--
-- Name: inventors_for_patent(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION inventors_for_patent(patent_id integer, join_string character varying DEFAULT '|'::character varying) RETURNS character varying
    LANGUAGE plpgsql STRICT SECURITY DEFINER
    AS $$
DECLARE
    inventors VARCHAR := '';
    c_inventors CURSOR (
        seek_patent_id core.pats.id%TYPE
    ) IS
			SELECT
					(case when e.name is null then a.name else e.name end) inventor
			from core.pats_aliases_map pam
			left outer join core.aliases a on a.id=pam.alias_id
			left outer join core.ents e on e.id=a.ent_id
			where pam.pat_id=seek_patent_id
			  and pam.pats_aliases_relationship_type_id=7 /* INVENTOR */;
BEGIN
    FOR row IN c_inventors (patent_id) LOOP
        inventors := inventors || row.inventor || join_string;
    END LOOP;

    IF LENGTH(inventors) > LENGTH(join_string) THEN
        RETURN SUBSTR(inventors, 1, LENGTH(inventors) - LENGTH(join_string)); -- remove trailing join string
    ELSE
        RETURN inventors;
    END IF;
END;
$$;


--
-- Name: nanvl(real, real); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION nanvl(real, real) RETURNS real
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT CASE WHEN $1 = 'NaN' THEN $2 ELSE $1 END; $_$;


--
-- Name: nanvl(double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION nanvl(double precision, double precision) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT CASE WHEN $1 = 'NaN' THEN $2 ELSE $1 END; $_$;


--
-- Name: nanvl(numeric, numeric); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION nanvl(numeric, numeric) RETURNS numeric
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT CASE WHEN $1 = 'NaN' THEN $2 ELSE $1 END; $_$;


--
-- Name: pg_schema_size(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION pg_schema_size(text) RETURNS bigint
    LANGUAGE sql
    AS $_$
SELECT sum(pg_total_relation_size('"' || schemaname || '"' || '.' || '"' || tablename || '"'))::bigint FROM pg_tables WHERE schemaname = $1
$_$;


--
-- Name: ps_lit_normalized(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION ps_lit_normalized(p_docket_info_id integer) RETURNS TABLE(case_key character varying, docket_info_id integer, docket_number_long character varying, docket_number character varying, case_type character varying, lit_cause_type_id integer, filed_date date, closed_date date, is_open boolean, nos integer, demand numeric, jurisdiction character varying, jury_demand character varying, is_administratively_closed boolean, title character varying, last_pacer_retrieval_for_summary timestamp without time zone, last_pacer_retrieval_for_docket timestamp without time zone, last_pacer_retrieval_for_parties timestamp without time zone, added_at timestamp without time zone, has_spammy_parties boolean, has_spammy_patents boolean, has_complaint boolean, date_reopened date)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
BEGIN
/* DS-4991 : ateja_c 11-04-2017 Added protection to closed_date & is_open flag using DCL */
    RETURN QUERY
    SELECT
        r_case_key,
        r_docket_info_id,
        r_docket_number_long,
        substring(r_docket_number_long, 1, 13)::VARCHAR AS r_docket_number,
        substring(r_docket_number_long, 6, 2)::VARCHAR AS r_case_type,
        core.find_or_create_lit_cause_type(r_lit_cause::varchar) AS r_lit_cause_type_id,
        r_filed_date,
        (SELECT closed_date  FROM  data_dcl.get_closed_date_is_open_core_lits(l.case_key , r_closed_date::date ,r_date_reopened::date) ) as closed_date,
        (SELECT is_open FROM  data_dcl.get_closed_date_is_open_core_lits(l.case_key , r_closed_date::date ,r_date_reopened::date) ) as is_open,
        r_nos,
        r_demand::NUMERIC,
        r_jurisdiction,
        r_jury_demand,
        r_is_administratively_closed,
        r_title,
        r_last_pacer_retrieval_for_summary,
        r_last_pacer_retrieval_for_docket,
        r_last_pacer_retrieval_for_parties,
        r_added_at,
        r_has_spammy_parties,
        r_has_spammy_patents,
        r_has_complaint,
        r_date_reopened
    FROM pacer_data_service.ps_lit(p_docket_info_id);

END;
$$;


--
-- Name: remove_text_from_judge(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION remove_text_from_judge(judge_name character varying) RETURNS character varying
    LANGUAGE plperl
    AS $_X$

  my($work_name) = @_ ;

  # Strip preceding punctuation and whitespace.
  $work_name =~ s/(\x13|\r|\n)/ /g;     # get rid of any carriage return
  $work_name =~ s/\s+/ /g;     # change multiple space in the string to single
  $work_name =~ s/^\W+//;    #trim punctuation from the start
  $work_name =~ s/^\s+//;    #trim whitespace from the start
  $work_name =~ s/\s+$//;    #trim whitespace from the end

  # If it is a known unassigned text, set it to a standard
  if ($work_name =~ m/unassigned/i || $work_name =~ m/vacant/i)
    {$work_name = 'Unassigned Judge'}

  # parenthesis are used for (Settlement), (MAG), (Magistrate), (REFERRAL JUDGE), (m), (2002), (MJ)
  # remove them.
  $work_name =~ s/ \(.*\)$//;
  $work_name =~ s/ \(.*\) / /g;
  $work_name =~ s/\($//;
  $work_name =~ s/^\s+//;    #trim whitespace from the start
  $work_name =~ s/\s+$//;    #trim whitespace from the end

  # Strip trailing titles.
  $work_name =~ s/ magistrate judge$//i;
  $work_name =~ s/ judge$//i;
  $work_name =~ s/ magistrate$//i;
  $work_name =~ s/^\s+//;    #trim whitespace from the start
  $work_name =~ s/\s+$//;    #trim whitespace from the end

  # find ', MJ', chop off everything after
  my $lower_name = lc $work_name;
  my $idx = index($lower_name, ', mj');
  if ($idx > -1)
    {$work_name = substr($work_name, 0 , $idx)}

  # find '-MG', chop off everything after
  my $lower_name = lc $work_name;
  my $idx = index($lower_name, '-mg');
  if ($idx > -1)
    {$work_name = substr($work_name, 0 , $idx)}

  # find '- INACTIVE', chop off everything after
  my $lower_name = lc $work_name;
  my $idx = index($lower_name, '- inactive');
  if ($idx > -1)
    {$work_name = substr($work_name, 0 , $idx)}

  $work_name =~ s/^\s+//;    #trim whitespace from the start
  $work_name =~ s/\s+$//;    #trim whitespace from the end

  #Strip leading titles
  my $lower_name = lc $work_name;
  my $idx = index($lower_name, 'judge');
  if ($idx > -1)
    {$work_name = substr($work_name, $idx+6)}
  my $lower_name = lc $work_name;
  my $idx = index($lower_name, 'magistrate');
  if ($idx > -1)
    {$work_name = substr($work_name, $idx+11)}

  # There are a few that are just listed as 'Judge' or 'Magistrate Judge' in which case we have just stripped them completely
  # so we need to put our place holder there so it is not blank
  if ($work_name =~ m/^\s*$/)
    {$work_name='Unassigned Judge'}

  # If we have just striped the word judge off 'Unassigned Judge' put it back
  if ($work_name =~ m/^unassigned\s*$/i)
    {$work_name='Unassigned Judge'}

  @titles = (
    'honorable',
    'hon\.',
    'discovery ',
    'usmj ',
    '^Visiting Judge VJ,',
    '^Federal Circuit Judg'
  );
  foreach (@titles) {
    $work_name =~ s/$_//ig;
  }

  $work_name =~ s/^MJ //g;
  $work_name =~ s/ MJ$//g;

  #Pull " MJ " from anywhere in the name and replace with a single space
  $work_name =~ s/ MJ / /g;

  $work_name =~ s/^\s+//;    #trim whitespace from the start
  $work_name =~ s/\s+$//;    #trim whitespace from the end

  return $work_name;
$_X$;


--
-- Name: reprocess_pat_families_for_sf_opportunities(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION reprocess_pat_families_for_sf_opportunities() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
 RD RECORD;
 v_result INTEGER;
BEGIN
 FOR RD IN SELECT distinct pat_family_id
           FROM   docdb_families.pat_family_pats pfp, sf.oma_patent__c op
           WHERE  pfp.patnum = p.patentnumber__c LOOP

  SELECT x INTO v_result
  FROM public.dblink(config.dblink_connection('coredb'), 'SELECT docdb_families.reprocess_pat_families('|| RD.pat_family_id ||');')
  as temp(x INTEGER);

 END LOOP;
 RETURN 1;
END;
$$;


--
-- Name: sf_oma_for_patent_blaster_trig_func(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION sf_oma_for_patent_blaster_trig_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
 v_task_id patent_blaster.tasks.id%type;
 v_count INTEGER := 0;
BEGIN
    IF (TG_OP = 'UPDATE') THEN
      IF COALESCE(OLD.isdeleted, 'false') != COALESCE(NEW.isdeleted, 'false') THEN
         ---here is an issue:
         ---if they delete a patent from a portfolio
         ---if the patent is already annotated, we don't want to lose the patent annoation information
         ---or we remove the foreign key constraints on (task_id, pat_id)
         ---let's take the first one
         IF COALESCE(NEW.isdeleted, 'false') = 'true' THEN
          BEGIN
          DELETE FROM patent_blaster.task_pats p
          WHERE task_id = (
                   SELECT id
                   FROM patent_blaster.tasks
                   WHERE opportunity_id = OLD.acquisition_opportunity__c) AND
                stripped_patnum = OLD.stripped_patnum__c AND
                NOT EXISTS (
                   SELECT 1 FROM patent_blaster.pat_annotations pa
                   WHERE pa.pat_id = p.pat_id
                );
          GET DIAGNOSTICS v_count = ROW_COUNT;
          RAISE NOTICE 'Deleted % row(s) for task_pats from isdeleted', v_count;

          EXCEPTION
            WHEN OTHERS THEN
             RAISE NOTICE 'Could not delete task_pats from patent_blaster: %', sqlerrm;
             RAISE;
          END;
         ELSE
          ---this is the case that a patent got deleted first then comes back.
          BEGIN
          INSERT INTO patent_blaster.task_pats
          (task_id, stripped_patnum, country_code, pat_id)
          SELECT (SELECT id
                FROM patent_blaster.tasks
                WHERE opportunity_id = NEW.acquisition_opportunity__c),
                p.stripped_patnum,
                p.country_code, p.id
          FROM sf.oma_patent__c o, core.pats p
          WHERE
               o.id = NEW.id AND
               o.stripped_patnum__c = p.stripped_patnum AND
               p.patnum not like '%W0';

          GET DIAGNOSTICS v_count = ROW_COUNT;
          RAISE NOTICE 'Inserted % row(s) for task_pats from isdeleted', v_count;
          EXCEPTION
            WHEN unique_violation THEN
              NULL;
            WHEN OTHERS THEN
              RAISE;
          END;
         END IF;
      END IF;
      RETURN NEW;

    ELSIF (TG_OP = 'DELETE') THEN
      UPDATE patent_blaster.task_pats
      SET is_deleted = true
      WHERE OLD.stripped_patnum__c = stripped_patnum AND
            task_id = (SELECT id FROM patent_blaster.tasks WHERE opportunity_id = OLD.acquisition_opportunity__c);

      --do nothing
      RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN

	--- test if parent exists, raise exception otherwise
	SELECT id INTO v_task_id
	FROM   patent_blaster.tasks
	WHERE  opportunity_id = NEW.acquisition_opportunity__c ;
	IF NOT FOUND THEN
         INSERT INTO patent_blaster.tasks
         (opportunity_id, analyst_name, name)
         SELECT
           NEW.acquisition_opportunity__c
         , 'NA'
         , 'NA'
        RETURNING id INTO v_task_id;
    		RAISE EXCEPTION 'Acquisition Opportunity identyfied by % is not found !!', NEW.acquisition_opportunity__c;
	END IF;

	----insert opportunities, market sectors, recommendation
        ----insert task
        ----insert task patent
        INSERT INTO patent_blaster.task_pats
        (task_id, stripped_patnum, country_code, pat_id)
        SELECT task_id, stripped_patnum, country_code, id
        FROM (
         SELECT (SELECT id
                FROM patent_blaster.tasks
                WHERE opportunity_id = NEW.acquisition_opportunity__c) as task_id,
                p.stripped_patnum,
                p.country_code, p.id
         FROM core.pats p
         WHERE
              NEW.stripped_patnum__c = p.stripped_patnum AND
              p.patnum not like '%W0'
        ) t
        WHERE NOT EXISTS (SELECT 1 FROM patent_blaster.task_pats WHERE task_id = t.task_id AND pat_id = t.id) AND
              task_id is NOT NULL
        RETURNING task_id INTO v_task_id;
        GET DIAGNOSTICS v_count = ROW_COUNT;
        RAISE NOTICE 'Inserted % row(s) for task_pats from INSERT', v_count;

        RETURN NEW;

    ELSE
        RAISE EXCEPTION '[sf..sf_oma_for_patent_blaster_trig_func] - Other action occurred: %, at %',TG_OP,now();
        RETURN NULL;
    END IF;

EXCEPTION
    WHEN data_exception THEN
        RAISE EXCEPTION '[sf..sf_oma_for_patent_blaster_trig_func] - UDF ERROR [DATA EXCEPTION] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN unique_violation THEN
        RAISE EXCEPTION '[sf..sf_oma_for_patent_blaster_trig_func] - UDF ERROR [UNIQUE] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION '[sf..sf_oma_for_patent_blaster_trig_func] - UDF ERROR [OTHER] - SQLSTATE: %, SQLERRM: %',SQLSTATE,SQLERRM;
        RETURN NULL;
END;
$$;


--
-- Name: sinh(double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION sinh(double precision) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT (exp($1) - exp(-$1)) / 2; $_$;


--
-- Name: sort(integer[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION sort(integer[]) RETURNS integer[]
    LANGUAGE sql IMMUTABLE
    AS $_$select pg_catalog.sort($1)$_$;


--
-- Name: tanh(double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION tanh(double precision) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT sinh($1) / cosh($1); $_$;


--
-- Name: uniq(integer[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION uniq(integer[]) RETURNS integer[]
    LANGUAGE sql IMMUTABLE
    AS $_$select pg_catalog.uniq($1)$_$;


SET search_path = core, pg_catalog;

--
-- Name: lits; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lits (
    id integer NOT NULL,
    docketx_id character varying(32),
    case_key character varying(32) NOT NULL,
    lit_cause_id integer,
    nos integer NOT NULL,
    demand numeric(16,2),
    docket_number character varying(13),
    docket_number_long character varying(128),
    jurisdiction character varying(40),
    jury_demand character varying(30),
    filed_date date NOT NULL,
    closed_date date,
    judgment_date date,
    decided_date date,
    reopened_date date,
    disposed_date date,
    is_open boolean NOT NULL,
    title character varying(255) NOT NULL,
    case_type character(2),
    last_pacer_retrieval_for_summary timestamp without time zone,
    last_pacer_retrieval_for_docket timestamp without time zone,
    last_pacer_retrieval_for_parties timestamp without time zone,
    has_spammy_parties boolean DEFAULT false,
    has_spammy_patents boolean DEFAULT false,
    has_complaint boolean DEFAULT false,
    added_at timestamp without time zone,
    created_at timestamp without time zone NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    docket_info_id integer,
    is_administratively_closed boolean DEFAULT false NOT NULL,
    salesforce_id character varying(18),
    original_filed_date date NOT NULL,
    pacer_docket_not_found boolean DEFAULT false,
    pacer_docket_is_sealed boolean DEFAULT false,
    is_dcl_corrected boolean
);


--
-- Name: TABLE lits; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE lits IS 'Litigations main docket information (docketx: districtdocket)';


--
-- Name: COLUMN lits.id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.id IS 'Litigation ID';


--
-- Name: COLUMN lits.docketx_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.docketx_id IS 'DocketX ID (docketx: districtdocket.id)';


--
-- Name: COLUMN lits.case_key; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.case_key IS 'A composed natural primary key of the form  "priorsmartCourtDistrictAcronym-caseID" (e.g. "casdce-362965") which we get from the priorsmart_mapping spreadsheet. (docketx: districtdocket.pacerid)';


--
-- Name: COLUMN lits.lit_cause_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.lit_cause_id IS 'Cause type from PACER (key connects to lit_cause_types)  (docketx: districtdocket.cause)';


--
-- Name: COLUMN lits.nos; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.nos IS 'Nature of Suit - 3 digit code (most will be 830) (docketx:districtdocket.nos)';


--
-- Name: COLUMN lits.demand; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.demand IS 'Monetary demand from plaintiff (docketx: districtdocket.demand)';


--
-- Name: COLUMN lits.docket_number; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.docket_number IS 'Docket case number (docketx: districtdocket.docketcasenumber)';


--
-- Name: COLUMN lits.docket_number_long; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.docket_number_long IS 'Docket case number with judges initials added (docketx: districtdocket.docketcasenumberlong)';


--
-- Name: COLUMN lits.jurisdiction; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.jurisdiction IS 'Federal Question
U.S. Government Defendant
U.S. Government Plaintiff
Diversity
(docketx: districtdocket.jurisdiction)';


--
-- Name: COLUMN lits.jury_demand; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.jury_demand IS '14991 | Plaintiff
  9311 | Both
  5543 | None
  2064 | Defendant
    50 |
    11 | Unknown
     2 | Either

(docketx: districtdocket.jurydemand)';


--
-- Name: COLUMN lits.filed_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.filed_date IS 'Complaint filing date
(docketx: districtdocket.datefiled)';


--
-- Name: COLUMN lits.closed_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.closed_date IS 'Date case is closed
(docketx: districtdocket.dateclosed)';


--
-- Name: COLUMN lits.judgment_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.judgment_date IS 'Judgement date (docketx: districtdocket.datejudgement)';


--
-- Name: COLUMN lits.decided_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.decided_date IS 'Decided date (docketx: districtdocket.datedecided)';


--
-- Name: COLUMN lits.reopened_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.reopened_date IS 'Date case re-opened (districtdocket.datereopened)';


--
-- Name: COLUMN lits.disposed_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.disposed_date IS 'Date case disposed (doxketx: districtdocket. datedisposed)';


--
-- Name: COLUMN lits.is_open; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.is_open IS 'True if docketx: districtdocket.status == "Open", false if "Closed"';


--
-- Name: COLUMN lits.title; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.title IS 'Case title (docketx: courtcase.fullcasetitle)';


--
-- Name: COLUMN lits.case_type; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.case_type IS 'Case type portion of the docket case number (docketx: courtcase.casetype)';


--
-- Name: COLUMN lits.last_pacer_retrieval_for_summary; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.last_pacer_retrieval_for_summary IS 'Time of last PACER update';


--
-- Name: COLUMN lits.last_pacer_retrieval_for_docket; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.last_pacer_retrieval_for_docket IS 'Time of last PACER docket update';


--
-- Name: COLUMN lits.last_pacer_retrieval_for_parties; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.last_pacer_retrieval_for_parties IS 'Time of last PACER parties update';


--
-- Name: COLUMN lits.has_spammy_parties; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.has_spammy_parties IS 'true : If the parties have names which can trigger spam filters. To be used for sending email';


--
-- Name: COLUMN lits.has_spammy_patents; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.has_spammy_patents IS 'true : If patent has any word that would trigger spam filter. To be used for sending emails from portal in future..';


--
-- Name: COLUMN lits.has_complaint; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.has_complaint IS 'True : If the docket has complaint';


--
-- Name: COLUMN lits.added_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.added_at IS 'Time when the docket is added to the priorsmart Database. Would not be present for dockets imported from docketx.';


--
-- Name: COLUMN lits.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: COLUMN lits.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN lits.docket_info_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.docket_info_id IS 'id from intakedb (key to link to docket information in raw/intake database)';


--
-- Name: COLUMN lits.is_administratively_closed; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.is_administratively_closed IS 'Was case closed for administrative reasons? (From Priorsmart)';


--
-- Name: COLUMN lits.original_filed_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits.original_filed_date IS 'Automatically controlled by the database. The oldest filed date from any case this litigation may have been transferred from. If not a transfer then same as filed_date';


--
-- Name: lits_pats_map_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lits_pats_map_id_seq
    START WITH 71500
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lits_pats_map; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lits_pats_map (
    lit_id integer NOT NULL,
    patnum character varying(15) NOT NULL,
    start_date date,
    end_date date,
    created_at timestamp without time zone DEFAULT (now())::timestamp without time zone NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    id integer DEFAULT nextval('lits_pats_map_id_seq'::regclass) NOT NULL,
    salesforce_id character varying(18),
    created_by character varying(255)
);


--
-- Name: TABLE lits_pats_map; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE lits_pats_map IS 'Table to house the list of patent numbers (stripped_patnum) involved in litigations.';


--
-- Name: COLUMN lits_pats_map.lit_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits_pats_map.lit_id IS 'Litigation id of the litigation the respective patent was named in.  Comment updated at: 2012-11-06';


--
-- Name: COLUMN lits_pats_map.patnum; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits_pats_map.patnum IS 'This is the stripped_patnum. It is NOT a patnum as in pats.patnum. To join with core.pats use lits_pats_map.patnum = pats.stripped_patnum. Comment updated at: 2012-11-06';


--
-- Name: COLUMN lits_pats_map.start_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits_pats_map.start_date IS 'INCORRECT: This column currently does not represent correct data with regards to the start and end date of the patent in suit. DO NOT USE. Comment updated at: 2012-11-06';


--
-- Name: COLUMN lits_pats_map.end_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits_pats_map.end_date IS 'INCORRECT: This column currently does not represent correct data with regards to the start and end date of the patent in suit. DO NOT USE. Comment updated at: 2012-11-06';


--
-- Name: COLUMN lits_pats_map.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits_pats_map.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: COLUMN lits_pats_map.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lits_pats_map.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


SET default_tablespace = rpx_user_default;

--
-- Name: pat_stats; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_stats (
    id integer NOT NULL,
    stripped_patnum character varying(32) NOT NULL,
    doc_kind_code character varying(16),
    country_code character varying(16),
    patnum character varying(255),
    num_backward_ref integer,
    num_forward_ref integer,
    num_claims_independant integer,
    num_claims_dependant integer,
    assignment_chain_break boolean,
    priority_date date,
    is_continuation boolean,
    num_open_continuances integer,
    time_in_review integer,
    word_cnt_indep_claims integer,
    word_cnt_dep_claims integer,
    word_cnt_patent integer,
    num_npl_ref integer,
    num_ents_citing integer,
    num_ult_parents_transacted integer,
    num_family_members integer,
    year_4_pay_date date,
    year_8_pay_date date,
    year_12_pay_date date,
    is_assign_pre_issue boolean,
    last_updated_by_tds_etl timestamp without time zone,
    last_updated_by_docdb_etl timestamp without time zone,
    last_updated_by_assign_etl timestamp without time zone,
    updated_at timestamp without time zone DEFAULT now(),
    created_at timestamp without time zone DEFAULT now(),
    last_updated_by_family_etl timestamp without time zone,
    run_id integer,
    expiration_date date,
    is_rpx_owned boolean,
    is_rpx_member_owned boolean,
    is_litigated boolean DEFAULT false,
    pat_id integer,
    examination_thoroughness numeric,
    num_citing_clusters integer,
    num_citing_assignees integer,
    num_defendants integer,
    word_cnt_shortest_indep_claim integer,
    forward_self_cites integer[],
    backward_self_cites integer[]
);


--
-- Name: TABLE pat_stats; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE pat_stats IS 'Table to capture stataistics and metrics calculated in-house at RPX.';


--
-- Name: COLUMN pat_stats.stripped_patnum; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.stripped_patnum IS 'The core patent number piece without country or kind code.';


--
-- Name: COLUMN pat_stats.doc_kind_code; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.doc_kind_code IS 'The patent number kind code.';


--
-- Name: COLUMN pat_stats.country_code; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.country_code IS 'The country from the patnum.';


--
-- Name: COLUMN pat_stats.patnum; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.patnum IS 'The full patent document number.';


--
-- Name: COLUMN pat_stats.num_backward_ref; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.num_backward_ref IS 'The number of patents that this patent references.';


--
-- Name: COLUMN pat_stats.num_forward_ref; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.num_forward_ref IS 'The number of patents that reference this patent.';


--
-- Name: COLUMN pat_stats.num_claims_independant; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.num_claims_independant IS 'The number of claims in this patent that are not dependant on another claim.';


--
-- Name: COLUMN pat_stats.num_claims_dependant; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.num_claims_dependant IS 'The number of claims in this patent that do depend on another claim.';


--
-- Name: COLUMN pat_stats.assignment_chain_break; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.assignment_chain_break IS 'This is TRUE if the assignees of an assignment (or any of those before) do not match the assignors of the next assignment.';


--
-- Name: COLUMN pat_stats.priority_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.priority_date IS 'This earliest filing date of the extended (US and international) patent family.';


--
-- Name: COLUMN pat_stats.is_continuation; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.is_continuation IS 'TRUE if is marked as a continuation in the DocDB dataset.';


--
-- Name: COLUMN pat_stats.num_open_continuances; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.num_open_continuances IS 'The number of documents linked as continuances in DocDB.';


--
-- Name: COLUMN pat_stats.time_in_review; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.time_in_review IS 'The number of days between the application and the issue date of a patent.';


--
-- Name: COLUMN pat_stats.word_cnt_indep_claims; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.word_cnt_indep_claims IS 'The number of words in all the independant claims combined.';


--
-- Name: COLUMN pat_stats.word_cnt_dep_claims; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.word_cnt_dep_claims IS 'The number of words in all the dependant claims combined.';


--
-- Name: COLUMN pat_stats.word_cnt_patent; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.word_cnt_patent IS 'The number of words in the patent. This includes the title, abstract, description, and all claims.';


--
-- Name: COLUMN pat_stats.num_npl_ref; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.num_npl_ref IS 'The number of non-patent literature references for the patent.';


--
-- Name: COLUMN pat_stats.num_ents_citing; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.num_ents_citing IS 'The number ultimate parent entities (or if not disambiguated, the number of distinct core_names) that have a patent that references this patent.';


--
-- Name: COLUMN pat_stats.num_ult_parents_transacted; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.num_ult_parents_transacted IS 'The number ultimate parent entities (or if not disambiguated, the number of distinct core_names) that have been referenced in an assignment for this patent.';


--
-- Name: COLUMN pat_stats.num_family_members; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.num_family_members IS 'The number of patents that share the same patent family.';


--
-- Name: COLUMN pat_stats.year_4_pay_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.year_4_pay_date IS 'The date the 4 year maintenance should be paid. This does not indicate it was paid, just the date it should be paid by.';


--
-- Name: COLUMN pat_stats.year_8_pay_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.year_8_pay_date IS 'The date the 8 year maintenance should be paid. This does not indicate it was paid, just the date it should be paid by.';


--
-- Name: COLUMN pat_stats.year_12_pay_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.year_12_pay_date IS 'The date the 12 year maintenance should be paid. This does not indicate it was paid, just the date it should be paid by.';


--
-- Name: COLUMN pat_stats.is_assign_pre_issue; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.is_assign_pre_issue IS 'TRUE if the first assignment of this patent was recorded before the patent was issued.';


--
-- Name: COLUMN pat_stats.num_defendants; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats.num_defendants IS 'number of ultimate parent defendants of a patent where the curated cause type is patent infringement, willful patent infringement';


SET search_path = public, pg_catalog;

--
-- Name: nmul(numeric); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE nmul(numeric) (
    SFUNC = numeric_mul,
    STYPE = numeric
);


SET search_path = acquiflow, pg_catalog;

SET default_tablespace = '';

--
-- Name: acq_1016_asset_updates; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE acq_1016_asset_updates (
    id integer,
    abandoned character varying,
    disc_number character varying,
    country_code character varying,
    application_number character varying,
    stripped_patnum character varying,
    status character varying,
    sub_status character varying,
    sub_status_date date,
    filed_date date,
    issue_date date,
    expiry_date date,
    assignee character varying,
    full_disc_number character varying,
    title character varying,
    inventors character varying,
    stripped_patnum_updated character varying,
    application_number_updated character varying
);


SET default_tablespace = rpx_user_default;

--
-- Name: acquisition_agreements; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE acquisition_agreements (
    id integer NOT NULL,
    acquisition_id integer NOT NULL,
    agreement_term_id integer,
    fee character varying,
    license_back boolean,
    agreement_doc character varying,
    seller_sf_account_id character varying,
    notes character varying,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


SET default_tablespace = '';

--
-- Name: acquisition_agreements_agreement_types; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE acquisition_agreements_agreement_types (
    id integer NOT NULL,
    acquisition_agreement_id integer NOT NULL,
    agreement_type_id integer NOT NULL
);


--
-- Name: acquisition_agreements_agreement_types_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE acquisition_agreements_agreement_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: acquisition_agreements_agreement_types_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE acquisition_agreements_agreement_types_id_seq OWNED BY acquisition_agreements_agreement_types.id;


--
-- Name: acquisition_agreements_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE acquisition_agreements_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: acquisition_agreements_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE acquisition_agreements_id_seq OWNED BY acquisition_agreements.id;


SET default_tablespace = rpx_user_default;

--
-- Name: acquisition_encumbrance_patents; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE acquisition_encumbrance_patents (
    acquisition_encumbrance_id integer NOT NULL,
    acquisition_patent_id integer NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"(),
    id integer NOT NULL
);


--
-- Name: acquisition_encumbrance_patents_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE acquisition_encumbrance_patents_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: acquisition_encumbrance_patents_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE acquisition_encumbrance_patents_id_seq OWNED BY acquisition_encumbrance_patents.id;


--
-- Name: acquisition_encumbrances; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE acquisition_encumbrances (
    id integer NOT NULL,
    acquisition_id integer NOT NULL,
    encumbrance_type_id integer NOT NULL,
    entity_sf_account_id character varying,
    notes character varying,
    all_patents boolean,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"(),
    start_date date,
    end_date date
);


--
-- Name: acquisition_encumbrances_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE acquisition_encumbrances_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: acquisition_encumbrances_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE acquisition_encumbrances_id_seq OWNED BY acquisition_encumbrances.id;


SET default_tablespace = '';

--
-- Name: acquisition_opportunities_portfolios; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE acquisition_opportunities_portfolios (
    id integer NOT NULL,
    portfolio_id integer NOT NULL,
    acquisition_sf_id character varying(64) NOT NULL,
    created_by character varying(64) DEFAULT "current_user"() NOT NULL,
    updated_by character varying(64) DEFAULT "current_user"() NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


--
-- Name: acquisition_opportunities_portfolios_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE acquisition_opportunities_portfolios_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: acquisition_opportunities_portfolios_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE acquisition_opportunities_portfolios_id_seq OWNED BY acquisition_opportunities_portfolios.id;


SET default_tablespace = rpx_user_default;

--
-- Name: acquisition_option_patents; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE acquisition_option_patents (
    acquisition_option_id integer NOT NULL,
    acquisition_patent_id integer NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"(),
    id integer NOT NULL
);


--
-- Name: acquisition_option_patents_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE acquisition_option_patents_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: acquisition_option_patents_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE acquisition_option_patents_id_seq OWNED BY acquisition_option_patents.id;


--
-- Name: acquisition_options; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE acquisition_options (
    id integer NOT NULL,
    acquisition_id integer NOT NULL,
    option_type_id integer NOT NULL,
    entity_sf_account_id character varying,
    option_count smallint,
    option_price numeric,
    effective_date date,
    expiration_date date,
    notes character varying,
    all_patents boolean,
    name character varying,
    exercised_date date,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"(),
    verified_at timestamp without time zone,
    divestiture_id integer,
    not_interested boolean DEFAULT false NOT NULL
);


SET default_tablespace = '';

--
-- Name: acquisition_options_bkup_19jan_2016; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE acquisition_options_bkup_19jan_2016 (
    id integer,
    acquisition_id integer,
    option_id integer,
    option_type_id integer,
    entity_sf_account_id character varying,
    option_count smallint,
    option_price numeric,
    effective_date date,
    expiration_date date,
    notes character varying,
    all_patents boolean,
    name character varying,
    exercised_date date,
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    created_by character varying(64),
    updated_by character varying(64),
    verified_at timestamp without time zone,
    divestiture_id integer
);


--
-- Name: acquisition_options_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE acquisition_options_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: acquisition_options_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE acquisition_options_id_seq OWNED BY acquisition_options.id;


SET default_tablespace = rpx_user_default;

--
-- Name: acquisition_patent_attributes; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE acquisition_patent_attributes (
    id integer NOT NULL,
    acquisition_patent_id integer NOT NULL,
    comments character varying(2048),
    case_type_id integer,
    subcase character varying,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


SET default_tablespace = '';

--
-- Name: acquisition_patent_attributes_dcl; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE acquisition_patent_attributes_dcl (
    id integer NOT NULL,
    acquisition_patent_id integer NOT NULL,
    acquisition_patent_attribute_id integer NOT NULL,
    comments character varying(2048),
    case_type_id integer,
    subcase character varying,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


--
-- Name: acquisition_patent_attributes_dcl_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE acquisition_patent_attributes_dcl_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: acquisition_patent_attributes_dcl_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE acquisition_patent_attributes_dcl_id_seq OWNED BY acquisition_patent_attributes_dcl.id;


--
-- Name: acquisition_patent_attributes_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE acquisition_patent_attributes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: acquisition_patent_attributes_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE acquisition_patent_attributes_id_seq OWNED BY acquisition_patent_attributes.id;


SET default_tablespace = rpx_user_default;

--
-- Name: acquisition_patents; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE acquisition_patents (
    id integer NOT NULL,
    stripped_patnum character varying(32),
    country_code character varying(8) NOT NULL,
    acquisition_id integer NOT NULL,
    portfolio_id integer,
    application_number character varying(50),
    expiration_date date,
    publication_date date,
    case_number character varying(50),
    asset_status_type_id integer,
    cpi_tracking_status_id integer NOT NULL,
    cpi_tracking_date timestamp without time zone,
    is_asset_matched boolean,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"(),
    patnum character varying(255),
    asset_source character(1) DEFAULT 'U'::bpchar NOT NULL,
    asset_source_id integer DEFAULT '-1'::integer NOT NULL,
    annuity_payment_date date,
    terminal_disclaimer boolean,
    number_of_claims integer,
    title text,
    priority_date date,
    filing_date date,
    issue_date date,
    is_application boolean,
    pat_family_id integer,
    is_dcl_populated boolean DEFAULT false,
    publication_number character varying(50),
    created_by_user_id integer,
    updated_by_user_id integer
);


SET default_tablespace = '';

--
-- Name: acquisition_patents_current_assignee_aliases; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE acquisition_patents_current_assignee_aliases (
    id integer NOT NULL,
    acquisition_patent_id integer,
    alias_id integer,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


--
-- Name: acquisition_patents_current_assignee_aliases_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE acquisition_patents_current_assignee_aliases_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: acquisition_patents_current_assignee_aliases_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE acquisition_patents_current_assignee_aliases_id_seq OWNED BY acquisition_patents_current_assignee_aliases.id;


--
-- Name: acquisition_patents_dcl; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE acquisition_patents_dcl (
    id integer NOT NULL,
    acquisition_patent_id integer,
    acquisition_id integer,
    portfolio_id integer,
    patnum character varying(255),
    stripped_patnum character varying(32),
    country_code character varying(8) NOT NULL,
    application_number character varying(50) NOT NULL,
    expiration_date date,
    publication_date date,
    publication_number character varying(50),
    case_number character varying(50),
    asset_status_type_id integer,
    cpi_tracking_status_id integer NOT NULL,
    cpi_tracking_date timestamp without time zone,
    is_asset_matched boolean,
    asset_source character(1) DEFAULT 'U'::bpchar NOT NULL,
    asset_source_id integer DEFAULT '-1'::integer NOT NULL,
    title text,
    issue_date date,
    priority_date date,
    is_application boolean,
    pat_family_id integer,
    filing_date date,
    annuity_payment_date date,
    terminal_disclaimer boolean,
    number_of_claims integer,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"(),
    created_by_user_id integer,
    updated_by_user_id integer
);


--
-- Name: acquisition_patents_dcl_current_assignee_aliases; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE acquisition_patents_dcl_current_assignee_aliases (
    id integer NOT NULL,
    acquisition_patent_dcl_id integer,
    alias_id integer,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


--
-- Name: acquisition_patents_dcl_current_assignee_aliases_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE acquisition_patents_dcl_current_assignee_aliases_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: acquisition_patents_dcl_current_assignee_aliases_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE acquisition_patents_dcl_current_assignee_aliases_id_seq OWNED BY acquisition_patents_dcl_current_assignee_aliases.id;


--
-- Name: acquisition_patents_dcl_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE acquisition_patents_dcl_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: acquisition_patents_dcl_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE acquisition_patents_dcl_id_seq OWNED BY acquisition_patents_dcl.id;


--
-- Name: acquisition_patents_dcl_rpx_ownership_rights; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE acquisition_patents_dcl_rpx_ownership_rights (
    id integer NOT NULL,
    acquisition_patents_dcl_id integer NOT NULL,
    rpx_ownership_right_id integer,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


--
-- Name: acquisition_patents_dcl_rpx_ownership_rights_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE acquisition_patents_dcl_rpx_ownership_rights_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: acquisition_patents_dcl_rpx_ownership_rights_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE acquisition_patents_dcl_rpx_ownership_rights_id_seq OWNED BY acquisition_patents_dcl_rpx_ownership_rights.id;


--
-- Name: acquisition_patents_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE acquisition_patents_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: acquisition_patents_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE acquisition_patents_id_seq OWNED BY acquisition_patents.id;


SET default_tablespace = rpx_user_default;

--
-- Name: acquisition_restriction_patents; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE acquisition_restriction_patents (
    acquisition_restriction_id integer NOT NULL,
    acquisition_patent_id integer NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"(),
    id integer NOT NULL
);


--
-- Name: acquisition_restriction_patents_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE acquisition_restriction_patents_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: acquisition_restriction_patents_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE acquisition_restriction_patents_id_seq OWNED BY acquisition_restriction_patents.id;


--
-- Name: acquisition_restrictions; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE acquisition_restrictions (
    id integer NOT NULL,
    acquisition_id integer NOT NULL,
    restriction_type_id integer NOT NULL,
    notes character varying,
    entity_sf_account_id character varying,
    start_date date,
    end_date date,
    all_patents boolean,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


--
-- Name: acquisition_restrictions_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE acquisition_restrictions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: acquisition_restrictions_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE acquisition_restrictions_id_seq OWNED BY acquisition_restrictions.id;


--
-- Name: acquisition_syndications; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE acquisition_syndications (
    id integer NOT NULL,
    acquisition_id integer NOT NULL,
    notes character varying,
    amount numeric(12,2),
    entity_sf_account_id character varying,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


--
-- Name: acquisition_syndications_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE acquisition_syndications_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: acquisition_syndications_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE acquisition_syndications_id_seq OWNED BY acquisition_syndications.id;


--
-- Name: acquisition_types; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE acquisition_types (
    id integer NOT NULL,
    name character varying(64) NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


--
-- Name: acquisition_types_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE acquisition_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: acquisition_types_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE acquisition_types_id_seq OWNED BY acquisition_types.id;


--
-- Name: acquisitions; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE acquisitions (
    id integer NOT NULL,
    acquisition_name character varying(512) NOT NULL,
    acquisition_date date,
    acquisition_type_id integer NOT NULL,
    published_at timestamp without time zone,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"(),
    legal_lead_sf_userx_id character varying(18),
    counter_party_type_id integer,
    is_published_to_portal boolean DEFAULT false,
    is_prior_encumbrances boolean DEFAULT false
);


--
-- Name: acquisitions_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE acquisitions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: acquisitions_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE acquisitions_id_seq OWNED BY acquisitions.id;


SET default_tablespace = '';

--
-- Name: adaptix_assets_dump; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE adaptix_assets_dump (
    id integer,
    family integer,
    patent_number_raw text,
    publication_number_raw text,
    application_number_raw text,
    country text,
    title text,
    application_status text,
    filed_date_actual text,
    publication_date_actual text,
    issue_date_actual text,
    current_assignee text,
    annuity_fee_status text,
    expiration_date date,
    notes text,
    type text,
    app_num_country character varying(2048),
    stripped_patnum character varying(2048),
    publication_number character varying(2048),
    filed_date date,
    publication_date date,
    issue_date date
);


SET default_tablespace = rpx_user_default;

--
-- Name: agreement_terms; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE agreement_terms (
    id integer NOT NULL,
    name character varying(64) NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


--
-- Name: agreement_terms_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE agreement_terms_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: agreement_terms_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE agreement_terms_id_seq OWNED BY agreement_terms.id;


--
-- Name: agreement_types; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE agreement_types (
    id integer NOT NULL,
    name character varying(64) NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


--
-- Name: agreement_types_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE agreement_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: agreement_types_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE agreement_types_id_seq OWNED BY agreement_types.id;


--
-- Name: asset_inventory_cpi; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE asset_inventory_cpi (
    id integer NOT NULL,
    client character varying(200),
    run_date character varying(30),
    case_number character varying(200),
    country character varying(200),
    wipo character varying(200),
    subcase character varying(200),
    client_division character varying(200),
    case_type character varying(200),
    status character varying(200),
    application_number character varying(200),
    filing_date character varying(30),
    patent_number character varying(200),
    issue_date character varying(30),
    publication_number character varying(200),
    publication_date character varying(30),
    expiration_date character varying(200),
    title text,
    db_comments character varying(20),
    db_query character varying(500),
    core_pats_id integer,
    docdb_pats_id integer,
    acquisition_id character varying(20),
    portfolio_id character varying(50),
    right_type character varying(200),
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"(),
    batch_number character varying(30),
    patnum character varying(32) DEFAULT NULL::character varying
);


--
-- Name: asset_inventory_cpi_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE asset_inventory_cpi_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: asset_inventory_cpi_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE asset_inventory_cpi_id_seq OWNED BY asset_inventory_cpi.id;


SET default_tablespace = '';

--
-- Name: asset_sources; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE asset_sources (
    id integer NOT NULL,
    asset_source_name character(1) NOT NULL,
    asset_source_description text NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


--
-- Name: asset_sources_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE asset_sources_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: asset_sources_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE asset_sources_id_seq OWNED BY asset_sources.id;


SET default_tablespace = rpx_user_default;

--
-- Name: asset_status_types; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE asset_status_types (
    id integer NOT NULL,
    name character varying(64) NOT NULL,
    description character varying(200),
    is_default boolean,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


--
-- Name: asset_status_types_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE asset_status_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: asset_status_types_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE asset_status_types_id_seq OWNED BY asset_status_types.id;


SET default_tablespace = '';

--
-- Name: batch_generated_option_ents; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE batch_generated_option_ents (
    id integer NOT NULL,
    option_id integer NOT NULL,
    bgo_type_id integer NOT NULL,
    option_price numeric,
    notification_sent_at timestamp without time zone,
    bgo_status_id integer NOT NULL,
    created_by character varying(64) DEFAULT "current_user"() NOT NULL,
    updated_by character varying(64) DEFAULT "current_user"() NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    account_id character varying(255) NOT NULL,
    expiration_date date
);


--
-- Name: batch_generated_option_ents_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE batch_generated_option_ents_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: batch_generated_option_ents_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE batch_generated_option_ents_id_seq OWNED BY batch_generated_option_ents.id;


--
-- Name: batch_generated_option_statuses; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE batch_generated_option_statuses (
    id integer NOT NULL,
    code character varying(64) NOT NULL,
    name character varying(64) NOT NULL,
    created_by character varying(64) DEFAULT "current_user"() NOT NULL,
    updated_by character varying(64) DEFAULT "current_user"() NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


--
-- Name: batch_generated_option_statuses_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE batch_generated_option_statuses_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: batch_generated_option_statuses_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE batch_generated_option_statuses_id_seq OWNED BY batch_generated_option_statuses.id;


--
-- Name: batch_generated_option_types; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE batch_generated_option_types (
    id integer NOT NULL,
    code character varying(64) NOT NULL,
    name character varying(64) NOT NULL,
    created_by character varying(64) DEFAULT "current_user"() NOT NULL,
    updated_by character varying(64) DEFAULT "current_user"() NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


--
-- Name: batch_generated_option_types_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE batch_generated_option_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: batch_generated_option_types_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE batch_generated_option_types_id_seq OWNED BY batch_generated_option_types.id;


SET default_tablespace = rpx_user_default;

--
-- Name: case_types; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE case_types (
    id integer NOT NULL,
    name character varying(64) NOT NULL,
    description character varying(200),
    is_default boolean,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


--
-- Name: case_types_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE case_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: case_types_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE case_types_id_seq OWNED BY case_types.id;


SET default_tablespace = '';

--
-- Name: counter_party_types; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE counter_party_types (
    id integer NOT NULL,
    name character varying(512) NOT NULL,
    is_default boolean DEFAULT false,
    created_by character varying(64) DEFAULT "current_user"() NOT NULL,
    updated_by character varying(64) DEFAULT "current_user"() NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


--
-- Name: counter_party_types_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE counter_party_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: counter_party_types_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE counter_party_types_id_seq OWNED BY counter_party_types.id;


--
-- Name: cpi_dump_10_14; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE cpi_dump_10_14 (
    acquisition_name text,
    acquisition_date text,
    disclosurestatus text,
    applicationstatus text,
    country text,
    invtitle text,
    patnumber text,
    appnumber text,
    fildate text,
    issdate text
);


SET default_tablespace = rpx_user_default;

--
-- Name: cpi_file_snapshot; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE cpi_file_snapshot (
    id integer NOT NULL,
    run_id integer,
    case_number character varying(50),
    subcase character varying(50),
    record_status character(1),
    publication_date date,
    filing_date date,
    issue_date date,
    expiration_date date,
    assignee text,
    patent_number character varying(32),
    country_code character varying(8),
    application_number character varying(50),
    case_type character varying(50),
    asset_status character varying(20),
    title text,
    publication_number character varying(50),
    pct_filed_date date,
    pct_number character varying(50),
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


--
-- Name: cpi_file_snapshot_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE cpi_file_snapshot_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cpi_file_snapshot_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE cpi_file_snapshot_id_seq OWNED BY cpi_file_snapshot.id;


--
-- Name: cpi_only_assets_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE cpi_only_assets_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


SET default_tablespace = '';

--
-- Name: cpi_only_assets; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE cpi_only_assets (
    id integer DEFAULT nextval('cpi_only_assets_id_seq'::regclass),
    client character varying(200),
    run_date character varying(30),
    case_number character varying(200),
    country character varying(200),
    wipo character varying(200),
    subcase character varying(200),
    client_division character varying(200),
    case_type character varying(200),
    status character varying(200),
    application_number character varying(200),
    filing_date date,
    patent_number character varying(200),
    issue_date date,
    publication_number character varying(200),
    publication_date date,
    expiration_date date,
    title text,
    db_comments character varying(20),
    db_query character varying(500),
    core_pats_id integer,
    docdb_pats_id integer,
    acquisition_id character varying(20),
    portfolio_id character varying(50),
    right_type character varying(200),
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    created_by character varying(64),
    updated_by character varying(64),
    batch_number character varying(30),
    patnum character varying(32) DEFAULT NULL::character varying
);


SET default_tablespace = rpx_user_default;

--
-- Name: cpi_tracking_status; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE cpi_tracking_status (
    id integer NOT NULL,
    name character varying,
    description character varying,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


--
-- Name: cpi_tracking_status_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE cpi_tracking_status_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cpi_tracking_status_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE cpi_tracking_status_id_seq OWNED BY cpi_tracking_status.id;


SET default_tablespace = '';

--
-- Name: divestiture_patents; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE divestiture_patents (
    id integer NOT NULL,
    acquisition_patents_dcl_id integer NOT NULL,
    divestiture_id integer NOT NULL,
    created_by character varying(64) DEFAULT "current_user"() NOT NULL,
    updated_by character varying(64) DEFAULT "current_user"() NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


--
-- Name: divestiture_patents_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE divestiture_patents_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: divestiture_patents_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE divestiture_patents_id_seq OWNED BY divestiture_patents.id;


--
-- Name: divestitures; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE divestitures (
    id integer NOT NULL,
    name character varying(512) NOT NULL,
    divestiture_date date,
    published_at timestamp without time zone,
    seller_sf_account_id character varying(64),
    counter_party_type_id integer,
    legal_lead_sf_userx_id character varying(64),
    price numeric,
    is_license_back boolean,
    is_defensive_option boolean,
    divestiture_doc text,
    notes text,
    date_offered date,
    created_by character varying(64) DEFAULT "current_user"() NOT NULL,
    updated_by character varying(64) DEFAULT "current_user"() NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


--
-- Name: divestitures_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE divestitures_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: divestitures_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE divestitures_id_seq OWNED BY divestitures.id;


--
-- Name: ds_2704_acquisition_patents_dcl; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE ds_2704_acquisition_patents_dcl (
    id integer,
    acquisition_patent_id integer,
    acquisition_id integer,
    portfolio_id integer,
    patnum character varying(255),
    stripped_patnum character varying(32),
    country_code character varying(8),
    application_number character varying(50),
    rpx_ownership_right_id integer,
    expiration_date date,
    publication_date date,
    publication_number character varying(50),
    case_number character varying(50),
    asset_status_type_id integer,
    cpi_tracking_status_id integer,
    cpi_tracking_date timestamp without time zone,
    is_asset_matched boolean,
    asset_source character(1),
    asset_source_id integer,
    title text,
    issue_date date,
    priority_date date,
    is_application boolean,
    current_assignees text,
    pat_family_id integer,
    filing_date date,
    annuity_payment_date date,
    terminal_disclaimer boolean,
    number_of_claims integer,
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    created_by character varying(64),
    updated_by character varying(64),
    created_by_user_id integer,
    updated_by_user_id integer
);


--
-- Name: ds_4112_user_notifications; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE ds_4112_user_notifications (
    id integer,
    notifiable_id integer,
    user_id integer,
    is_read boolean,
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    created_by character varying(64),
    updated_by character varying(64),
    notifiable_type character varying(255)
);


--
-- Name: ds_4264_license_date_update; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE ds_4264_license_date_update (
    member_credit_id integer,
    mc_entity_name character varying,
    mc_entity_sf_acct_type character varying,
    portfolio_name character varying,
    portfolio_acquisition_date date,
    old_license_date date,
    new_license_date date,
    review integer
);


--
-- Name: ds_4275_license_date_update; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE ds_4275_license_date_update (
    member_credit_id integer,
    mc_entity_name character varying,
    portfolio_name character varying,
    portfolio_acquisition_date date,
    old_license_date date,
    new_license_date date,
    diff integer
);


--
-- Name: ds_4457_acquisition_syndications; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE ds_4457_acquisition_syndications (
    acquisition_name character varying,
    acquisition_id integer,
    entity_name character varying,
    entity_sf_account_id character varying,
    additional_contribution character varying,
    notes character varying
);


SET default_tablespace = rpx_user_default;

--
-- Name: encumbrance_types; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE encumbrance_types (
    id integer NOT NULL,
    name character varying(64) NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


--
-- Name: encumbrance_types_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE encumbrance_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: encumbrance_types_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE encumbrance_types_id_seq OWNED BY encumbrance_types.id;


SET default_tablespace = '';

--
-- Name: exercised_batch_options; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE exercised_batch_options (
    id integer NOT NULL,
    exercised_date timestamp without time zone,
    entity_sf_account_id character varying(255),
    option_price double precision,
    option_id integer,
    notes text,
    created_at timestamp without time zone,
    updated_at timestamp without time zone
);


--
-- Name: exercised_batch_options_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE exercised_batch_options_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: exercised_batch_options_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE exercised_batch_options_id_seq OWNED BY exercised_batch_options.id;


--
-- Name: kudelski_assets_dump; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE kudelski_assets_dump (
    id integer,
    title text,
    country text,
    country_desc text,
    status text,
    filed_date_text text,
    filed_date date,
    application_number_raw text,
    grant_date_text text,
    grant_date date,
    patent_number_raw text,
    asset_source text,
    app_num_country character varying(2048),
    stripped_patnum character varying(2048)
);


--
-- Name: kudelski_assets_dump_round2; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE kudelski_assets_dump_round2 (
    id integer,
    application_number_raw text,
    patent_number_raw text,
    title text,
    country_desc text,
    country text,
    app_num_country character varying(2048),
    stripped_patnum character varying(2048)
);


--
-- Name: kudelski_temp_serial; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE kudelski_temp_serial
    START WITH 5307
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: manual_assets; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE manual_assets (
    id integer NOT NULL,
    client character varying(200),
    run_date character varying(30),
    case_number character varying(200),
    country character varying(200),
    wipo character varying(200),
    subcase character varying(200),
    client_division character varying(200),
    case_type character varying(200),
    status character varying(200),
    application_number character varying(200),
    filing_date date,
    patent_number character varying(200),
    issue_date date,
    publication_number character varying(200),
    publication_date date,
    expiration_date date,
    title text,
    db_comments character varying(20),
    db_query character varying(500),
    core_pats_id integer,
    docdb_pats_id integer,
    acquisition_id character varying(20),
    portfolio_id character varying(50),
    right_type character varying(200),
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"(),
    batch_number character varying(30),
    patnum character varying(32) DEFAULT NULL::character varying
);


--
-- Name: manual_assets_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE manual_assets_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: manual_assets_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE manual_assets_id_seq OWNED BY manual_assets.id;


--
-- Name: market_sector_portfolios_map; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE market_sector_portfolios_map (
    portfolio_id integer,
    market_sector_id integer,
    market_sector_name character varying(255),
    id integer NOT NULL
);


--
-- Name: market_sector_portfolios_map_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE market_sector_portfolios_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: market_sector_portfolios_map_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE market_sector_portfolios_map_id_seq OWNED BY market_sector_portfolios_map.id;


--
-- Name: memory_integrity_assets_dump_round; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE memory_integrity_assets_dump_round (
    id integer,
    patent_number_raw text,
    publication_number_raw text,
    application_number_raw text,
    country text,
    title text,
    asset_status text,
    filed_date date,
    publication_date date,
    issue_date date,
    expiration_date date,
    app_num_country character varying(2048),
    stripped_patnum character varying(2048)
);


--
-- Name: memory_integrity_temp_serial; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE memory_integrity_temp_serial
    START WITH 32
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: morpho_camera_assets_dump; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE morpho_camera_assets_dump (
    id integer,
    cpi_tracking_status_id integer,
    patent_number_raw text,
    publication_number_raw text,
    application_number_raw text,
    country text,
    title text,
    asset_status text,
    filed_date date,
    publication_date date,
    issue_date date,
    current_assignee text,
    annuity_fee_status text,
    expiration_date date,
    notes text,
    type text,
    app_num_country character varying(2048),
    stripped_patnum character varying(2048)
);


--
-- Name: morpho_camera_assets_dump_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE morpho_camera_assets_dump_seq
    START WITH 9
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: movi_assets_dump; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE movi_assets_dump (
    id integer,
    family integer,
    patent_number_raw text,
    publication_number_raw text,
    application_number_raw text,
    country text,
    title text,
    application_status text,
    filed_date_actual text,
    publication_date_actual text,
    issue_date_actual text,
    current_assignee text,
    annuity_fee_status text,
    expiration_date date,
    notes text,
    type text,
    upload_status text,
    app_num_country character varying(2048),
    stripped_patnum character varying(2048),
    publication_number character varying(2048),
    filed_date date,
    publication_date date,
    issue_date date
);


--
-- Name: movi_temp_serial; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE movi_temp_serial
    START WITH 13
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: northstar_assets_dump; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE northstar_assets_dump (
    id integer,
    patent_number_raw text,
    application_number_raw text,
    application_status text,
    country text,
    filed_date_actual text,
    title text,
    upload_status text,
    app_num_country character varying(2048),
    stripped_patnum character varying(2048),
    filed_date date
);


--
-- Name: northstar_temp_serial; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE northstar_temp_serial
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


SET default_tablespace = rpx_user_default;

--
-- Name: option_types; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE option_types (
    id integer NOT NULL,
    name character varying(64) NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


SET default_tablespace = '';

--
-- Name: option_types_19jan_2016; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE option_types_19jan_2016 (
    id integer,
    name character varying(64),
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    created_by character varying(64),
    updated_by character varying(64)
);


--
-- Name: option_types_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE option_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: option_types_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE option_types_id_seq OWNED BY option_types.id;


--
-- Name: options_report_download_requests; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE options_report_download_requests (
    id integer NOT NULL,
    email text NOT NULL,
    requested_at timestamp without time zone,
    report_sent boolean DEFAULT false,
    report_sent_at timestamp without time zone,
    acquisition_id integer,
    created_at timestamp without time zone,
    updated_at timestamp without time zone
);


--
-- Name: options_report_download_requests_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE options_report_download_requests_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: options_report_download_requests_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE options_report_download_requests_id_seq OWNED BY options_report_download_requests.id;


SET default_tablespace = rpx_user_default;

--
-- Name: portfolios; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE portfolios (
    id integer NOT NULL,
    acquisition_id integer NOT NULL,
    portfolio_name character varying NOT NULL,
    notes character varying NOT NULL,
    is_detected character varying NOT NULL,
    is_eou_detected character varying NOT NULL,
    is_claim_charted character varying NOT NULL,
    is_credible_seller character varying NOT NULL,
    published_at timestamp without time zone,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


SET default_tablespace = '';

--
-- Name: portfolios_ds_3109; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE portfolios_ds_3109 (
    id integer,
    acquisition_id integer,
    portfolio_name character varying,
    notes character varying,
    is_detected character varying,
    acquisition_sf_id character varying,
    is_eou_detected character varying,
    is_claim_charted character varying,
    is_credible_seller character varying,
    published_at timestamp without time zone,
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    created_by character varying(64),
    updated_by character varying(64)
);


--
-- Name: portfolios_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE portfolios_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: portfolios_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE portfolios_id_seq OWNED BY portfolios.id;


SET default_tablespace = rpx_user_default;

--
-- Name: restriction_types; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE restriction_types (
    id integer NOT NULL,
    name character varying(64) NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


--
-- Name: restriction_types_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE restriction_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: restriction_types_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE restriction_types_id_seq OWNED BY restriction_types.id;


--
-- Name: rpx_cpi_asset_tracking_log; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE rpx_cpi_asset_tracking_log (
    id integer NOT NULL,
    log_level_id integer NOT NULL,
    app_id integer,
    app_name character varying(50),
    run_id integer,
    db_user character varying(50) DEFAULT "current_user"() NOT NULL,
    client_host character varying(512) DEFAULT COALESCE(((inet_client_addr() || ':'::text) || inet_client_port()), 'LOCAL'::text) NOT NULL,
    search_path character varying(256) DEFAULT btrim((current_schemas(true))::text, '{}'::text) NOT NULL,
    message text NOT NULL,
    assets_added integer,
    assets_modified integer,
    assets_deleted integer,
    assets_matched integer,
    assets_not_matched integer,
    total_assets integer,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


--
-- Name: rpx_cpi_asset_tracking_log_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE rpx_cpi_asset_tracking_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: rpx_cpi_asset_tracking_log_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE rpx_cpi_asset_tracking_log_id_seq OWNED BY rpx_cpi_asset_tracking_log.id;


--
-- Name: rpx_ownership_rights; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE rpx_ownership_rights (
    id integer NOT NULL,
    name character varying(64) NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


--
-- Name: rpx_ownership_rights_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE rpx_ownership_rights_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: rpx_ownership_rights_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE rpx_ownership_rights_id_seq OWNED BY rpx_ownership_rights.id;


SET default_tablespace = '';

--
-- Name: selected_batch_generated_option_types; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE selected_batch_generated_option_types (
    id integer NOT NULL,
    option_id integer NOT NULL,
    batch_generated_option_type_id integer NOT NULL,
    created_by character varying(64) DEFAULT "current_user"() NOT NULL,
    updated_by character varying(64) DEFAULT "current_user"() NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


--
-- Name: selected_batch_generated_option_types_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE selected_batch_generated_option_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: selected_batch_generated_option_types_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE selected_batch_generated_option_types_id_seq OWNED BY selected_batch_generated_option_types.id;


--
-- Name: soundview_assets_dump; Type: TABLE; Schema: acquiflow; Owner: -
--

CREATE TABLE soundview_assets_dump (
    id integer,
    family integer,
    patent_number_raw text,
    publication_number_raw text,
    application_number_raw text,
    country text,
    title text,
    application_status text,
    filed_date_actual text,
    publication_date_actual text,
    issue_date_actual text,
    current_assignee text,
    annuity_fee_status text,
    expiration_date date,
    notes text,
    type text,
    upload_status text,
    app_num_country character varying(2048),
    stripped_patnum character varying(2048),
    publication_number character varying(2048),
    filed_date date,
    publication_date date,
    issue_date date
);


--
-- Name: soundview_temp_serial; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE soundview_temp_serial
    START WITH 68
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


SET default_tablespace = rpx_user_default;

--
-- Name: stage_cpi_weekly_master; Type: TABLE; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE stage_cpi_weekly_master (
    id integer NOT NULL,
    client text,
    run_date date,
    case_number character varying(50),
    country_code character varying(50),
    wipo character varying(8),
    subcase character varying(50),
    client_division character varying(200),
    case_type character varying(50),
    status character varying(50),
    application_number character varying(50),
    filing_date date,
    patent_number character varying(32),
    issue_date date,
    publication_number character varying(50),
    publication_date date,
    tax_base_date date,
    working_base_date character varying(50),
    tax_schedule character varying(50),
    paid_thru character varying(50),
    agent character varying(200),
    expiration_date date,
    attorney_inv text,
    attorney_ctry text,
    client_ref_inv text,
    client_ref_1_ctry text,
    client_ref_2_ctry text,
    priority_number character varying(50),
    assignee_inv text,
    assignee_ctry text,
    title text,
    inventor_1 text,
    inventor_2 text,
    inventor_3 text,
    inventor_4 text,
    remarks text,
    comments text,
    rate character varying(50),
    wkpd_thru character varying(50),
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(64) DEFAULT "current_user"(),
    updated_by character varying(64) DEFAULT "current_user"()
);


--
-- Name: stage_cpi_weekly_master_id_seq; Type: SEQUENCE; Schema: acquiflow; Owner: -
--

CREATE SEQUENCE stage_cpi_weekly_master_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: stage_cpi_weekly_master_id_seq; Type: SEQUENCE OWNED BY; Schema: acquiflow; Owner: -
--

ALTER SEQUENCE stage_cpi_weekly_master_id_seq OWNED BY stage_cpi_weekly_master.id;


--
-- Name: v_acquisition_asset_counts; Type: VIEW; Schema: acquiflow; Owner: -
--

CREATE VIEW v_acquisition_asset_counts AS
 SELECT t.id,
    t.acquisition_name,
    t.acquisition_date,
    t.name AS acquisition_type,
    sum((t.us * (t.is_application)::integer)) AS us_applications,
    sum((t.us * (t.is_patent)::integer)) AS us_patents,
    sum(t.us) AS us_total,
    sum((t.f * (t.is_application)::integer)) AS f_applications,
    sum((t.f * (t.is_patent)::integer)) AS f_patents,
    sum(t.f) AS f_total,
    sum((t.is_application)::integer) AS ww_applications,
    sum((t.is_patent)::integer) AS ww_patents,
    (sum(t.us) + sum(t.f)) AS ww_total
   FROM ( SELECT acq.id,
            acq.acquisition_name,
            acq.acquisition_date,
            at.name,
                CASE ap.country_code
                    WHEN 'US'::text THEN 1
                    ELSE 0
                END AS us,
                CASE ap.country_code
                    WHEN 'US'::text THEN 0
                    ELSE 1
                END AS f,
            ap.is_application,
            (NOT ap.is_application) AS is_patent
           FROM ((acquisitions acq
             JOIN acquisition_patents_dcl ap ON ((ap.acquisition_id = acq.id)))
             JOIN acquisition_types at ON ((at.id = acq.acquisition_type_id)))) t
  GROUP BY t.id, t.acquisition_name, t.acquisition_date, t.name
  ORDER BY t.acquisition_date;


--
-- Name: v_acquisition_asset_counts_at_acq; Type: VIEW; Schema: acquiflow; Owner: -
--

CREATE VIEW v_acquisition_asset_counts_at_acq AS
 SELECT t.id,
    t.acquisition_name,
    t.acquisition_date,
    t.name AS acquisition_type,
    sum((t.us * (t.was_application)::integer)) AS us_applications,
    sum((t.us * (t.was_patent)::integer)) AS us_patents,
    sum(t.us) AS us_total,
    sum((t.f * (t.was_application)::integer)) AS f_applications,
    sum((t.f * (t.was_patent)::integer)) AS f_patents,
    sum(t.f) AS f_total,
    sum((t.was_application)::integer) AS ww_applications,
    sum((t.was_patent)::integer) AS ww_patents,
    (sum(t.us) + sum(t.f)) AS ww_total
   FROM ( SELECT acq.id,
            acq.acquisition_name,
            acq.acquisition_date,
            ap.issue_date,
            (ap.is_application OR (ap.issue_date > acq.acquisition_date)) AS was_application,
            (NOT (ap.is_application OR (ap.issue_date > acq.acquisition_date))) AS was_patent,
            at.name,
                CASE ap.country_code
                    WHEN 'US'::text THEN 1
                    ELSE 0
                END AS us,
                CASE ap.country_code
                    WHEN 'US'::text THEN 0
                    ELSE 1
                END AS f,
            ap.is_application,
            (NOT ap.is_application) AS is_patent
           FROM ((acquisitions acq
             JOIN acquisition_patents_dcl ap ON ((ap.acquisition_id = acq.id)))
             JOIN acquisition_types at ON ((at.id = acq.acquisition_type_id)))) t
  GROUP BY t.id, t.acquisition_name, t.acquisition_date, t.name
  ORDER BY t.acquisition_date;


SET search_path = core, pg_catalog;

SET default_tablespace = '';

--
-- Name: aliases; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE aliases (
    id integer NOT NULL,
    name character varying(512) NOT NULL,
    lower_stripped character varying(512) NOT NULL,
    core_name character varying(512) NOT NULL,
    fingerprint character varying(512) NOT NULL,
    ent_id integer,
    is_verified boolean DEFAULT false NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    clean_name character varying(512) NOT NULL,
    created_by character varying(255),
    verified_by character varying(255),
    is_automatch_processed boolean DEFAULT false
);


--
-- Name: TABLE aliases; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE aliases IS 'Names of people and companies exactly as they appear from our various data sources.';


--
-- Name: COLUMN aliases.name; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN aliases.name IS 'Alias name exactly as it appears from PACER, USPTO, etc.';


--
-- Name: COLUMN aliases.lower_stripped; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN aliases.lower_stripped IS 'Name as seen lower cased and stripped of punctuation.';


--
-- Name: COLUMN aliases.core_name; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN aliases.core_name IS 'Name converted automatically to core form (remove Co, Inc, LLC, etc. and proper cased), for use in name disambiguation.';


--
-- Name: COLUMN aliases.fingerprint; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN aliases.fingerprint IS 'Name converted automatically to fingerprint (only alpha/numeric characters, lower cased and sorted), for use in name disambiguation.';


--
-- Name: COLUMN aliases.ent_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN aliases.ent_id IS 'Entity id (key to link to ents table)';


--
-- Name: COLUMN aliases.is_verified; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN aliases.is_verified IS 'Has the alias->ent mapping been approved by a human?';


--
-- Name: COLUMN aliases.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN aliases.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN aliases.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN aliases.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: ents; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE ents (
    id integer NOT NULL,
    ent_type_id integer NOT NULL,
    name character varying NOT NULL,
    core_name character varying(255) NOT NULL,
    fingerprint character varying(255) NOT NULL,
    lower_stripped character varying(255) NOT NULL,
    salesforce_id character varying(18),
    deactivation_date date,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    created_by character varying(255),
    updated_by character varying(255),
    rpx_account_id character varying(30),
    ultimate_parent_id integer,
    rollup_parent_id integer,
    not_for_portal boolean DEFAULT false
);


--
-- Name: COLUMN ents.id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ents.id IS 'Artificial ID';


--
-- Name: COLUMN ents.ent_type_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ents.ent_type_id IS 'Type of entity (key to link to ent_types)';


--
-- Name: COLUMN ents.name; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ents.name IS 'Entity name';


--
-- Name: COLUMN ents.core_name; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ents.core_name IS 'Name converted automatically to core form (remove Co, Inc, LLC, etc. and proper cased), for use in name disambiguation.';


--
-- Name: COLUMN ents.fingerprint; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ents.fingerprint IS 'Name converted automatically to fingerprint (only alpha/numeric characters, lower cased and sorted), for use in name disambiguation.';


--
-- Name: COLUMN ents.lower_stripped; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ents.lower_stripped IS 'Entity name lower cased and punctuation stripped';


--
-- Name: COLUMN ents.salesforce_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ents.salesforce_id IS 'Salesforce ID. This connects the entity to its Salesforce object. (ID of the form 0014000000xxxxx)';


--
-- Name: COLUMN ents.deactivation_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ents.deactivation_date IS 'Date the entity is no longer active.';


--
-- Name: COLUMN ents.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ents.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN ents.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ents.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: COLUMN ents.rpx_account_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ents.rpx_account_id IS 'Holds the RPX account id out of SalesForce. RID also matches account RID used on the client Portal.';


--
-- Name: COLUMN ents.ultimate_parent_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ents.ultimate_parent_id IS 'Calculated field, updated automatically anytime ent_relationships is updated.';


--
-- Name: COLUMN ents.rollup_parent_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ents.rollup_parent_id IS 'Automatically generated until manually changed to be different than ultimate_parent_id, then must be changed manually.';


SET default_tablespace = rpx_user_default;

--
-- Name: pat_stats_current_assignees; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_stats_current_assignees (
    id integer NOT NULL,
    pat_stats_id integer NOT NULL,
    alias_id integer NOT NULL,
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    run_id integer,
    pat_id integer
);


--
-- Name: TABLE pat_stats_current_assignees; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE pat_stats_current_assignees IS 'A list of the alias ids that are the current assignees for this patent.';


--
-- Name: pats_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pats_id_seq
    START WITH 7966777
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


SET default_tablespace = '';

--
-- Name: pats; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pats (
    id integer DEFAULT nextval('pats_id_seq'::regclass) NOT NULL,
    patnum character varying(255) NOT NULL,
    foreign_app_data character varying(2048),
    doc_kind_code character varying(2048),
    title character varying(2048) NOT NULL,
    int_cross_ref_class character varying(2048),
    fapd_doc_listing character varying(2048),
    related_app character varying(2048),
    us_class_at_publication character varying(2048),
    app_filing_date date,
    reissue_data_section_label character varying(2048),
    foreign_app_priority_data character varying(2048),
    pct_num character varying(2048),
    pct_pub_num character varying(2048),
    ipc_cross_ref_class character varying(2048),
    field_of_search character varying(4096),
    pct_pub_date date,
    cross_ref_at_publication character varying(2048),
    us_class_current character varying(2048),
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    amended_claims_pub_date date,
    app_num_country character varying(2048),
    app_num_intl character varying(2048),
    intl_class character varying(2048),
    intl_class_current character varying(2048),
    intl_class_edition character varying(2048),
    issue_date date,
    pct_102_date date,
    pct_371_date date,
    pct_filed_date date,
    publication_date date,
    publication_number character varying(255),
    lastmod character(14),
    term_extension integer DEFAULT 0,
    term_disclaimer character varying(255),
    salesforce_id character varying(18),
    stripped_patnum character varying(32),
    country_code character varying(16),
    is_application boolean DEFAULT true NOT NULL,
    earliest_filing_date date,
    term_expiratoin_date date,
    last_submission_pat_id integer DEFAULT '-1'::integer NOT NULL,
    next_submission_pat_id integer,
    orig_app_num_country character varying(32) DEFAULT 'undefined'::character varying NOT NULL,
    is_dcl_corrected boolean,
    formal_number character varying(32)
);


--
-- Name: COLUMN pats.patnum; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.patnum IS 'US + patent number + kind code';


--
-- Name: COLUMN pats.foreign_app_data; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.foreign_app_data IS 'tds:fapp
Foreign Application Data. From applications, not patents. Use FADL for document listings';


--
-- Name: COLUMN pats.doc_kind_code; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.doc_kind_code IS 'tds:pkcd
Document Kind Code – Optional on some document types, required on others, but allowed on all.';


--
-- Name: COLUMN pats.title; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.title IS 'tds:titl
Patent Title – ENGLISH';


--
-- Name: COLUMN pats.int_cross_ref_class; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.int_cross_ref_class IS 'tds:crci
International cross ref class. 0 or more entries in file. One entry per CRCI line. Same format as CLSI.';


--
-- Name: COLUMN pats.fapd_doc_listing; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.fapd_doc_listing IS 'tds:fadl
Document Listing for FAPD. Text date, or yyyymmdd, then [2 letter country code]';


--
-- Name: COLUMN pats.related_app; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.related_app IS 'tds:rela
“Related Application:” In US documents this data is often in the descriptive text and will not appear in this section.  AppNum, Date, relationship (CON, CIP, Parent, etc) may be listed on a single line entry.';


--
-- Name: COLUMN pats.us_class_at_publication; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.us_class_at_publication IS 'tds:uscp
U.S. Class at Publication: US Applications and Grants Classification at Publication time.';


--
-- Name: COLUMN pats.app_filing_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.app_filing_date IS 'tds:apdt
Appl. filing date - format YYYYMMDD" - always follows APNS, or APNO.';


--
-- Name: COLUMN pats.reissue_data_section_label; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.reissue_data_section_label IS 'tds:reis
Reissue Data Section Label';


--
-- Name: COLUMN pats.foreign_app_priority_data; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.foreign_app_priority_data IS 'tds:fapd
For US:Foreign Application Priority Data For WO/EPPriority Data. Label that Heralds FADL entries';


--
-- Name: COLUMN pats.pct_num; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.pct_num IS 'tds:pcno
PCT No.';


--
-- Name: COLUMN pats.pct_pub_num; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.pct_pub_num IS 'tds:ppnm
PCT Pub number';


--
-- Name: COLUMN pats.ipc_cross_ref_class; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.ipc_cross_ref_class IS 'tds:ccri
IPC Cross Ref classes. Same format as CCSI';


--
-- Name: COLUMN pats.field_of_search; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.field_of_search IS 'tds:foss
Field of Search: Only in EPB is electronic A3 available (scanned search reports cant be used). Field of Search - 1st class/subclass entry - omit prior to first FOS entry';


--
-- Name: COLUMN pats.pct_pub_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.pct_pub_date IS 'tds:ppdt
PCT PUB. Date: PCT Filing Date';


--
-- Name: COLUMN pats.cross_ref_at_publication; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.cross_ref_at_publication IS 'tds:uccp
Cross Ref. Classes at document publication time. One UCCP entry for each cross reference classifications assigned (e.g., 1 per line). 0 or more entries.';


--
-- Name: COLUMN pats.us_class_current; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.us_class_current IS 'tds:clsu
Current U.S. Class: US Class/Subclass';


--
-- Name: COLUMN pats.amended_claims_pub_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.amended_claims_pub_date IS 'tds:damc
Date of Publication of Amended Claims: This applies to the current document (which has the amendments)';


--
-- Name: COLUMN pats.app_num_country; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.app_num_country IS 'tds:apnc
Application number (country specific)';


--
-- Name: COLUMN pats.app_num_intl; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.app_num_intl IS 'tds:apni
Application number (international style)';


--
-- Name: COLUMN pats.intl_class; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.intl_class IS 'tds:clsi
”Intern''l Class: “Int. Cl.”  “International Class:” See: Notes on US and International Class formats at the end of this table.  (a.k.a. “IPC”). A single line of data with 2 to 4 items.';


--
-- Name: COLUMN pats.intl_class_current; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.intl_class_current IS 'tds:ccsi
Current Intern''l Class. See: Notes on US and International Class formats at the end of this table. Optionally generated from database. Date of classification (or reclassification) may also be stored on line after the class in parenthesis: B41J 002/175 (YYYYMMDD)';


--
-- Name: COLUMN pats.intl_class_edition; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.intl_class_edition IS 'tds:cice
“International Class Edition” This is an optional field and is not included on all documents. See: Notes on US and International Class formats at the end of this table.  This is an optional single digit (usually 4 through 8) that indicates what edition of the international specification the class information was produced under.';


--
-- Name: COLUMN pats.issue_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.issue_date IS 'tds:issd
“Date of Patent:” (USB) “Date of Publication and mention of the grant of patent:” (EPB) Date the patent grant was issued by the patent authority.';


--
-- Name: COLUMN pats.pct_102_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.pct_102_date IS 'tds:p102
PCT 102(e) Date';


--
-- Name: COLUMN pats.pct_371_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.pct_371_date IS 'tds:p371
PCT 371 Date';


--
-- Name: COLUMN pats.pct_filed_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.pct_filed_date IS 'tds:pcfd
PCT Filed: Filed Date';


--
-- Name: COLUMN pats.publication_number; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.publication_number IS 'publication number';


--
-- Name: COLUMN pats.lastmod; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.lastmod IS 'last modified timestamp from TDS in YYYYMMDDhhmmss GMT.';


--
-- Name: COLUMN pats.stripped_patnum; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.stripped_patnum IS 'This column contains the central piece of the patnum column, with the two digit country prefix and the kind code suffix stripped off.';


--
-- Name: COLUMN pats.country_code; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.country_code IS 'This column contains the two digit country code prefix from the patnum column.';


--
-- Name: COLUMN pats.is_application; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats.is_application IS 'This column determines whether the record represents an application or a finalized patent. If true the record is for an application, if false the record is an approved patent.';


--
-- Name: pats_aliases_map_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pats_aliases_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pats_aliases_map; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pats_aliases_map (
    pat_id integer NOT NULL,
    alias_id integer NOT NULL,
    pats_aliases_relationship_type_id integer NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    alias_contact_id integer,
    id integer DEFAULT nextval('pats_aliases_map_id_seq'::regclass) NOT NULL,
    is_verified boolean DEFAULT false NOT NULL,
    verified_by character varying(255),
    notes text
);


--
-- Name: COLUMN pats_aliases_map.is_verified; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats_aliases_map.is_verified IS 'has the alias->pat mapping been approved by a human?';


--
-- Name: pats_aliases_relationship_types; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pats_aliases_relationship_types (
    id integer NOT NULL,
    name character varying(255) NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    is_default boolean DEFAULT false NOT NULL
);


--
-- Name: TABLE pats_aliases_relationship_types; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE pats_aliases_relationship_types IS 'inventor, examinor, assistant examinor, lawyer, ...';


--
-- Name: COLUMN pats_aliases_relationship_types.name; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats_aliases_relationship_types.name IS 'rpx=# select count(id), party_type, app_type from parties group by 2,3 order by 1 desc;
  count  |     party_type     |      app_type
---------+--------------------+--------------------
 3234036 | applicant          | applicant-inventor
 2090607 | agent              |
 1706880 | assignee           |
 1297892 | primary_examiner   |
 1282899 | inventor           |
  542185 | primary-examiner   |
  505915 | assistant_examiner |
  231045 | assistant-examiner |
    3071 | applicant          | applicant';


--
-- Name: COLUMN pats_aliases_relationship_types.is_default; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats_aliases_relationship_types.is_default IS 'When TRUE, the value is the one that should be used for any new record where the value is not known. There should only be one TRUE record in the table.';


SET search_path = docdb, pg_catalog;

--
-- Name: docdb_inventors_id_seq; Type: SEQUENCE; Schema: docdb; Owner: -
--

CREATE SEQUENCE docdb_inventors_id_seq
    START WITH 90000000000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


SET default_tablespace = rpx_user_default;

--
-- Name: docdb_inventors; Type: TABLE; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE docdb_inventors (
    id bigint DEFAULT nextval('docdb_inventors_id_seq'::regclass) NOT NULL,
    pat_id bigint NOT NULL,
    inventor_name character varying(2048) NOT NULL,
    sequence character varying(255),
    data_format character varying(255),
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    designation character varying(255),
    status character varying(255),
    address character varying(255),
    residence character varying(255),
    designated_states character varying(255),
    deceased_inventor character varying(255),
    batch_id integer,
    run_id integer
);


--
-- Name: docdb_pats_id_seq; Type: SEQUENCE; Schema: docdb; Owner: -
--

CREATE SEQUENCE docdb_pats_id_seq
    START WITH 900000000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: docdb_pats; Type: TABLE; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE docdb_pats (
    id integer DEFAULT nextval('docdb_pats_id_seq'::regclass) NOT NULL,
    patnum character varying(255),
    is_representative character varying(10),
    originating_office character varying(25),
    status character varying(25),
    filedate character varying,
    title text,
    title_lang character varying(255),
    family_id integer,
    stripped_patnum character varying(255),
    extended_kind_code character varying(255),
    app_num_intl character varying(25),
    app_num_country character varying(25),
    lang_of_publication character varying(25),
    lang_of_filing character varying(25),
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    doc_kind_code character varying(10),
    publication_number character varying(255),
    app_is_representative character varying(255),
    app_kind_code character varying(255),
    date_of_coming_into_force character varying(255),
    previously_filed_app character varying(255),
    country_code character varying(255),
    public_availability_category character varying(255),
    batch_id integer,
    run_id integer,
    publication_date_history character varying(255) DEFAULT ''::character varying,
    issue_date date,
    app_date date,
    date_of_last_exchange date,
    date_of_previous_exchange date,
    publication_date date,
    date_added_docdb date,
    preceding_publication_date date,
    public_availability_date date,
    doc_number character varying(255),
    pat_family_processed boolean
);


SET search_path = acquiflow, pg_catalog;

--
-- Name: v_acquisition_assets; Type: VIEW; Schema: acquiflow; Owner: -
--

CREATE VIEW v_acquisition_assets AS
 SELECT DISTINCT ma.id AS asset_id,
    ma.publication_date,
    ma.title,
    COALESCE(ma.patnum, (((ma.country)::text || (ma.patent_number)::text))::character varying) AS patnum,
    ma.patent_number AS stripped_patnum,
    ma.country AS country_code,
    ma.application_number,
    ma.issue_date,
    ma.expiration_date,
    NULL::date AS priority_date,
        CASE
            WHEN (ma.issue_date IS NOT NULL) THEN 'N'::text
            ELSE 'Y'::text
        END AS is_application,
    NULL::character varying[] AS inventors,
    ma.filing_date,
    'M'::text AS record_source,
    ma.publication_number,
    NULL::character varying[] AS current_assignees,
    NULL::integer AS pat_family_id
   FROM manual_assets ma
UNION ALL
 SELECT p.asset_id,
    p.publication_date,
    p.title,
    (p.patnum)::character varying AS patnum,
    p.stripped_patnum,
    p.country_code,
    p.application_number,
    p.issue_date,
    ps.expiration_date,
    ps.priority_date,
        CASE
            WHEN (p.issue_date IS NOT NULL) THEN 'N'::text
            ELSE 'Y'::text
        END AS is_application,
    p.inventors,
    p.filing_date,
    p.record_source,
    p.publication_number,
    p.current_assignees,
    p.pat_family_id
   FROM (( SELECT p_1.id AS asset_id,
            p_1.publication_date,
            p_1.title,
            (p_1.patnum)::text AS patnum,
            p_1.stripped_patnum,
            p_1.country_code,
            p_1.app_num_intl AS application_number,
            p_1.issue_date,
            p_1.app_date AS filing_date,
            ( SELECT array_agg(i.inventor_name) AS array_agg
                   FROM docdb.docdb_inventors i
                  WHERE ((i.pat_id = p_1.id) AND ((i.data_format)::text = 'docdb'::text))) AS inventors,
            'D'::text AS record_source,
            p_1.publication_number,
            NULL::character varying[] AS current_assignees,
            ( SELECT pmp.pat_family_id
                   FROM docdb_families.pat_family_pats pmp
                  WHERE (((pmp.patnum)::text = (p_1.patnum)::text) AND ((pmp.country_code)::text = (p_1.country_code)::text))
                 LIMIT 1) AS pat_family_id
           FROM docdb.docdb_pats p_1
          WHERE (((p_1.country_code)::text <> 'US'::text) AND (COALESCE(p_1.app_date, '2100-01-01'::date) > '1976-01-01'::date) AND (NOT (EXISTS ( SELECT 1
                   FROM manual_assets ma
                  WHERE (((p_1.stripped_patnum)::text = (ma.patent_number)::text) AND ((p_1.country_code)::text = (ma.wipo)::text) AND ((ma.wipo)::text <> 'US'::text))))))
        UNION ALL
         SELECT cp.id AS asset_id,
            COALESCE(cp.publication_date, ( SELECT max(pats_pub.publication_date) AS max
                   FROM core.pats pats_pub
                  WHERE (((pats_pub.app_num_country)::text = (cp.app_num_country)::text) AND (pats_pub.issue_date IS NULL) AND (pats_pub.publication_date IS NOT NULL))
                 LIMIT 1)) AS publication_date,
            cp.title,
            (cp.patnum)::text AS patnum,
            cp.stripped_patnum,
            cp.country_code,
            cp.app_num_country AS application_number,
            cp.issue_date,
            cp.app_filing_date AS filing_date,
            ( SELECT array_agg(a.name) AS array_agg
                   FROM core.aliases a,
                    core.pats_aliases_map m,
                    core.pats_aliases_relationship_types t
                  WHERE ((m.pat_id = cp.id) AND (m.alias_id = a.id) AND (m.pats_aliases_relationship_type_id = t.id) AND ((t.name)::text = 'Inventor'::text))) AS inventors,
            'C'::text AS record_source,
            COALESCE(cp.publication_number, (( SELECT max((pats_pub.publication_number)::text) AS max
                   FROM core.pats pats_pub
                  WHERE (((pats_pub.app_num_country)::text = (cp.app_num_country)::text) AND (pats_pub.issue_date IS NULL) AND (pats_pub.publication_date IS NOT NULL))
                 LIMIT 1))::character varying) AS publication_number,
            ( SELECT array_agg(DISTINCT COALESCE(assignee_ents.name, assignee_alias.name)) AS array_agg
                   FROM (((core.pat_stats ps_1
                     LEFT JOIN core.pat_stats_current_assignees psca ON ((psca.pat_stats_id = ps_1.id)))
                     LEFT JOIN core.aliases assignee_alias ON ((assignee_alias.id = psca.alias_id)))
                     LEFT JOIN core.ents assignee_ents ON ((assignee_ents.id = assignee_alias.ent_id)))
                  WHERE (((cp.stripped_patnum)::text = (ps_1.stripped_patnum)::text) AND ((cp.country_code)::text = (ps_1.country_code)::text))) AS current_assignees,
            ( SELECT pmp.pat_family_id
                   FROM docdb_families.pat_family_pats pmp
                  WHERE (((pmp.stripped_patnum)::text = (cp.stripped_patnum)::text) AND ((pmp.country_code)::text = (cp.country_code)::text))
                 LIMIT 1) AS pat_family_id
           FROM core.pats cp
          WHERE (COALESCE(cp.app_filing_date, '2100-01-01'::date) > '1976-01-01'::date)) p
     LEFT JOIN core.pat_stats ps ON ((((p.stripped_patnum)::text = (ps.stripped_patnum)::text) AND ((p.country_code)::text = (ps.country_code)::text))));


--
-- Name: v_acquisition_details; Type: VIEW; Schema: acquiflow; Owner: -
--

CREATE VIEW v_acquisition_details AS
 SELECT acq.id AS acquisition_id,
    acq.acquisition_name,
    acq.acquisition_date,
    ( SELECT array_agg(port.portfolio_name) AS array_agg
           FROM ( SELECT port_1.portfolio_name
                   FROM portfolios port_1
                  WHERE (port_1.acquisition_id = acq.id)
                  ORDER BY port_1.portfolio_name) port) AS portfolios,
    ( SELECT array_agg(port.portfolio_name) AS array_agg
           FROM ( SELECT port_1.portfolio_name
                   FROM portfolios port_1
                  WHERE ((port_1.acquisition_id = acq.id) AND (port_1.published_at IS NOT NULL))
                  ORDER BY port_1.portfolio_name) port) AS published_portfolios,
        CASE
            WHEN (acq.published_at IS NULL) THEN 'N'::text
            ELSE 'Y'::text
        END AS acquisition_published,
        CASE
            WHEN ((COALESCE(( SELECT count(*) AS count
               FROM acquisitions acq1
              WHERE ((acq1.id = acq.id) AND (NOT (EXISTS ( SELECT 1
                       FROM portfolios p
                      WHERE ((p.acquisition_id = acq1.id) AND (p.published_at IS NULL))))) AND (EXISTS ( SELECT 1
                       FROM portfolios p
                      WHERE (p.acquisition_id = acq1.id))))), (0)::bigint))::integer = 0) THEN 'N'::text
            ELSE 'Y'::text
        END AS all_portfolios_published,
        CASE
            WHEN acq.is_published_to_portal THEN 'Y'::text
            ELSE 'N'::text
        END AS acquisition_published_to_rpx_portal,
        CASE
            WHEN ((COALESCE(( SELECT count(*) AS count
               FROM acquisitions acq1
              WHERE ((acq1.id = acq.id) AND (acq1.published_at IS NOT NULL) AND acq1.is_published_to_portal AND (NOT (EXISTS ( SELECT 1
                       FROM portfolios p
                      WHERE ((p.acquisition_id = acq1.id) AND (p.published_at IS NULL))))) AND (EXISTS ( SELECT 1
                       FROM portfolios p
                      WHERE (p.acquisition_id = acq1.id))))), (0)::bigint))::integer = 0) THEN 'N'::text
            ELSE 'Y'::text
        END AS visible_on_rpx_portal
   FROM acquisitions acq;


SET search_path = core, pg_catalog;

--
-- Name: ent_subtypes_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ent_subtypes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ent_subtypes; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE ent_subtypes (
    id integer DEFAULT nextval('ent_subtypes_id_seq'::regclass) NOT NULL,
    name character varying(100) NOT NULL,
    description text,
    updated_at timestamp(6) without time zone NOT NULL,
    created_at timestamp(6) without time zone NOT NULL
);


--
-- Name: ent_subtypes_map_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ent_subtypes_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ent_subtypes_map; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE ent_subtypes_map (
    id integer DEFAULT nextval('ent_subtypes_map_id_seq'::regclass) NOT NULL,
    ent_id integer NOT NULL,
    ent_subtype_id integer NOT NULL,
    start_date date,
    end_date date,
    updated_at timestamp(6) without time zone NOT NULL,
    created_at timestamp(6) without time zone NOT NULL,
    updated_by character varying(255) NOT NULL,
    created_by character varying(255) NOT NULL
);


SET default_tablespace = '';

--
-- Name: ent_types; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE ent_types (
    id integer NOT NULL,
    name character varying(255) NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    is_default boolean DEFAULT false NOT NULL
);


--
-- Name: TABLE ent_types; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE ent_types IS 'List of types for entities';


--
-- Name: COLUMN ent_types.name; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ent_types.name IS 'Entity types (Company, Person, Government, etc.)';


--
-- Name: COLUMN ent_types.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ent_types.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN ent_types.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ent_types.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: COLUMN ent_types.is_default; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ent_types.is_default IS 'When TRUE, the value is the one that should be used for any new record where the value is not known. There should only be one TRUE record in the table.';


--
-- Name: lit_annotations_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_annotations_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_annotations; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lit_annotations (
    lit_id integer NOT NULL,
    rpx_lit_id character varying(16),
    lit_type_id integer,
    is_npe_suit boolean DEFAULT false NOT NULL,
    is_dj boolean NOT NULL,
    market_sector_type_id integer,
    lit_classification_type_id integer,
    lit_stage_id integer NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone DEFAULT (now())::timestamp without time zone NOT NULL,
    is_abandon boolean DEFAULT false NOT NULL,
    ad_hoc_1 text,
    ad_hoc_2 text,
    ad_hoc_3 text,
    ad_hoc_4 text,
    ad_hoc_5 text,
    lit_curated_cause_type_id integer,
    id integer DEFAULT nextval('lit_annotations_id_seq'::regclass) NOT NULL,
    is_ncl_suit boolean DEFAULT false NOT NULL,
    is_dcl_corrected boolean,
    display_on_portal boolean,
    portal_display_override boolean,
    latest_document_id integer
);


--
-- Name: TABLE lit_annotations; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE lit_annotations IS 'Human created annotations for litigations (data01: rpx_casedata)';


--
-- Name: COLUMN lit_annotations.lit_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_annotations.lit_id IS 'Litigation ID (key connects to lits)';


--
-- Name: COLUMN lit_annotations.rpx_lit_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_annotations.rpx_lit_id IS 'RPX Lit ID (RLD-000000) - alternate unique identifier. (data01: rpx_casedata.rpxlitid)';


--
-- Name: COLUMN lit_annotations.lit_type_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_annotations.lit_type_id IS 'Lit type ID (key connects to lit_types) (data01: rpx_casedata.case_type)';


--
-- Name: COLUMN lit_annotations.is_npe_suit; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_annotations.is_npe_suit IS '0==false, 1==true (data01: rpx_casedata.npesuitflag)';


--
-- Name: COLUMN lit_annotations.is_dj; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_annotations.is_dj IS 'Is the case requesting declaratory judgment? (data01: rpx_casedata.isdj)';


--
-- Name: COLUMN lit_annotations.market_sector_type_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_annotations.market_sector_type_id IS 'Market sector code (1-18; key connects to market_sector_types) (data01: rpx_casedata.marketsector)';


--
-- Name: COLUMN lit_annotations.lit_classification_type_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_annotations.lit_classification_type_id IS 'Lit classification type ID (key connects to lit_classification_types)
(data01: rpx_casedata.case_classification)';


--
-- Name: COLUMN lit_annotations.lit_stage_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_annotations.lit_stage_id IS 'Lit stage ID (key connects to lit_stage) (data01: rpx_stagereached_case.case_stagereached)';


--
-- Name: COLUMN lit_annotations.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_annotations.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN lit_annotations.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_annotations.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: COLUMN lit_annotations.is_abandon; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_annotations.is_abandon IS 'True if case was abandoned by the court.  Some cases are abandoned (not closed, but never updated) at the ECF level. (data01: rpx_casedata.transferflag = ''A'')';


--
-- Name: COLUMN lit_annotations.ad_hoc_1; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_annotations.ad_hoc_1 IS 'place for data services people to put their own special stuff';


--
-- Name: COLUMN lit_annotations.ad_hoc_2; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_annotations.ad_hoc_2 IS 'place for data services people to put their own special stuff';


--
-- Name: COLUMN lit_annotations.ad_hoc_3; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_annotations.ad_hoc_3 IS 'place for data services people to put their own special stuff';


--
-- Name: COLUMN lit_annotations.ad_hoc_4; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_annotations.ad_hoc_4 IS 'place for data services people to put their own special stuff';


--
-- Name: COLUMN lit_annotations.ad_hoc_5; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_annotations.ad_hoc_5 IS 'place for data services people to put their own special stuff';


--
-- Name: COLUMN lit_annotations.lit_curated_cause_type_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_annotations.lit_curated_cause_type_id IS 'Litigation cause, human currated';


--
-- Name: lit_parties; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lit_parties (
    id integer NOT NULL,
    alias_id integer NOT NULL,
    lit_party_type_id integer NOT NULL,
    lit_id integer NOT NULL,
    alias_contact_id integer,
    lit_party_practice_type_id integer DEFAULT 0 NOT NULL,
    start_date date,
    end_date date,
    is_verified boolean DEFAULT false NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    is_removed_from_pacer boolean DEFAULT false,
    verified_by character varying(255),
    salesforce_id character varying(18),
    missing_from_source_date date,
    dj_party_normalized_type character varying(255),
    is_dcl_corrected boolean,
    campaign_party_normalized_type character varying(255)
);


--
-- Name: TABLE lit_parties; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE lit_parties IS 'Litigation parties (plaintiffs, defendants, ...) (docketx: representedparty and representation)';


--
-- Name: COLUMN lit_parties.id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties.id IS 'Lit parties ID (key connects to lit_parties_representations)';


--
-- Name: COLUMN lit_parties.alias_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties.alias_id IS 'Alias ID (key connects to aliases)';


--
-- Name: COLUMN lit_parties.lit_party_type_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties.lit_party_type_id IS 'Lit party type ID (key connects to lit_party_types)';


--
-- Name: COLUMN lit_parties.lit_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties.lit_id IS 'Litigation ID (key connects to lits)';


--
-- Name: COLUMN lit_parties.alias_contact_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties.alias_contact_id IS 'Entity-Address ID (key connects to alias_contacts)';


--
-- Name: COLUMN lit_parties.lit_party_practice_type_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties.lit_party_practice_type_id IS 'Lit party practice type ID (key connects to lit_party_practice_types)
Defaults to 0 - Unknown';


--
-- Name: COLUMN lit_parties.start_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties.start_date IS 'Start date of party tenure';


--
-- Name: COLUMN lit_parties.end_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties.end_date IS 'End date of party tenure (docketx: representation.litigantterminatedate)';


--
-- Name: COLUMN lit_parties.is_verified; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties.is_verified IS 'has the lit_party -> alias->ent mapping been approved by a human?';


--
-- Name: COLUMN lit_parties.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN lit_parties.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: pat_claims_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_claims_id_seq
    START WITH 131687726
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_claims; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pat_claims (
    id integer DEFAULT nextval('pat_claims_id_seq'::regclass) NOT NULL,
    pat_id integer NOT NULL,
    claim_num character varying(20) NOT NULL,
    claim_text text,
    lang character varying(2),
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    word_count integer
);


--
-- Name: TABLE pat_claims; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE pat_claims IS 'tds:clms';


--
-- Name: COLUMN pat_claims.claim_num; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_claims.claim_num IS 'tds:claim_num
Claim number';


--
-- Name: COLUMN pat_claims.claim_text; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_claims.claim_text IS 'tds:ctxt
Claim paragraph';


SET search_path = acquiflow, pg_catalog;

--
-- Name: v_batch_generated_option_details; Type: VIEW; Schema: acquiflow; Owner: -
--

CREATE VIEW v_batch_generated_option_details AS
 WITH option_pats AS (
         SELECT ao.acquisition_id,
            ao.id AS option_id,
            ap.stripped_patnum,
            ap.country_code,
            ap.portfolio_id
           FROM ((acquisition_options ao
             JOIN acquisition_option_patents aop ON ((ao.id = aop.acquisition_option_id)))
             JOIN acquisition_patents_dcl ap ON (((ap.acquisition_patent_id = aop.acquisition_patent_id) AND (ap.portfolio_id IS NOT NULL))))
          WHERE ((COALESCE(ao.all_patents, false) = false) AND (ao.id IN ( SELECT batch_generated_option_ents.option_id
                   FROM batch_generated_option_ents)))
        UNION ALL
         SELECT ao.acquisition_id,
            ao.id AS option_id,
            ap.stripped_patnum,
            ap.country_code,
            ap.portfolio_id
           FROM (acquisition_options ao
             JOIN acquisition_patents_dcl ap ON (((ap.acquisition_id = ao.acquisition_id) AND (ap.portfolio_id IS NOT NULL))))
          WHERE ((ao.all_patents = true) AND (ao.id IN ( SELECT batch_generated_option_ents.option_id
                   FROM batch_generated_option_ents)))
        ), sf_filtered_pats AS (
         WITH oma_pats AS (
                 SELECT op.acquisition_id,
                    op.option_id,
                    oma_pat.stripped_patnum__c AS stripped_patnum,
                    pats.country_code,
                    NULL::integer AS lit_id
                   FROM ((((option_pats op
                     JOIN acquisition_opportunities_portfolios aop ON ((op.portfolio_id = aop.portfolio_id)))
                     JOIN sf.acquisition_opportunity__c ao ON ((((ao.id)::text = (aop.acquisition_sf_id)::text) AND ((ao.isdeleted)::text = 'false'::text))))
                     JOIN core.pats ON ((((pats.stripped_patnum)::text = (op.stripped_patnum)::text) AND ((pats.country_code)::text = (op.country_code)::text))))
                     JOIN sf.oma_patent__c oma_pat ON ((((ao.id)::text = (oma_pat.acquisition_opportunity__c)::text) AND (ao.record_type_text__c = 'OMA'::text) AND ((oma_pat.isdeleted)::text = 'false'::text) AND ((oma_pat.patentnumber__c)::text = (pats.patnum)::text))))
                  GROUP BY op.acquisition_id, op.option_id, oma_pat.stripped_patnum__c, pats.country_code, NULL::integer
                ), lit_pats AS (
                 SELECT op.acquisition_id,
                    op.option_id,
                    lpm.patnum AS stripped_patnum,
                    'US'::character varying AS country_code,
                    lpm.lit_id
                   FROM (option_pats op
                     JOIN core.lits_pats_map lpm ON ((((op.stripped_patnum)::text = (lpm.patnum)::text) AND ((op.country_code)::text = 'US'::text))))
                  GROUP BY op.acquisition_id, op.option_id, lpm.patnum, 'US'::character varying, lpm.lit_id
                )
         SELECT oma_pats.acquisition_id,
            oma_pats.option_id,
            oma_pats.stripped_patnum,
            oma_pats.country_code,
            oma_pats.lit_id
           FROM oma_pats
        UNION
         SELECT lit_pats.acquisition_id,
            lit_pats.option_id,
            lit_pats.stripped_patnum,
            lit_pats.country_code,
            lit_pats.lit_id
           FROM lit_pats
        ), all_defendants AS (
         SELECT sfp.acquisition_id,
            sfp.option_id,
            ult_ents.salesforce_id,
            ult_ents.id AS ultimate_parent_entity_id,
            ult_ents.name AS ultimate_parent_entity_name,
            ents.id AS entity_id,
            ents.name AS entity_name,
            al.id AS alias_id,
            al.name AS alias_name,
            ult_ents_accx.typex AS account_type,
            ult_ents_accx.isdeleted AS bgo_account_is_deleted,
            et.name AS ent_type,
            es.name AS ent_sub_type,
            esm.start_date AS ent_sub_type_start_date,
            esm.end_date AS ent_sub_type_end_date,
            lits.id AS case_id,
            lits.case_key,
            lits.title AS case_title,
            lits.filed_date AS case_filed_date,
            lits.closed_date AS case_closed_date,
            lits.is_open AS case_is_open,
            la.is_abandon AS case_is_abandon,
            min(
                CASE
                    WHEN ((lp.start_date IS NULL) OR (lp.start_date > lp.end_date)) THEN lits.filed_date
                    ELSE lp.start_date
                END) AS lit_party_start_date,
            NULLIF(max(COALESCE(lp.end_date, lits.closed_date, '9999-12-31'::date)), '9999-12-31'::date) AS lit_party_end_date
           FROM ((((((((((sf_filtered_pats sfp
             JOIN core.lits lits ON ((sfp.lit_id = lits.id)))
             JOIN core.lit_parties lp ON (((lp.lit_id = lits.id) AND ((lp.dj_party_normalized_type)::text = 'defendant'::text) AND (lp.missing_from_source_date IS NULL))))
             JOIN core.lit_annotations la ON ((lits.id = la.lit_id)))
             JOIN core.aliases al ON ((lp.alias_id = al.id)))
             JOIN core.ents ents ON ((al.ent_id = ents.id)))
             JOIN core.ents ult_ents ON ((ents.ultimate_parent_id = ult_ents.id)))
             JOIN core.ent_types et ON ((ult_ents.ent_type_id = et.id)))
             JOIN sf.accountx ult_ents_accx ON (((ult_ents_accx.id)::text = (ult_ents.salesforce_id)::text)))
             LEFT JOIN core.ent_subtypes_map esm ON ((esm.ent_id = ult_ents.id)))
             LEFT JOIN core.ent_subtypes es ON ((es.id = esm.ent_subtype_id)))
          GROUP BY sfp.acquisition_id, sfp.option_id, ult_ents.salesforce_id, ult_ents.id, ult_ents.name, ents.id, ents.name, al.id, al.name, ult_ents_accx.typex, ult_ents_accx.isdeleted, et.name, es.name, esm.start_date, esm.end_date, lits.id, lits.case_key, lits.title, lits.filed_date, lits.closed_date, lits.is_open, la.is_abandon
        ), prcs AS (
         SELECT sfp.acquisition_id,
            sfp.option_id,
            ult_ents.salesforce_id,
            ult_ents.id AS ultimate_parent_entity_id,
            ult_ents.name AS ultimate_parent_entity_name,
            ents.id AS entity_id,
            ents.name AS entity_name,
            NULL::integer AS alias_id,
            NULL::character varying AS alias_name,
            ult_ents_accx.typex AS account_type,
            ult_ents_accx.isdeleted AS bgo_account_is_deleted,
            et.name AS ent_type,
            es.name AS ent_sub_type,
            esm.start_date AS ent_sub_type_start_date,
            esm.end_date AS ent_sub_type_end_date,
            NULL::integer AS case_id,
            NULL::character varying AS case_key,
            NULL::text AS case_title,
            NULL::date AS case_filed_date,
            NULL::date AS case_closed_date,
            NULL::boolean AS case_is_open,
            NULL::boolean AS case_is_abandon,
            NULL::date AS lit_party_start_date,
            NULL::date AS lit_party_end_date,
            array_agg(DISTINCT pats.patnum) AS prc_patents
           FROM (((((((((sf_filtered_pats sfp
             JOIN core.pats pats ON ((((pats.stripped_patnum)::text = (sfp.stripped_patnum)::text) AND ((pats.country_code)::text = (sfp.country_code)::text))))
             JOIN core.pat_claims pc ON ((pc.pat_id = pats.id)))
             JOIN pa_web.analysis_techtagannotation att ON ((att.claim_id = pc.id)))
             JOIN core.ents ents ON ((att.potentially_relevant_company_id = ents.id)))
             JOIN core.ents ult_ents ON ((ents.ultimate_parent_id = ult_ents.id)))
             JOIN core.ent_types et ON ((ult_ents.ent_type_id = et.id)))
             JOIN sf.accountx ult_ents_accx ON (((ult_ents_accx.id)::text = (ult_ents.salesforce_id)::text)))
             LEFT JOIN core.ent_subtypes_map esm ON ((esm.ent_id = ult_ents.id)))
             LEFT JOIN core.ent_subtypes es ON ((es.id = esm.ent_subtype_id)))
          GROUP BY sfp.acquisition_id, sfp.option_id, ult_ents.salesforce_id, ult_ents.id, ult_ents.name, ents.id, ents.name, NULL::integer, NULL::character varying, ult_ents_accx.typex, ult_ents_accx.isdeleted, et.name, es.name, esm.start_date, esm.end_date, NULL::integer, NULL::character varying, NULL::text, NULL::date, NULL::date, NULL::boolean, NULL::boolean, NULL::date, NULL::date
        ), current_bgo_data AS (
         SELECT all_defendants.acquisition_id,
            all_defendants.option_id,
            all_defendants.salesforce_id,
            all_defendants.ultimate_parent_entity_id,
            all_defendants.ultimate_parent_entity_name,
            all_defendants.entity_id,
            all_defendants.entity_name,
            all_defendants.alias_id,
            all_defendants.alias_name,
            all_defendants.account_type,
            all_defendants.bgo_account_is_deleted,
            all_defendants.ent_type,
            all_defendants.ent_sub_type,
            all_defendants.ent_sub_type_start_date,
            all_defendants.ent_sub_type_end_date,
            all_defendants.case_id,
            all_defendants.case_key,
            all_defendants.case_title,
            all_defendants.case_filed_date,
            all_defendants.case_closed_date,
            all_defendants.case_is_open,
            all_defendants.case_is_abandon,
            all_defendants.lit_party_start_date,
            all_defendants.lit_party_end_date,
            NULL::character varying[] AS prc_patents
           FROM all_defendants
        UNION
         SELECT prcs.acquisition_id,
            prcs.option_id,
            prcs.salesforce_id,
            prcs.ultimate_parent_entity_id,
            prcs.ultimate_parent_entity_name,
            prcs.entity_id,
            prcs.entity_name,
            prcs.alias_id,
            prcs.alias_name,
            prcs.account_type,
            prcs.bgo_account_is_deleted,
            prcs.ent_type,
            prcs.ent_sub_type,
            prcs.ent_sub_type_start_date,
            prcs.ent_sub_type_end_date,
            prcs.case_id,
            prcs.case_key,
            prcs.case_title,
            prcs.case_filed_date,
            prcs.case_closed_date,
            prcs.case_is_open,
            prcs.case_is_abandon,
            prcs.lit_party_start_date,
            prcs.lit_party_end_date,
            prcs.prc_patents
           FROM prcs
        ), existing_bgo_data AS (
         SELECT acq.id AS acquisition_id,
            acq.acquisition_name,
            acq.acquisition_date,
            bgoe.id AS bgo_option_id,
            ents.name AS bgo_entity_name,
            bgoe.account_id AS bgo_account_id,
            ao.id AS parent_option_id,
            ao.name AS parent_option_name,
            ao.all_patents AS parent_option_all_patents_flag,
            bgot.name AS bgo_type_name,
            bgoe.option_price AS bgo_option_price,
            bgoe.expiration_date AS bgo_expiration_date,
            bgos.name AS bgo_status
           FROM ((((((acquisitions acq
             JOIN acquisition_options ao ON ((acq.id = ao.acquisition_id)))
             JOIN option_types ot ON ((ao.option_type_id = ot.id)))
             JOIN batch_generated_option_ents bgoe ON ((ao.id = bgoe.option_id)))
             JOIN core.ents ents ON (((bgoe.account_id)::text = (ents.salesforce_id)::text)))
             JOIN batch_generated_option_types bgot ON ((bgoe.bgo_type_id = bgot.id)))
             JOIN batch_generated_option_statuses bgos ON ((bgoe.bgo_status_id = bgos.id)))
        )
 SELECT ebd.acquisition_id,
    ebd.acquisition_name,
    ebd.acquisition_date,
    ebd.bgo_option_id,
    ebd.bgo_entity_name,
    ebd.bgo_account_id,
    cbd.account_type,
    cbd.alias_id,
    cbd.alias_name,
    cbd.entity_id,
    cbd.entity_name,
    cbd.ultimate_parent_entity_id,
    cbd.ultimate_parent_entity_name,
    ebd.parent_option_id,
    ebd.parent_option_name,
    ebd.parent_option_all_patents_flag,
    ebd.bgo_type_name,
    ebd.bgo_option_price,
    ebd.bgo_expiration_date,
    ebd.bgo_status,
    cbd.case_id,
    cbd.case_key,
    cbd.case_title,
    cbd.case_filed_date,
    cbd.case_closed_date,
    cbd.case_is_open,
    cbd.case_is_abandon,
    cbd.lit_party_start_date,
    cbd.lit_party_end_date,
        CASE
            WHEN (cbd.prc_patents IS NOT NULL) THEN 'PRC'::text
            ELSE
            CASE
                WHEN (cbd.lit_party_start_date <= ebd.acquisition_date) THEN
                CASE
                    WHEN ((cbd.lit_party_end_date IS NULL) AND (cbd.case_is_abandon = false) AND ((cbd.account_type)::text <> ALL ((ARRAY['Member Subsidiary'::character varying, 'Insurance Member'::character varying, 'Member'::character varying])::text[])) AND ((cbd.bgo_account_is_deleted)::text <> 'true'::text) AND ((cbd.ent_type)::text <> ALL ((ARRAY['Individual'::character varying, 'Government'::character varying, 'John Doe'::character varying])::text[])) AND (NOT (((COALESCE(cbd.ent_sub_type, 'N/A'::character varying))::text = 'NPE'::text) AND ((now() >= COALESCE(cbd.ent_sub_type_start_date, '1970-01-01'::date)) AND (now() <= COALESCE(cbd.ent_sub_type_end_date, '9999-12-31'::date)))))) THEN 'Active ADO'::text
                    ELSE 'InActive ADO'::text
                END
                WHEN (cbd.lit_party_start_date > ebd.acquisition_date) THEN
                CASE
                    WHEN ((cbd.lit_party_end_date IS NULL) AND (cbd.case_is_abandon = false) AND ((cbd.account_type)::text <> ALL ((ARRAY['Member Subsidiary'::character varying, 'Insurance Member'::character varying, 'Member'::character varying])::text[])) AND ((cbd.bgo_account_is_deleted)::text <> 'true'::text) AND ((cbd.ent_type)::text <> ALL ((ARRAY['Individual'::character varying, 'Government'::character varying, 'John Doe'::character varying])::text[])) AND (NOT (((COALESCE(cbd.ent_sub_type, 'N/A'::character varying))::text = 'NPE'::text) AND ((now() >= COALESCE(cbd.ent_sub_type_start_date, '1970-01-01'::date)) AND (now() <= COALESCE(cbd.ent_sub_type_end_date, '9999-12-31'::date)))))) THEN 'Active FD'::text
                    ELSE 'InActive FD'::text
                END
                ELSE NULL::text
            END
        END AS current_bgo_type_name,
    cbd.prc_patents
   FROM (existing_bgo_data ebd
     LEFT JOIN current_bgo_data cbd ON (((ebd.acquisition_id = cbd.acquisition_id) AND (ebd.parent_option_id = cbd.option_id) AND ((ebd.bgo_account_id)::text = (cbd.salesforce_id)::text))));


--
-- Name: VIEW v_batch_generated_option_details; Type: COMMENT; Schema: acquiflow; Owner: -
--

COMMENT ON VIEW v_batch_generated_option_details IS '1.0 tazhagan_c AQF-978 : New view for getting the details of batch generated options';


--
-- Name: v_full_asset_report; Type: VIEW; Schema: acquiflow; Owner: -
--

CREATE VIEW v_full_asset_report AS
 SELECT aq.id AS acquisition_id,
    aq.acquisition_name,
    aq.acquisition_date,
    ports.id AS portfolio_id,
    (ports.portfolio_name)::character varying(512) AS portfolio_name,
    (aqp.case_number)::character varying(32) AS case_number,
    ast.name AS assets_status,
    aqp.country_code,
    (aqp.application_number)::text AS application_number,
    (aqp.filing_date)::text AS app_file_date,
    (aqp.patnum)::character varying(32) AS patnum,
    (aqp.issue_date)::text AS issue_date,
    aqp.expiration_date,
    (aqp.title)::character varying AS title,
    (max(
        CASE
            WHEN ((own_right_types.name)::text = 'Ownership'::text) THEN 1
            ELSE 0
        END))::boolean AS rpx_ownership_rights_ownership,
    (max(
        CASE
            WHEN ((own_right_types.name)::text = 'Sublicense'::text) THEN 1
            ELSE 0
        END))::boolean AS rpx_ownership_rights_sublicense,
    (max(
        CASE
            WHEN ((own_right_types.name)::text = 'Covenant Not to Sue'::text) THEN 1
            ELSE 0
        END))::boolean AS rpx_ownership_rights_cns,
    (max(
        CASE
            WHEN ((own_right_types.name)::text = 'Sold'::text) THEN 1
            ELSE 0
        END))::boolean AS rpx_ownership_rights_sold,
    (aqp.publication_number)::character varying(32) AS publication_number,
    aqp.publication_date,
    ( SELECT string_agg(DISTINCT (COALESCE(ents.name, aliases.name))::text, '; '::text) AS string_agg
           FROM ((acquisition_patents_dcl_current_assignee_aliases pdca
             JOIN core.aliases ON ((aliases.id = pdca.alias_id)))
             LEFT JOIN core.ents ON ((ents.id = aliases.ent_id)))
          WHERE (pdca.acquisition_patent_dcl_id = aqp.id)) AS current_assignees,
    aqp.pat_family_id,
    (aqp.asset_source)::text AS source,
    (aqp.asset_source_id)::text AS source_asset_id,
        CASE
            WHEN ((aq.is_published_to_portal = true) AND (aq.published_at IS NOT NULL) AND (ports.published_at IS NOT NULL)) THEN true
            ELSE false
        END AS is_published_to_portal
   FROM ((((((acquisitions aq
     JOIN acquisition_patents_dcl aqp ON ((aqp.acquisition_id = aq.id)))
     LEFT JOIN acquisition_patent_attributes_dcl aqpa ON ((aqpa.acquisition_patent_id = aqp.acquisition_patent_id)))
     LEFT JOIN acquisition_patents_dcl_rpx_ownership_rights own_rights ON ((own_rights.acquisition_patents_dcl_id = aqp.id)))
     LEFT JOIN rpx_ownership_rights own_right_types ON ((own_right_types.id = own_rights.rpx_ownership_right_id)))
     LEFT JOIN asset_status_types ast ON ((ast.id = aqp.asset_status_type_id)))
     LEFT JOIN portfolios ports ON ((ports.id = aqp.portfolio_id)))
  WHERE (aq.published_at IS NOT NULL)
  GROUP BY aq.id, aq.acquisition_name, aq.acquisition_date, ports.id, ((ports.portfolio_name)::character varying(512)), ((aqp.case_number)::character varying(32)), ast.name, aqp.country_code, (aqp.application_number)::text, (aqp.filing_date)::text, ((aqp.patnum)::character varying(32)), (aqp.issue_date)::text, aqp.expiration_date, (aqp.title)::character varying, ((aqp.publication_number)::character varying(32)), aqp.publication_date, ( SELECT string_agg(DISTINCT (COALESCE(ents.name, aliases.name))::text, '; '::text) AS string_agg
           FROM ((acquisition_patents_dcl_current_assignee_aliases pdca
             JOIN core.aliases ON ((aliases.id = pdca.alias_id)))
             LEFT JOIN core.ents ON ((ents.id = aliases.ent_id)))
          WHERE (pdca.acquisition_patent_dcl_id = aqp.id)), aqp.pat_family_id, ((aqp.asset_source)::text), (aqp.asset_source_id)::text,
        CASE
            WHEN ((aq.is_published_to_portal = true) AND (aq.published_at IS NOT NULL) AND (ports.published_at IS NOT NULL)) THEN true
            ELSE false
        END
  ORDER BY aq.id DESC, ports.id DESC, (aqp.filing_date)::text DESC;


--
-- Name: VIEW v_full_asset_report; Type: COMMENT; Schema: acquiflow; Owner: -
--

COMMENT ON VIEW v_full_asset_report IS '1.0 tazhagan_c MC-582 : New view for getting the full asset report';


--
-- Name: v_full_options_report; Type: VIEW; Schema: acquiflow; Owner: -
--

CREATE VIEW v_full_options_report AS
 SELECT t1.acquisition_id,
    t1.acquisition_name,
    t1.acquisition_date,
    t1.entity_name,
    t1.ultimate_parent_name,
    t1.entity_account_owner_name,
    t1.entity_account_type,
    t1.option_type,
    t1.option_status,
    (t1.option_price)::numeric AS option_price,
    t1.notes,
    t1.effective_date,
    (t1.exercised_date)::date AS exercised_date,
    t1.expiration_date,
    (t1.expiration_date - (now())::date) AS expires_in_no_of_days,
    t1.bgo_status_name,
        CASE
            WHEN (t1.notification_sent_at IS NULL) THEN 'No'::text
            ELSE 'Yes'::text
        END AS notification_sent,
    t1.option_id,
    t1.parent_option_id
   FROM ( SELECT t.option_id,
            t.option_name,
            t.option_type,
            (
                CASE
                    WHEN (((t.option_type)::text = 'Batch Option'::text) AND (t.remaining_options = 0)) THEN 'Expired Option'::text
                    ELSE t.option_status
                END)::character varying AS option_status,
            t.option_price,
            t.effective_date,
            t.expiration_date,
            t.notes,
            t.option_count,
            t.ultimate_parent_name,
            t.entity_sf_account_id,
            t.entity_account_owner_id,
            t.entity_account_owner_name,
            t.ultimate_entity_sf_account_id,
            t.ultimate_entity_account_owner_id,
            t.ultimate_entity_account_owner_name,
            t.all_patents,
            t.option_patents_count,
            t.remaining_options,
            t.exercised_option_name,
            t.exercised_option_type,
            t.exercised_date,
            t.entity_name,
                CASE
                    WHEN (((t.option_type)::text = 'Batch Option'::text) AND (t.remaining_options = 0)) THEN true
                    ELSE t.is_option_expired
                END AS is_option_expired,
            t.bgo_status_id,
            t.bgo_status_name,
            t.notification_sent_at,
            t.entity_account_type,
            acq.acquisition_name,
            acq.acquisition_date,
            acq.id AS acquisition_id,
            t.bgo_id,
            t.bgo_type_id,
            t.bgo_type_name,
            t.source_table,
            t.parent_option_id
           FROM (( SELECT ao.id AS option_id,
                        CASE
                            WHEN ((opt.name)::text = 'Batch Option'::text) THEN ao.name
                            ELSE COALESCE(ents.name, accx.namex)
                        END AS option_name,
                    opt.name AS option_type,
                        CASE
                            WHEN ao.not_interested THEN 'Not Interested Option'::text
                            WHEN (ao.exercised_date IS NOT NULL) THEN 'Exercised Option'::text
                            WHEN (ao.expiration_date < (now())::date) THEN 'Expired Option'::text
                            WHEN ((ao.expiration_date IS NULL) OR (ao.expiration_date >= (now())::date)) THEN 'Active Option'::text
                            ELSE NULL::text
                        END AS option_status,
                    ao.option_price,
                    ao.effective_date,
                    ao.expiration_date,
                    ao.notes,
                    COALESCE((ao.option_count)::integer, 0) AS option_count,
                    ult_ents.name AS ultimate_parent_name,
                    accx.id AS entity_sf_account_id,
                    userx.id AS entity_account_owner_id,
                    (userx.namex)::text AS entity_account_owner_name,
                    ult_accx.id AS ultimate_entity_sf_account_id,
                    ult_userx.id AS ultimate_entity_account_owner_id,
                    (ult_userx.namex)::text AS ultimate_entity_account_owner_name,
                    COALESCE(ao.all_patents, false) AS all_patents,
                    count(aop.acquisition_patent_id) OVER (PARTITION BY ao.id) AS option_patents_count,
                        CASE
                            WHEN ((opt.name)::text = 'Entity Option'::text) THEN (0)::bigint
                            ELSE (COALESCE((ao.option_count)::integer, 1) - ( SELECT count(ebo.id) AS count
                               FROM exercised_batch_options ebo
                              WHERE (ebo.option_id = ao.id)))
                        END AS remaining_options,
                        CASE
                            WHEN ((ao.exercised_date IS NOT NULL) AND ((opt.name)::text = 'Entity Option'::text)) THEN COALESCE(ents.name, accx.namex)
                            ELSE NULL::character varying
                        END AS exercised_option_name,
                        CASE
                            WHEN (ao.exercised_date IS NOT NULL) THEN opt.name
                            ELSE NULL::character varying
                        END AS exercised_option_type,
                    ao.exercised_date,
                    COALESCE(ents.name, accx.namex) AS entity_name,
                        CASE
                            WHEN (ao.expiration_date < (now())::date) THEN true
                            ELSE false
                        END AS is_option_expired,
                    NULL::integer AS bgo_status_id,
                    NULL::text AS bgo_status_name,
                    NULL::timestamp without time zone AS notification_sent_at,
                    accx.typex AS entity_account_type,
                    ao.acquisition_id,
                    NULL::integer AS bgo_id,
                    NULL::integer AS bgo_type_id,
                    NULL::character varying AS bgo_type_name,
                    'acquisition_options'::character varying AS source_table,
                    NULL::integer AS parent_option_id
                   FROM ((((((((acquisition_options ao
                     JOIN option_types opt ON ((ao.option_type_id = opt.id)))
                     LEFT JOIN acquisition_option_patents aop ON ((ao.id = aop.acquisition_option_id)))
                     LEFT JOIN sf.accountx accx ON (((ao.entity_sf_account_id)::text = (accx.id)::text)))
                     LEFT JOIN sf.userx ON (((userx.id)::text = (accx.ownerid)::text)))
                     LEFT JOIN core.ents ents ON ((accx.entity_id__c = (ents.id)::numeric)))
                     LEFT JOIN core.ents ult_ents ON ((ents.ultimate_parent_id = ult_ents.id)))
                     LEFT JOIN sf.accountx ult_accx ON (((ult_ents.id)::numeric = ult_accx.entity_id__c)))
                     LEFT JOIN sf.userx ult_userx ON (((ult_userx.id)::text = (ult_accx.ownerid)::text)))
                UNION
                 SELECT ao.id AS option_id,
                    COALESCE(ents.name, accx.namex) AS option_name,
                    opt2.name AS option_type,
                    'Exercised Option'::text AS option_status,
                    ao.option_price,
                    ao2.effective_date,
                    ao2.expiration_date,
                    ao.notes,
                    COALESCE((ao2.option_count)::integer, 0) AS option_count,
                    ult_ents.name AS ultimate_parent_name,
                    accx.id AS entity_sf_account_id,
                    userx.id AS entity_account_owner_id,
                    (userx.namex)::text AS entity_account_owner_name,
                    ult_accx.id AS ultimate_entity_sf_account_id,
                    ult_userx.id AS ultimate_entity_account_owner_id,
                    (ult_userx.namex)::text AS ultimate_entity_account_owner_name,
                    COALESCE(ao2.all_patents, false) AS all_patents,
                    count(aop.acquisition_patent_id) OVER (PARTITION BY ao.id) AS option_patents_count,
                    NULL::bigint AS remaining_options,
                    ao2.name AS exercised_option_name,
                    opt2.name AS exercised_option_type,
                    ao.exercised_date,
                    COALESCE(ents.name, accx.namex) AS entity_name,
                        CASE
                            WHEN (ao2.expiration_date < (now())::date) THEN true
                            ELSE false
                        END AS is_option_expired,
                    NULL::integer AS bgo_status_id,
                    NULL::text AS bgo_status_name,
                    NULL::timestamp without time zone AS notification_sent_at,
                    accx.typex AS entity_account_type,
                    ao2.acquisition_id,
                    NULL::integer AS bgo_id,
                    NULL::integer AS bgo_type_id,
                    NULL::character varying AS bgo_type_name,
                    'exercised_batch_options'::character varying AS source_table,
                    ao.option_id AS parent_option_id
                   FROM (((((((((acquisition_options ao2
                     JOIN exercised_batch_options ao ON ((ao.option_id = ao2.id)))
                     LEFT JOIN option_types opt2 ON ((ao2.option_type_id = opt2.id)))
                     LEFT JOIN acquisition_option_patents aop ON ((ao.id = aop.acquisition_option_id)))
                     LEFT JOIN sf.accountx accx ON (((ao.entity_sf_account_id)::text = (accx.id)::text)))
                     LEFT JOIN sf.userx ON (((userx.id)::text = (accx.ownerid)::text)))
                     LEFT JOIN core.ents ents ON ((accx.entity_id__c = (ents.id)::numeric)))
                     LEFT JOIN core.ents ult_ents ON ((ents.ultimate_parent_id = ult_ents.id)))
                     LEFT JOIN sf.accountx ult_accx ON (((ult_ents.id)::numeric = ult_accx.entity_id__c)))
                     LEFT JOIN sf.userx ult_userx ON (((ult_userx.id)::text = (ult_accx.ownerid)::text)))
                UNION
                 SELECT bgoe.id AS option_id,
                    ao.name AS option_name,
                    'Batch Generated Option'::character varying AS option_type,
                        CASE
                            WHEN (ao.exercised_date IS NOT NULL) THEN 'Exercised Option'::text
                            WHEN (bgoe.expiration_date < (now())::date) THEN 'Expired Option'::text
                            WHEN ((bgoe.expiration_date IS NULL) OR (bgoe.expiration_date >= (now())::date)) THEN 'Active Option'::text
                            ELSE NULL::text
                        END AS option_status,
                    bgoe.option_price,
                    ao.effective_date,
                    bgoe.expiration_date,
                    ao.notes,
                    COALESCE((ao.option_count)::integer, 0) AS option_count,
                    ult_ents.name AS ultimate_parent_name,
                    accx.id AS entity_sf_account_id,
                    userx.id AS entity_account_owner_id,
                    (userx.namex)::text AS entity_account_owner_name,
                    ult_accx.id AS ultimate_entity_sf_account_id,
                    ult_userx.id AS ultimate_entity_account_owner_id,
                    (ult_userx.namex)::text AS ultimate_entity_account_owner_name,
                    COALESCE(ao.all_patents, false) AS all_patents,
                    count(aop.acquisition_patent_id) OVER (PARTITION BY ao.id) AS option_patents_count,
                    0 AS remaining_options,
                    NULL::character varying AS exercised_option_name,
                    NULL::character varying AS exercised_option_type,
                    NULL::timestamp without time zone AS exercised_date,
                    COALESCE(ents.name, accx.namex) AS entity_name,
                        CASE
                            WHEN (bgoe.expiration_date < (now())::date) THEN true
                            ELSE false
                        END AS is_option_expired,
                    bgoe.bgo_status_id,
                    (bgos.name)::text AS bgo_status_name,
                    bgoe.notification_sent_at,
                    accx.typex AS entity_account_type,
                    ao.acquisition_id,
                    bgoe.id AS bgo_id,
                    bgoe.bgo_type_id,
                    ( SELECT bgot.name
                           FROM batch_generated_option_types bgot
                          WHERE (bgot.id = bgoe.bgo_type_id)
                         LIMIT 1) AS bgo_type_name,
                    'batch_generated_option_ents'::character varying AS source_table,
                    ao.id AS parent_option_id
                   FROM ((((((((((batch_generated_option_ents bgoe
                     JOIN acquisition_options ao ON ((ao.id = bgoe.option_id)))
                     JOIN option_types opt ON ((ao.option_type_id = opt.id)))
                     LEFT JOIN acquisition_option_patents aop ON ((ao.id = aop.acquisition_option_id)))
                     LEFT JOIN sf.accountx accx ON (((bgoe.account_id)::text = (accx.id)::text)))
                     LEFT JOIN sf.userx ON (((userx.id)::text = (accx.ownerid)::text)))
                     LEFT JOIN core.ents ents ON ((accx.entity_id__c = (ents.id)::numeric)))
                     LEFT JOIN core.ents ult_ents ON ((ents.ultimate_parent_id = ult_ents.id)))
                     LEFT JOIN sf.accountx ult_accx ON (((ult_ents.id)::numeric = ult_accx.entity_id__c)))
                     LEFT JOIN sf.userx ult_userx ON (((ult_userx.id)::text = (ult_accx.ownerid)::text)))
                     LEFT JOIN batch_generated_option_statuses bgos ON ((bgoe.bgo_status_id = bgos.id)))) t
             JOIN acquisitions acq ON ((acq.id = t.acquisition_id)))
          WHERE (acq.published_at IS NOT NULL)) t1
  WHERE (((t1.option_status)::text = ANY (ARRAY[('Active Option'::character varying)::text, ('Exercised Option'::character varying)::text, ('Not Interested Option'::character varying)::text, ('Expired Option'::character varying)::text])) AND ((t1.option_type)::text = ANY (ARRAY[('Batch Option'::character varying)::text, ('Entity Option'::character varying)::text, ('Batch Generated Option'::character varying)::text])))
  ORDER BY t1.acquisition_id DESC, t1.option_id;


--
-- Name: VIEW v_full_options_report; Type: COMMENT; Schema: acquiflow; Owner: -
--

COMMENT ON VIEW v_full_options_report IS '1.0 tazhagan_c MC-582 : New view for getting the full options report';


--
-- Name: v_missing_portfolio; Type: VIEW; Schema: acquiflow; Owner: -
--

CREATE VIEW v_missing_portfolio AS
 SELECT dcl.id,
    dcl.acquisition_patent_id,
    dcl.acquisition_id,
    acq.acquisition_name,
    acq.acquisition_date,
    dcl.portfolio_id,
    port.portfolio_name,
    dcl.case_number,
    dcl.application_number,
    dcl.patnum,
    dcl.title
   FROM ((acquisition_patents_dcl dcl
     LEFT JOIN acquisitions acq ON ((acq.id = dcl.acquisition_id)))
     LEFT JOIN portfolios port ON ((port.id = dcl.portfolio_id)))
  WHERE ((dcl.portfolio_id IS NULL) AND (dcl.publication_date IS NOT NULL));


--
-- Name: v_portfolio_asset_counts; Type: VIEW; Schema: acquiflow; Owner: -
--

CREATE VIEW v_portfolio_asset_counts AS
 SELECT t.portfolio_id,
    t.portfolio_name,
    t.acquisition_id,
    t.acquisition_name,
    t.acquisition_date,
    t.acquisition_type,
    sum((t.us * (t.is_application)::integer)) AS us_applications,
    sum((t.us * (t.is_patent)::integer)) AS us_patents,
    sum(t.us) AS us_total,
    sum((t.f * (t.is_application)::integer)) AS f_applications,
    sum((t.f * (t.is_patent)::integer)) AS f_patents,
    sum(t.f) AS f_total,
    sum((t.is_application)::integer) AS ww_applications,
    sum((t.is_patent)::integer) AS ww_patents,
    (sum(t.us) + sum(t.f)) AS ww_total
   FROM ( SELECT p.id AS portfolio_id,
            p.portfolio_name,
            acq.id AS acquisition_id,
            acq.acquisition_name,
            acq.acquisition_date,
            at.name AS acquisition_type,
                CASE ap.country_code
                    WHEN 'US'::text THEN 1
                    ELSE 0
                END AS us,
                CASE ap.country_code
                    WHEN 'US'::text THEN 0
                    ELSE 1
                END AS f,
            ap.is_application,
            (NOT ap.is_application) AS is_patent
           FROM (((portfolios p
             JOIN acquisitions acq ON ((p.acquisition_id = acq.id)))
             JOIN acquisition_patents_dcl ap ON ((ap.portfolio_id = p.id)))
             JOIN acquisition_types at ON ((at.id = acq.acquisition_type_id)))) t
  GROUP BY t.portfolio_id, t.portfolio_name, t.acquisition_id, t.acquisition_name, t.acquisition_date, t.acquisition_type
  ORDER BY t.acquisition_date;


--
-- Name: v_portfolio_asset_counts_at_acq; Type: VIEW; Schema: acquiflow; Owner: -
--

CREATE VIEW v_portfolio_asset_counts_at_acq AS
 SELECT t.portfolio_id,
    t.portfolio_name,
    t.acquisition_id,
    t.acquisition_name,
    t.acquisition_date,
    t.acquisition_type,
    sum((t.us * (t.was_application)::integer)) AS us_applications,
    sum((t.us * (t.was_patent)::integer)) AS us_patents,
    sum(t.us) AS us_total,
    sum((t.f * (t.was_application)::integer)) AS f_applications,
    sum((t.f * (t.was_patent)::integer)) AS f_patents,
    sum(t.f) AS f_total,
    sum((t.was_application)::integer) AS ww_applications,
    sum((t.was_patent)::integer) AS ww_patents,
    (sum(t.us) + sum(t.f)) AS ww_total
   FROM ( SELECT p.id AS portfolio_id,
            p.portfolio_name,
            acq.id AS acquisition_id,
            acq.acquisition_name,
            acq.acquisition_date,
            ap.issue_date,
            (ap.is_application OR (ap.issue_date > acq.acquisition_date)) AS was_application,
            (NOT (ap.is_application OR (ap.issue_date > acq.acquisition_date))) AS was_patent,
            at.name AS acquisition_type,
                CASE ap.country_code
                    WHEN 'US'::text THEN 1
                    ELSE 0
                END AS us,
                CASE ap.country_code
                    WHEN 'US'::text THEN 0
                    ELSE 1
                END AS f,
            ap.is_application,
            (NOT ap.is_application) AS is_patent
           FROM (((portfolios p
             JOIN acquisitions acq ON ((p.acquisition_id = acq.id)))
             JOIN acquisition_patents_dcl ap ON ((ap.portfolio_id = p.id)))
             JOIN acquisition_types at ON ((at.id = acq.acquisition_type_id)))) t
  GROUP BY t.portfolio_id, t.portfolio_name, t.acquisition_id, t.acquisition_name, t.acquisition_date, t.acquisition_type
  ORDER BY t.acquisition_date;


SET search_path = core, pg_catalog;

--
-- Name: market_sector_types; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE market_sector_types (
    id integer NOT NULL,
    name character varying(255) NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    is_default boolean DEFAULT false NOT NULL,
    description character varying(255),
    key_value character varying
);


--
-- Name: TABLE market_sector_types; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE market_sector_types IS 'RPX market sector codes (1-18) (data01: rpx_casedata.marketsector)';


--
-- Name: COLUMN market_sector_types.id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN market_sector_types.id IS 'Market sector type ID (key connects to lit_annotations and ents_market_sector_types)';


--
-- Name: COLUMN market_sector_types.name; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN market_sector_types.name IS 'Name of market sector';


--
-- Name: COLUMN market_sector_types.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN market_sector_types.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN market_sector_types.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN market_sector_types.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: COLUMN market_sector_types.is_default; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN market_sector_types.is_default IS 'When TRUE, the value is the one that should be used for any new record where the value is not known. There should only be one TRUE record in the table.';


SET default_tablespace = rpx_user_default;

--
-- Name: patent_owners; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE patent_owners (
    pat_id integer,
    stripped_patnum character varying,
    country_code character varying,
    owner_alias_id integer,
    owner_ent_id integer,
    start_date date,
    end_date date,
    id bigint NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now()
);


SET search_path = ptab, pg_catalog;

SET default_tablespace = '';

--
-- Name: ptab_cases; Type: TABLE; Schema: ptab; Owner: -
--

CREATE TABLE ptab_cases (
    id integer NOT NULL,
    case_num character varying(20) NOT NULL,
    filing_date date NOT NULL,
    institution_decision_date date,
    stripped_patnum character varying(10),
    country_code character varying NOT NULL,
    application_num character varying(10),
    status character varying(64) NOT NULL,
    tech_center character varying(100) NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    created_by character varying(15) NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_by character varying(15) NOT NULL,
    ptab_case_type_id integer,
    is_dcl_corrected boolean DEFAULT false,
    final_decision_date date,
    final_outcome_date date,
    notice_date date,
    reason_for_notice_filing_date text,
    final_decision_outcome text,
    final_outcome text,
    petitioner_application_num character varying(10),
    petitioner_stripped_patnum character varying(10),
    petitioner_tech_center character varying(100),
    missing_from_source_date date,
    is_open boolean
);


--
-- Name: COLUMN ptab_cases.stripped_patnum; Type: COMMENT; Schema: ptab; Owner: -
--

COMMENT ON COLUMN ptab_cases.stripped_patnum IS 'Patent Number from the ptab site';


--
-- Name: COLUMN ptab_cases.application_num; Type: COMMENT; Schema: ptab; Owner: -
--

COMMENT ON COLUMN ptab_cases.application_num IS 'application number from the ptab site';


--
-- Name: COLUMN ptab_cases.final_decision_date; Type: COMMENT; Schema: ptab; Owner: -
--

COMMENT ON COLUMN ptab_cases.final_decision_date IS 'Final Written Decision Date';


--
-- Name: COLUMN ptab_cases.final_outcome_date; Type: COMMENT; Schema: ptab; Owner: -
--

COMMENT ON COLUMN ptab_cases.final_outcome_date IS 'Final Outcome Date';


--
-- Name: COLUMN ptab_cases.notice_date; Type: COMMENT; Schema: ptab; Owner: -
--

COMMENT ON COLUMN ptab_cases.notice_date IS 'Date of Notice of Accorded Filing Date';


--
-- Name: COLUMN ptab_cases.reason_for_notice_filing_date; Type: COMMENT; Schema: ptab; Owner: -
--

COMMENT ON COLUMN ptab_cases.reason_for_notice_filing_date IS 'Source of Notice Date or reason why it is not available';


SET search_path = acquiflow, pg_catalog;

--
-- Name: v_rpx_assets_report_dcl; Type: VIEW; Schema: acquiflow; Owner: -
--

CREATE VIEW v_rpx_assets_report_dcl AS
 SELECT aqp.acquisition_patent_id,
    aq.id AS acquisition_id,
    aqt.name AS acquisition_type,
    ports.id AS portfolio_id,
    ( SELECT array_agg(DISTINCT aop.acquisition_sf_id) AS array_agg
           FROM acquisition_opportunities_portfolios aop
          WHERE (aop.portfolio_id = ports.id)) AS portfolio_acquisition_sf_ids,
    aq.acquisition_name,
    aq.acquisition_date,
    (ports.portfolio_name)::character varying(512) AS portfolio_name,
    ( SELECT string_agg(DISTINCT (COALESCE(ents.name, aliases.name))::text, '; '::text) AS string_agg
           FROM ((acquisition_patents_dcl_current_assignee_aliases pdca
             JOIN core.aliases ON ((aliases.id = pdca.alias_id)))
             LEFT JOIN core.ents ON ((ents.id = aliases.ent_id)))
          WHERE (pdca.acquisition_patent_dcl_id = aqp.id)) AS current_assignees,
    ( SELECT (string_to_array(string_agg(DISTINCT (pdca.alias_id)::text, ','::text), ','::text))::integer[] AS string_to_array
           FROM acquisition_patents_dcl_current_assignee_aliases pdca
          WHERE (pdca.acquisition_patent_dcl_id = aqp.id)) AS current_assignee_aliases,
    (aqp.publication_number)::character varying(32) AS publication_number,
    aqp.publication_date,
    aqp.pat_family_id,
    aqp.expiration_date,
    COALESCE(( SELECT 'Owned'::character varying(64) AS rpx_ownership_rights
           FROM (rpx_ownership_rights ror
             JOIN acquisition_patents_dcl_rpx_ownership_rights ap_dcl_own ON ((ror.id = ap_dcl_own.rpx_ownership_right_id)))
          WHERE ((ap_dcl_own.acquisition_patents_dcl_id = aqp.id) AND ((ror.name)::text = 'Ownership'::text))), 'Other'::character varying(64)) AS rpx_ownership_rights,
    ast.name AS assets_status,
    aqp.country_code,
    aqp.stripped_patnum,
    (COALESCE(aqp.patnum, (((aqp.country_code)::text || (aqp.stripped_patnum)::text))::character varying))::character varying(32) AS patnum,
    (aqp.application_number)::character varying(32) AS application_number,
    (aqp.case_number)::character varying(32) AS case_number,
    aqp.title,
    aqp.filing_date AS app_file_date,
    aqp.issue_date,
    (aqpa.subcase)::character varying(8) AS subcase,
    ( SELECT (string_to_array(string_agg(DISTINCT (pa.owner_alias_id)::text, ','::text), ','::text))::integer[] AS string_to_array
           FROM core.patent_owners pa
          WHERE (((pa.stripped_patnum)::text = (aqp.stripped_patnum)::text) AND ((pa.country_code)::text = (aqp.country_code)::text) AND (pa.start_date < aq.acquisition_date) AND (COALESCE(pa.end_date, '9999-01-01'::date) >= aq.acquisition_date))) AS assignee_aliases,
        CASE
            WHEN (( SELECT count(*) AS count
               FROM core.lits_pats_map
              WHERE ((lits_pats_map.patnum)::text = (aqp.stripped_patnum)::text)) > 0) THEN true
            ELSE false
        END AS is_litigated,
    (COALESCE(( SELECT max(1) AS max
           FROM ptab.ptab_cases ipr
          WHERE (((aqp.stripped_patnum)::text = (ipr.stripped_patnum)::text) AND ((aqp.country_code)::text = (ipr.country_code)::text))
          GROUP BY ipr.stripped_patnum, ipr.country_code), 0))::boolean AS is_ipr_flag,
    (aqp.asset_source)::character varying(32) AS source,
    (aqp.asset_source_id)::character varying(32) AS source_asset_id,
    cpi_tracking_status.name AS cpi_tracking_status,
    aqp.priority_date,
        CASE
            WHEN (aqp.issue_date IS NULL) THEN 'Y'::text
            ELSE 'N'::text
        END AS is_application,
    (( SELECT ( SELECT mst.name
                   FROM core.market_sector_types mst
                  WHERE (mst.id = COALESCE(mstm.id, 8))
                 LIMIT 1) AS primary_market_sector_name
           FROM ((pa_web.analysis_portfolio p
             LEFT JOIN pa_web.market_sector_types_map mstm ON (((mstm.key_value)::text = (p.primary_market_sector)::text)))
             LEFT JOIN acquisition_opportunities_portfolios aop ON (((p.salesforce_id)::text = (aop.acquisition_sf_id)::text)))
          WHERE (aop.portfolio_id = ports.id)
         LIMIT 1))::character varying(50) AS primary_market_sector,
    ( SELECT array_agg(DISTINCT pc.id ORDER BY pc.id) AS array_agg
           FROM core.pat_claims pc,
            patent_blaster.task_pats tp,
            patent_blaster.claim_annotations ca
          WHERE ((pc.pat_id = tp.pat_id) AND (pc.id = ca.claim_id) AND ((tp.stripped_patnum)::text = (aqp.stripped_patnum)::text) AND ((tp.country_code)::text = (aqp.country_code)::text) AND (ca.is_representative_claim = true) AND (pc.claim_text IS NOT NULL))) AS representative_claim_ids,
    (COALESCE(NULLIF((aqp.patnum)::text, ''::text), NULLIF((aqp.publication_number)::text, ''::text), (aqp.application_number)::text))::character varying AS asset_number,
    aq.published_at AS acquisition_published_at,
    ports.published_at AS portfolio_published_at,
    ( SELECT array_to_json(array_agg(t.*)) AS array_to_json
           FROM ( SELECT mcd.id AS document_id,
                    mcd.document_name
                   FROM (member_credit3.member_credit_portfolios mcp
                     JOIN member_credit3.member_credit_documents mcd ON (((mcp.id = mcd.documentable_id) AND ((mcd.documentable_type)::text = 'AR::MemberCreditPortfolio'::text) AND (mcd.member_credit_document_type_id = 1))))
                  WHERE (mcp.portfolio_id = ports.id)
                  ORDER BY mcd.created_at DESC
                 LIMIT 1) t) AS mc_doc_details,
    ( SELECT ror.name
           FROM (rpx_ownership_rights ror
             JOIN acquisition_patents_dcl_rpx_ownership_rights ap_dcl_own ON ((ror.id = ap_dcl_own.rpx_ownership_right_id)))
          WHERE (ap_dcl_own.acquisition_patents_dcl_id = aqp.id)
         LIMIT 1) AS rpx_ownership_name,
    ( SELECT accountx.namex
           FROM (acquisition_agreements aag
             JOIN sf.accountx ON (((accountx.id)::text = (aag.seller_sf_account_id)::text)))
          WHERE (aag.acquisition_id = aq.id)) AS counter_party
   FROM ((((((acquisitions aq
     JOIN acquisition_types aqt ON ((aq.acquisition_type_id = aqt.id)))
     JOIN acquisition_patents_dcl aqp ON ((aqp.acquisition_id = aq.id)))
     JOIN acquisition_patent_attributes_dcl aqpa ON ((aqpa.acquisition_patent_id = aqp.acquisition_patent_id)))
     JOIN portfolios ports ON ((ports.id = aqp.portfolio_id)))
     LEFT JOIN asset_status_types ast ON ((ast.id = aqp.asset_status_type_id)))
     LEFT JOIN cpi_tracking_status ON ((cpi_tracking_status.id = aqp.cpi_tracking_status_id)))
  WHERE (aq.is_published_to_portal AND (aq.published_at IS NOT NULL) AND (NOT (EXISTS ( SELECT 1
           FROM portfolios p
          WHERE ((p.acquisition_id = aq.id) AND (p.published_at IS NULL))))));


SET search_path = core, pg_catalog;

--
-- Name: assignees_aliases_map; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE assignees_aliases_map (
    assignment_id integer NOT NULL,
    alias_id integer NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    alias_contact_id integer,
    is_verified boolean DEFAULT false NOT NULL,
    verified_by character varying(255),
    notes text,
    id integer NOT NULL
);


--
-- Name: COLUMN assignees_aliases_map.is_verified; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN assignees_aliases_map.is_verified IS 'has the alias->assignees mapping been approved by a human?';


--
-- Name: assignors_aliases_map; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE assignors_aliases_map (
    assignment_id integer NOT NULL,
    alias_id integer NOT NULL,
    execution_date date NOT NULL,
    acknowledged_date date,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    alias_contact_id integer,
    id integer NOT NULL,
    is_verified boolean DEFAULT false NOT NULL,
    notes text,
    verified_by character varying(255)
);


--
-- Name: COLUMN assignors_aliases_map.execution_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN assignors_aliases_map.execution_date IS 'when this assignor executed their part of assignment.
tds: assd.assd_sd';


--
-- Name: COLUMN assignors_aliases_map.acknowledged_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN assignors_aliases_map.acknowledged_date IS 'from rawdb.rpx.us_patent_assignments.date_acknowledged
date PTO recognized this assignors paperwork
"only present when no execution date availble"
tds: assd_da';


--
-- Name: COLUMN assignors_aliases_map.is_verified; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN assignors_aliases_map.is_verified IS 'has the alias->assignors mapping been approved by a human?';


--
-- Name: lit_courts_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_courts_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_courts; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lit_courts (
    lit_id integer NOT NULL,
    alias_id integer NOT NULL,
    start_date date,
    end_date date,
    is_verified boolean DEFAULT false NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    id integer DEFAULT nextval('lit_courts_id_seq'::regclass) NOT NULL,
    verified_by character varying(255)
);


--
-- Name: TABLE lit_courts; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE lit_courts IS 'Litigation courts (connnects litigations to the aliases for the courts)';


--
-- Name: COLUMN lit_courts.lit_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_courts.lit_id IS 'Litigation ID (key connects to lits)';


--
-- Name: COLUMN lit_courts.alias_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_courts.alias_id IS 'Alias ID (key connects to aliases)';


--
-- Name: COLUMN lit_courts.start_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_courts.start_date IS 'Start date of venue tenure';


--
-- Name: COLUMN lit_courts.end_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_courts.end_date IS 'End date of venue tenure';


--
-- Name: COLUMN lit_courts.is_verified; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_courts.is_verified IS 'has the alias->court mapping been approved by a human?';


--
-- Name: COLUMN lit_courts.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_courts.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN lit_courts.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_courts.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: lit_judges_map_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_judges_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_judges_map; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lit_judges_map (
    alias_id integer NOT NULL,
    lit_id integer NOT NULL,
    assignment_type_id integer NOT NULL,
    is_terminated boolean DEFAULT false NOT NULL,
    assignment_role_as_filed character varying(255),
    end_date date,
    start_date date NOT NULL,
    is_verified boolean DEFAULT false NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    id integer DEFAULT nextval('lit_judges_map_id_seq'::regclass) NOT NULL,
    verified_by character varying(255),
    missing_from_source_date date
);


--
-- Name: TABLE lit_judges_map; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE lit_judges_map IS 'Judges assigned to litigations (docketx: caseassignment)';


--
-- Name: COLUMN lit_judges_map.alias_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_judges_map.alias_id IS 'Alias ID (key connects to aliases)';


--
-- Name: COLUMN lit_judges_map.lit_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_judges_map.lit_id IS 'Litigation ID (key connects to lits)';


--
-- Name: COLUMN lit_judges_map.assignment_type_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_judges_map.assignment_type_id IS 'Assignment type ID (key connects to judge_assignment_types) (docketx: caseassignment.assignmenttype)';


--
-- Name: COLUMN lit_judges_map.is_terminated; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_judges_map.is_terminated IS 'Is this judge no longer on this case? (docketx: caseassignment.isterminated)';


--
-- Name: COLUMN lit_judges_map.assignment_role_as_filed; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_judges_map.assignment_role_as_filed IS 'Role (honorable, magistrate, etc., as spidered) (docketx: caseassignment.assignmentrole)';


--
-- Name: COLUMN lit_judges_map.end_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_judges_map.end_date IS 'End date of assignment tenure';


--
-- Name: COLUMN lit_judges_map.start_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_judges_map.start_date IS 'Start date of assignment tenure';


--
-- Name: COLUMN lit_judges_map.is_verified; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_judges_map.is_verified IS 'has the alias->ent mapping been approved by a human?';


--
-- Name: COLUMN lit_judges_map.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_judges_map.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN lit_judges_map.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_judges_map.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: lit_parties_representations_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_parties_representations_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_parties_representations; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lit_parties_representations (
    lit_parties_id integer NOT NULL,
    lawfirm_alias_id integer NOT NULL,
    lawyer_alias_id integer NOT NULL,
    is_lead_lawyer boolean DEFAULT false,
    is_notify_lawyer boolean DEFAULT false,
    lawyer_alias_contact_id integer,
    lawfirm_alias_contact_id integer,
    is_local_lawyer boolean DEFAULT false,
    start_date date,
    end_date date,
    is_verified boolean DEFAULT false NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    id integer DEFAULT nextval('lit_parties_representations_id_seq'::regclass) NOT NULL,
    verified_by character varying(255),
    missing_from_source_date date,
    is_dcl_corrected boolean
);


--
-- Name: TABLE lit_parties_representations; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE lit_parties_representations IS 'Which lawyers from which law firms represent which parties in a litagation. (docketx: representation)';


--
-- Name: COLUMN lit_parties_representations.lit_parties_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties_representations.lit_parties_id IS 'Lit parties ID (key connects to lit_parties)';


--
-- Name: COLUMN lit_parties_representations.lawfirm_alias_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties_representations.lawfirm_alias_id IS 'Law firm ID (key connects to aliases)';


--
-- Name: COLUMN lit_parties_representations.lawyer_alias_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties_representations.lawyer_alias_id IS 'Lawyer ID (key connects to aliases)';


--
-- Name: COLUMN lit_parties_representations.is_lead_lawyer; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties_representations.is_lead_lawyer IS 'Is this lawyer a lead attorney? (docketx: representation.leadattorney)';


--
-- Name: COLUMN lit_parties_representations.is_notify_lawyer; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties_representations.is_notify_lawyer IS 'Is this lawyer to be notified of any changes in docket? (docketx: representation.notifyattorney)';


--
-- Name: COLUMN lit_parties_representations.lawyer_alias_contact_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties_representations.lawyer_alias_contact_id IS 'Lawyer-Address ID (key connects to alias_contacts)';


--
-- Name: COLUMN lit_parties_representations.lawfirm_alias_contact_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties_representations.lawfirm_alias_contact_id IS 'Law Firm-Address ID (key connects to alias_contacts)';


--
-- Name: COLUMN lit_parties_representations.is_local_lawyer; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties_representations.is_local_lawyer IS 'does lawyer reside in court district?';


--
-- Name: COLUMN lit_parties_representations.start_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties_representations.start_date IS 'Start date of representation';


--
-- Name: COLUMN lit_parties_representations.end_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties_representations.end_date IS 'End date of representation';


--
-- Name: COLUMN lit_parties_representations.is_verified; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties_representations.is_verified IS 'has the alias->ent mapping (for lawyer and lawfirm) been approved by a human?';


--
-- Name: COLUMN lit_parties_representations.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties_representations.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN lit_parties_representations.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_parties_representations.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


SET default_tablespace = rpx_user_default;

--
-- Name: pats_assignments_map; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pats_assignments_map (
    id integer NOT NULL,
    patnum character varying(255) NOT NULL,
    stripped_patnum character varying(255) NOT NULL,
    doc_kind_code character varying(16),
    pat_assignment_id integer NOT NULL,
    is_zero_assignment boolean DEFAULT false,
    document_type_id integer,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    country_code character varying(16),
    pat_id integer,
    invention_id integer
);


--
-- Name: TABLE pats_assignments_map; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE pats_assignments_map IS 'This table maps patents to assignment records in the pat_assignments table. This table has one record per patent.  Comment updated at: 2012-11-06';


--
-- Name: COLUMN pats_assignments_map.patnum; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats_assignments_map.patnum IS 'Maps to core.pats.patnum and all other patnum fields except core.lits_pats_map.patnum. Comment updated at: 2012-11-06';


--
-- Name: COLUMN pats_assignments_map.stripped_patnum; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats_assignments_map.stripped_patnum IS 'Maps to all other stripped_patnum fields as well as core.lits_pats_map.patnum. Comment updated at: 2012-11-06';


--
-- Name: COLUMN pats_assignments_map.is_zero_assignment; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats_assignments_map.is_zero_assignment IS 'If true, the assignment is considered "name on face of patent". These are fake assignments created to allow us to easily store the name on the face of patent when it was issued. These are not recorded assignments with USPTO. Comment updated at: 2012-11-06';


--
-- Name: COLUMN pats_assignments_map.pat_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats_assignments_map.pat_id IS 'Patent ID from core.pats. Comment updated at: 2016-05-20';


--
-- Name: COLUMN pats_assignments_map.invention_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats_assignments_map.invention_id IS 'Invention ID from core.pats_invention. Comment updated at: 2016-05-20';


SET search_path = ptab, pg_catalog;

--
-- Name: ptab_expert_info; Type: TABLE; Schema: ptab; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE ptab_expert_info (
    src_id bigint NOT NULL,
    expert_alias_id integer,
    expert_name text,
    doc_ptab_case_detail_id integer,
    expert_document_name text,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    created_by character varying(15) DEFAULT "current_user"() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_by character varying(15) DEFAULT "current_user"() NOT NULL,
    id integer NOT NULL,
    ptab_case_id integer NOT NULL
);


--
-- Name: TABLE ptab_expert_info; Type: COMMENT; Schema: ptab; Owner: -
--

COMMENT ON TABLE ptab_expert_info IS ' This table is replica of ldc.lit_docs_ptab_petition_expert_info.even the id column is from source table';


SET default_tablespace = '';

--
-- Name: ptab_judges_map; Type: TABLE; Schema: ptab; Owner: -
--

CREATE TABLE ptab_judges_map (
    id integer NOT NULL,
    ptab_case_id integer NOT NULL,
    judge_alias_id integer NOT NULL,
    start_date date,
    end_date date,
    created_by text DEFAULT "current_user"() NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_by text DEFAULT "current_user"() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


--
-- Name: ptab_parties; Type: TABLE; Schema: ptab; Owner: -
--

CREATE TABLE ptab_parties (
    ptab_case_id integer NOT NULL,
    ptab_party_type_id integer NOT NULL,
    alias_id integer NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    created_by character varying(15) NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_by character varying(15) NOT NULL,
    id integer NOT NULL,
    is_primary boolean DEFAULT false,
    missing_from_source_date date
);


--
-- Name: COLUMN ptab_parties.id; Type: COMMENT; Schema: ptab; Owner: -
--

COMMENT ON COLUMN ptab_parties.id IS 'This column is added as it is required for Audit ETL/process';


--
-- Name: ptab_parties_representations; Type: TABLE; Schema: ptab; Owner: -
--

CREATE TABLE ptab_parties_representations (
    id bigint NOT NULL,
    ptab_parties_id bigint,
    lawfirm_alias_id bigint,
    attorney_alias_id bigint,
    lawfirm_alias_contact_id bigint,
    attorney_alias_contact_id bigint,
    start_date date,
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    created_by character varying(18)
);


SET search_path = core, pg_catalog;

--
-- Name: lit_curated_cause_types; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lit_curated_cause_types (
    id integer NOT NULL,
    name character varying(255) NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    is_default boolean DEFAULT false NOT NULL
);


--
-- Name: TABLE lit_curated_cause_types; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE lit_curated_cause_types IS '"normalized" causes for litigations';


--
-- Name: COLUMN lit_curated_cause_types.id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_curated_cause_types.id IS 'Artificial ID';


--
-- Name: COLUMN lit_curated_cause_types.name; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_curated_cause_types.name IS 'Cause types (Declaratory Judgment, Willful Patent Infringement, Ownership Dispute, etc.)';


--
-- Name: COLUMN lit_curated_cause_types.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_curated_cause_types.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN lit_curated_cause_types.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_curated_cause_types.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: COLUMN lit_curated_cause_types.is_default; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_curated_cause_types.is_default IS 'When TRUE, the value is the one that should be used for any new record where the value is not known. There should only be one TRUE record in the table.';


--
-- Name: lit_types; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lit_types (
    id integer NOT NULL,
    name character varying(255) NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    is_default boolean DEFAULT false NOT NULL,
    description character varying(255)
);


--
-- Name: TABLE lit_types; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE lit_types IS 'Type of case (data01: rpx_casedata.case_type)';


--
-- Name: COLUMN lit_types.name; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_types.name IS 'this looks like an overloaded field. (data01: rpx_casedata.case_type)

 12710 | Operating Company
  3487 | NPE
   938 | INV
   935 | False Marking
   196 | Misfile
   143 | Miscellaneous
   107 | NCE
    97 | UNI
    54 | Ownership Dispute
    47 | Administrative
    10 | Trademark
     8 | Pat Term Adjustment
     5 | Filed in Error
     1 | Copyright';


--
-- Name: COLUMN lit_types.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_types.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN lit_types.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_types.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: COLUMN lit_types.is_default; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_types.is_default IS 'When TRUE, the value is the one that should be used for any new record where the value is not known. There should only be one TRUE record in the table.';


--
-- Name: dma_lit_annotations; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE dma_lit_annotations (
    id integer NOT NULL,
    lit_id integer NOT NULL,
    rpx_lit_id character varying(16),
    lit_type_id integer,
    is_npe_suit boolean DEFAULT false NOT NULL,
    is_dj boolean NOT NULL,
    market_sector_type_id integer,
    lit_classification_type_id integer,
    lit_stage_id integer NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    is_abandon boolean DEFAULT false NOT NULL,
    ad_hoc_1 text,
    ad_hoc_2 text,
    ad_hoc_3 text,
    ad_hoc_4 text,
    ad_hoc_5 text,
    lit_curated_cause_type_id integer,
    is_ncl_suit boolean DEFAULT false NOT NULL,
    is_dcl_corrected boolean,
    lit_annotation_override boolean DEFAULT false
);


--
-- Name: docket_entries_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE docket_entries_id_seq
    START WITH 3452671
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


SET default_tablespace = rpx_user_default;

--
-- Name: docket_entries; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE docket_entries (
    id integer DEFAULT nextval('docket_entries_id_seq'::regclass) NOT NULL,
    lit_id integer NOT NULL,
    docketx_id character varying(32),
    date_entered date,
    date_filed date NOT NULL,
    docket_text text,
    entry_number integer DEFAULT 0,
    row_number integer NOT NULL,
    original_docket_text text,
    updated_at timestamp(6) without time zone NOT NULL,
    created_at timestamp(6) without time zone NOT NULL,
    is_mixed_action boolean DEFAULT false,
    event text,
    category character varying(255)
);


--
-- Name: TABLE docket_entries; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE docket_entries IS 'Row by row docket entries for each litigation.';


--
-- Name: COLUMN docket_entries.id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN docket_entries.id IS 'Docket entry ID (key connects to docket_entry_documents_map)';


--
-- Name: COLUMN docket_entries.lit_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN docket_entries.lit_id IS 'Litigation ID (key connects to lits)';


--
-- Name: COLUMN docket_entries.docketx_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN docket_entries.docketx_id IS 'ID to link back to DOcketX data (docketx: docketentry.id)';


--
-- Name: COLUMN docket_entries.date_entered; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN docket_entries.date_entered IS 'Date of docket entry (docketx: docketentry.dateentered)';


--
-- Name: COLUMN docket_entries.date_filed; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN docket_entries.date_filed IS 'Filing date of docket entry (docketx: docketentry.datefiled)';


--
-- Name: COLUMN docket_entries.docket_text; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN docket_entries.docket_text IS 'Text of docket entry';


--
-- Name: COLUMN docket_entries.entry_number; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN docket_entries.entry_number IS 'PACER docket entry number (docketx: docketentry.entrynumber)';


--
-- Name: COLUMN docket_entries.row_number; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN docket_entries.row_number IS 'PriorSmart will provide the exact docket_entry order (not in docketx data)';


--
-- Name: COLUMN docket_entries.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN docket_entries.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN docket_entries.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN docket_entries.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: docket_entry_documents_map_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE docket_entry_documents_map_id_seq
    START WITH 6001159
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: docket_entry_documents_map; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE docket_entry_documents_map (
    id integer DEFAULT nextval('docket_entry_documents_map_id_seq'::regclass) NOT NULL,
    docketx_id character varying(32),
    lit_document_id integer,
    docket_entry_id integer NOT NULL,
    is_main boolean NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    created_at timestamp(6) without time zone NOT NULL
);


--
-- Name: TABLE docket_entry_documents_map; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE docket_entry_documents_map IS 'Framework for storing docket documents (connects docket_entries to lit_documents)';


--
-- Name: COLUMN docket_entry_documents_map.id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN docket_entry_documents_map.id IS 'Artificial key';


--
-- Name: COLUMN docket_entry_documents_map.docketx_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN docket_entry_documents_map.docketx_id IS 'ID to connect back to the DocketX data (docketx: docketentrydocument.id)';


--
-- Name: COLUMN docket_entry_documents_map.lit_document_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN docket_entry_documents_map.lit_document_id IS 'PACER document ID (key connects to lit_documents)';


--
-- Name: COLUMN docket_entry_documents_map.docket_entry_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN docket_entry_documents_map.docket_entry_id IS 'Docket entry ID (key connects to docket_entries)';


--
-- Name: COLUMN docket_entry_documents_map.is_main; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN docket_entry_documents_map.is_main IS 'Is document a main document?';


--
-- Name: COLUMN docket_entry_documents_map.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN docket_entry_documents_map.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN docket_entry_documents_map.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN docket_entry_documents_map.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: lit_documents_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_documents_id_seq
    START WITH 9556206
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_documents; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE lit_documents (
    id integer DEFAULT nextval('lit_documents_id_seq'::regclass) NOT NULL,
    docketx_id character varying(36),
    doc_num integer,
    de_seq_num integer,
    dm_id integer,
    url character varying(255) NOT NULL,
    lit_document_type_id integer DEFAULT 0,
    file_type_id integer DEFAULT 0,
    rpx_file_name character varying(255),
    rpx_file_location character varying(255),
    document_status_id integer DEFAULT 1 NOT NULL,
    document_status_message text,
    case_key character varying(30),
    updated_at timestamp(6) without time zone NOT NULL,
    created_at timestamp(6) without time zone NOT NULL,
    old_id integer,
    no_of_pages integer,
    ocr_text text,
    pdf_type character varying,
    billable_pages integer,
    cost double precision
);


--
-- Name: TABLE lit_documents; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE lit_documents IS 'Electronically filed documents (from PACER)';


--
-- Name: COLUMN lit_documents.id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_documents.id IS 'Lit Document ID (key connects to docket_entry_documents_map)';


--
-- Name: COLUMN lit_documents.docketx_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_documents.docketx_id IS 'DocketX document ID (docketx: document.id)';


--
-- Name: COLUMN lit_documents.doc_num; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_documents.doc_num IS 'Parameter for document URL';


--
-- Name: COLUMN lit_documents.de_seq_num; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_documents.de_seq_num IS 'Parameter for document URL';


--
-- Name: COLUMN lit_documents.dm_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_documents.dm_id IS 'Parameter for document URL';


--
-- Name: COLUMN lit_documents.url; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_documents.url IS 'Document URL (docketx: document.documenturl)';


--
-- Name: COLUMN lit_documents.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_documents.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN lit_documents.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_documents.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: COLUMN lit_documents.pdf_type; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_documents.pdf_type IS 'plain pdf or scanned pdf, when the pdf contains scanned images.';


--
-- Name: lit_case_stages; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE lit_case_stages (
    id integer NOT NULL,
    lit_id integer NOT NULL,
    lit_stage_id integer NOT NULL,
    is_current boolean NOT NULL,
    comment text,
    start_date date NOT NULL,
    start_entry_index integer NOT NULL,
    end_date date,
    end_entry_index integer,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE lit_case_stages; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE lit_case_stages IS 'This table contains the history of case stages for a litigation. The data in this table is generated automatically by PriorSmart code.';


--
-- Name: COLUMN lit_case_stages.lit_stage_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_case_stages.lit_stage_id IS 'This id corresponds to the lit_stages table. Use lit_stage_id to join to lit_stages to retrieve the name of the stage.';


--
-- Name: COLUMN lit_case_stages.is_current; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_case_stages.is_current IS 'Designates if the given stage is the current stage for the associated litigation. If litigation is closed, this is the stage in which the litigation closed. Comment updated at: 2012-11-06';


--
-- Name: COLUMN lit_case_stages.comment; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_case_stages.comment IS 'Basic explanation why the given case was selected. For debugging purposes only. Comment updated at: 2012-11-06';


--
-- Name: COLUMN lit_case_stages.start_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_case_stages.start_date IS 'Date on which the automated logic determined the case stage to start.  Comment updated at: 2012-11-06';


--
-- Name: COLUMN lit_case_stages.end_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_case_stages.end_date IS 'Date on which the automated logic determined the case stage ended. If the case is still open and ongoing, the end_date is NULL for the current stage. If the case is closed, the end date of the last stage is the closed date of the litigation.  Comment updated at: 2012-11-06';


SET default_tablespace = '';

--
-- Name: lit_stages; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lit_stages (
    id integer NOT NULL,
    name character varying(255) NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    is_default boolean DEFAULT false NOT NULL
);


--
-- Name: TABLE lit_stages; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE lit_stages IS 'Stage the litigation has reached (data01: rpx_stagereached_case.case_stagereached)';


--
-- Name: COLUMN lit_stages.name; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_stages.name IS 'Stage a litigation has reached (data01: rpx_stagereached_case.case_stagereached)

initial_pleadings
scheduling
claim_construction
dispositive_motions
pretrial
trial
posttrial
unknown';


--
-- Name: COLUMN lit_stages.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_stages.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN lit_stages.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_stages.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: COLUMN lit_stages.is_default; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_stages.is_default IS 'When TRUE, the value is the one that should be used for any new record where the value is not known. There should only be one TRUE record in the table.';


--
-- Name: lit_cause_types; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lit_cause_types (
    id integer NOT NULL,
    name character varying(255) NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    is_default boolean DEFAULT false NOT NULL
);


--
-- Name: TABLE lit_cause_types; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE lit_cause_types IS 'Cause for the litigation (docketx: districtdocket.cause)';


--
-- Name: COLUMN lit_cause_types.id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_cause_types.id IS 'Lit Cause ID (key connects to lits)';


--
-- Name: COLUMN lit_cause_types.name; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_cause_types.name IS 'PACER code and name of case type (e.g. "35:271 Patent Infringement")
(docketx: districtdocket.cause)';


--
-- Name: COLUMN lit_cause_types.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_cause_types.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN lit_cause_types.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_cause_types.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: COLUMN lit_cause_types.is_default; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_cause_types.is_default IS 'When TRUE, the value is the one that should be used for any new record where the value is not known. There should only be one TRUE record in the table.';


--
-- Name: lit_relationships_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_relationships_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_relationships; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lit_relationships (
    from_lit_id integer NOT NULL,
    to_lit_id integer NOT NULL,
    lit_relationship_type_id integer NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    id integer DEFAULT nextval('lit_relationships_id_seq'::regclass) NOT NULL,
    lit_family_id integer
);


--
-- Name: TABLE lit_relationships; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE lit_relationships IS 'Table to keep track of transfers, related cases';


--
-- Name: COLUMN lit_relationships.from_lit_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_relationships.from_lit_id IS 'Litigation ID a transfer came from (key to link to lits)';


--
-- Name: COLUMN lit_relationships.to_lit_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_relationships.to_lit_id IS 'Litigation ID a transfer went to (key to link to lits)';


--
-- Name: COLUMN lit_relationships.lit_relationship_type_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_relationships.lit_relationship_type_id IS 'Type of relationship';


--
-- Name: COLUMN lit_relationships.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_relationships.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN lit_relationships.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_relationships.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: dma_lits_pats_map; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE dma_lits_pats_map (
    id integer NOT NULL,
    lit_id integer NOT NULL,
    patnum character varying(15) NOT NULL,
    start_date date,
    end_date date,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    salesforce_id character varying(18),
    lpm_override boolean DEFAULT false NOT NULL
);


SET default_tablespace = rpx_user_default;

--
-- Name: entity_contacts; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE entity_contacts (
    id integer NOT NULL,
    ent_id integer NOT NULL,
    line1 character varying(255),
    line2 character varying(255),
    line3 character varying(255),
    city character varying(255),
    state_or_province character varying(255),
    postal_code character varying(255),
    country character varying(255),
    url character varying(255),
    phone character varying(255),
    fax character varying(255),
    cell character varying(255),
    email character varying(255),
    notes text,
    lat real,
    lon real,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    last_known_address boolean DEFAULT false
);


--
-- Name: TABLE entity_contacts; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE entity_contacts IS 'Contact information for person or corporation in entity table (docketx: contactdetails & address)';


--
-- Name: COLUMN entity_contacts.ent_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN entity_contacts.ent_id IS 'Entity ID (key to connect to ents)';


--
-- Name: COLUMN entity_contacts.line1; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN entity_contacts.line1 IS 'Street address line 1';


--
-- Name: COLUMN entity_contacts.line2; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN entity_contacts.line2 IS 'Street address line 2';


--
-- Name: COLUMN entity_contacts.line3; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN entity_contacts.line3 IS 'Street address line 3';


--
-- Name: COLUMN entity_contacts.city; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN entity_contacts.city IS 'City for mailing address';


--
-- Name: COLUMN entity_contacts.state_or_province; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN entity_contacts.state_or_province IS 'State or Province for street address. Two character abbreviation.';


--
-- Name: COLUMN entity_contacts.postal_code; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN entity_contacts.postal_code IS 'Zip code or postal code for mailing address. US codes are 5 digit zip or 10 digit zip+4.';


--
-- Name: COLUMN entity_contacts.country; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN entity_contacts.country IS 'Country for mailing address';


--
-- Name: COLUMN entity_contacts.url; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN entity_contacts.url IS 'Web address (URL) for a company in ents. This is not an email address.';


--
-- Name: COLUMN entity_contacts.phone; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN entity_contacts.phone IS 'Phone number. Format for most US numbers is (555) 555-5555, but not all are in that form.';


--
-- Name: COLUMN entity_contacts.fax; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN entity_contacts.fax IS 'Fax number. Format for most US numbers is (555) 555-5555, but not all are in that form.';


--
-- Name: COLUMN entity_contacts.cell; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN entity_contacts.cell IS 'Cell phone number. Format for most US numbers is (555) 555-5555, but not all are in that form.';


--
-- Name: COLUMN entity_contacts.email; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN entity_contacts.email IS 'Email address.';


--
-- Name: COLUMN entity_contacts.notes; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN entity_contacts.notes IS 'Notes for the entity. Free text.';


--
-- Name: COLUMN entity_contacts.lat; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN entity_contacts.lat IS 'Latitude of geocoded address.';


--
-- Name: COLUMN entity_contacts.lon; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN entity_contacts.lon IS 'Longitude of gencoded address.';


--
-- Name: COLUMN entity_contacts.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN entity_contacts.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN entity_contacts.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN entity_contacts.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


SET default_tablespace = '';

--
-- Name: pat_claim_relationships; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pat_claim_relationships (
    id integer NOT NULL,
    pat_claims_id integer NOT NULL,
    depends_on integer NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL
);


--
-- Name: lit_campaigns_litigation_vw; Type: VIEW; Schema: core; Owner: -
--

CREATE VIEW lit_campaigns_litigation_vw AS
 SELECT DISTINCT c.id AS campaign_id,
    cl.lit_id,
    ll.filed_date AS lit_start_date,
    ll.closed_date AS lit_end_date,
    substr((ll.case_key)::text, 1, ("position"((ll.case_key)::text, 'e-'::text) - 1)) AS district_court,
    ll.title AS lit_title,
    ms.name AS market_sector_name,
    c.start_date AS campaign_start_date,
    c.closed_date AS campaign_closed_date
   FROM ((((lit_campaigns.campaigns c
     JOIN lit_campaigns.campaign_lits cl ON ((cl.campaign_id = c.id)))
     JOIN lits ll ON ((ll.id = cl.lit_id)))
     JOIN lit_annotations la ON ((ll.id = la.lit_id)))
     JOIN market_sector_types ms ON ((la.market_sector_type_id = ms.id)));


--
-- Name: court_details_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE court_details_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: court_details; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE court_details (
    id integer DEFAULT nextval('court_details_id_seq'::regclass) NOT NULL,
    ent_id integer NOT NULL,
    pacer_label character varying(255),
    district_court_name character varying(255) NOT NULL,
    district_court_acronym character varying(5) NOT NULL,
    office_name character varying(255),
    office_number integer,
    is_headoffice boolean DEFAULT false NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    court_abbrev character varying(100),
    court_abbrev_clean character varying(100),
    city character varying(255),
    state character varying(255),
    latitude real,
    longitude real
);


--
-- Name: TABLE court_details; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE court_details IS 'District court office details (docketx: divisionaloffice)';


--
-- Name: COLUMN court_details.ent_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN court_details.ent_id IS 'Entity id for the district court (key to link to ents)';


--
-- Name: COLUMN court_details.pacer_label; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN court_details.pacer_label IS 'Name used by PACER to specify the office (docketx: divisionaloffice.pacerlabel)';


--
-- Name: COLUMN court_details.district_court_name; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN court_details.district_court_name IS 'Full district court name (docketx: divisionaloffice.districtcourtname)';


--
-- Name: COLUMN court_details.district_court_acronym; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN court_details.district_court_acronym IS '4 or 5 character abbreviation for the district court, upper case. (docketx: divisionaloffice.districtcourtacronym)';


--
-- Name: COLUMN court_details.office_name; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN court_details.office_name IS 'Name of the individual office of the district court. (docketx: divisionaloffice.officename)';


--
-- Name: COLUMN court_details.office_number; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN court_details.office_number IS 'Office number for district court office, -1 means no office specified (docketx: divisionaloffice.officenumber)';


--
-- Name: COLUMN court_details.is_headoffice; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN court_details.is_headoffice IS 'Is the head office for parent district court? (docketx: divisionaloffice.headofficeflag)';


--
-- Name: COLUMN court_details.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN court_details.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN court_details.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN court_details.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: acq_counter_party_temp; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE acq_counter_party_temp (
    acquisition_id double precision,
    seller_sf_account_name text,
    seller_sf_account_id text,
    counter_party_type_id double precision,
    counter_party_type_name text
);


--
-- Name: alias_contacts; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE alias_contacts (
    id integer NOT NULL,
    alias_id integer NOT NULL,
    line1 character varying(255),
    line2 character varying(255),
    line3 character varying(255),
    city character varying(255),
    state_or_province character varying(255),
    postal_code character varying(255),
    country character varying(255),
    url character varying(255),
    phone character varying(255),
    fax character varying(255),
    cell character varying(255),
    email character varying(255),
    notes text,
    lat real,
    lon real,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    line4 character varying(255),
    address_md5 text
);


--
-- Name: TABLE alias_contacts; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE alias_contacts IS 'Contact information for person or corporation in aliases table (docketx: contactdetails & address)';


--
-- Name: COLUMN alias_contacts.alias_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN alias_contacts.alias_id IS 'Alias ID (key to connect to aliases)';


--
-- Name: COLUMN alias_contacts.line1; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN alias_contacts.line1 IS 'Street address line 1';


--
-- Name: COLUMN alias_contacts.line2; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN alias_contacts.line2 IS 'Street address line 2';


--
-- Name: COLUMN alias_contacts.line3; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN alias_contacts.line3 IS 'Street address line 3';


--
-- Name: COLUMN alias_contacts.city; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN alias_contacts.city IS 'City for mailing address';


--
-- Name: COLUMN alias_contacts.state_or_province; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN alias_contacts.state_or_province IS 'State or Province for street address. Two character abbreviation.';


--
-- Name: COLUMN alias_contacts.postal_code; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN alias_contacts.postal_code IS 'Zip code or postal code for mailing address. US codes are 5 digit zip or 10 digit zip+4.';


--
-- Name: COLUMN alias_contacts.country; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN alias_contacts.country IS 'Country for mailing address';


--
-- Name: COLUMN alias_contacts.url; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN alias_contacts.url IS 'Web address (URL) for a company in aliases. This is not an email address.';


--
-- Name: COLUMN alias_contacts.phone; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN alias_contacts.phone IS 'Phone number. Format for most US numbers is (555) 555-5555, but not all are in that form.';


--
-- Name: COLUMN alias_contacts.fax; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN alias_contacts.fax IS 'Fax number. Format for most US numbers is (555) 555-5555, but not all are in that form.';


--
-- Name: COLUMN alias_contacts.cell; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN alias_contacts.cell IS 'Cell phone number. Format for most US numbers is (555) 555-5555, but not all are in that form.';


--
-- Name: COLUMN alias_contacts.email; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN alias_contacts.email IS 'Email address.';


--
-- Name: COLUMN alias_contacts.notes; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN alias_contacts.notes IS 'Notes for the alias. Free text.';


--
-- Name: COLUMN alias_contacts.lat; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN alias_contacts.lat IS 'latitude of geocoded address.';


--
-- Name: COLUMN alias_contacts.lon; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN alias_contacts.lon IS 'longitude of gencoded address.';


--
-- Name: COLUMN alias_contacts.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN alias_contacts.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN alias_contacts.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN alias_contacts.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: alias_contacts_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE alias_contacts_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: alias_contacts_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE alias_contacts_id_seq OWNED BY alias_contacts.id;


--
-- Name: alias_ent_details; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE alias_ent_details (
    alias_id integer,
    ent_id integer,
    ultimate_parent_id integer,
    alias_name character varying(512),
    ent_name character varying,
    ultimate_parent_name character varying,
    id integer NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(255) DEFAULT "current_user"(),
    updated_by character varying(255) DEFAULT "current_user"(),
    is_npe boolean DEFAULT false,
    is_patent_licensing_co boolean DEFAULT false,
    is_defensive_entity boolean DEFAULT false,
    factset_company_id integer,
    is_non_human boolean,
    alias_roles integer[],
    clean_name text,
    ent_type_id integer,
    alias_created_at timestamp without time zone,
    ent_created_at timestamp without time zone,
    soft_ent_id integer,
    soft_ultimate_parent_id integer,
    soft_ultimate_parent_name text,
    sf_account_id character varying(18),
    sf_account_type character varying(255)
);


--
-- Name: alias_ent_details_bkp_soft_ent_updt; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE alias_ent_details_bkp_soft_ent_updt (
    alias_id integer,
    ent_id integer,
    ultimate_parent_id integer,
    alias_name character varying(512),
    ent_name character varying,
    ultimate_parent_name character varying,
    id integer,
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    created_by character varying(255),
    updated_by character varying(255),
    is_npe boolean,
    is_patent_licensing_co boolean,
    is_defensive_entity boolean,
    factset_company_id integer,
    is_non_human boolean,
    alias_roles integer[],
    clean_name text,
    ent_type_id integer,
    alias_created_at timestamp without time zone,
    ent_created_at timestamp without time zone,
    soft_ent_id integer
);


--
-- Name: alias_ent_details_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE alias_ent_details_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: alias_ent_details_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE alias_ent_details_id_seq OWNED BY alias_ent_details.id;


SET default_tablespace = rpx_user_default;

--
-- Name: alias_roles; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE alias_roles (
    id integer NOT NULL,
    name character varying(32),
    source_tables text[],
    created_at timestamp with time zone DEFAULT now(),
    created_by character varying(32) DEFAULT "current_user"(),
    sql_filter text
);


--
-- Name: alias_roles_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE alias_roles_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: alias_roles_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE alias_roles_id_seq OWNED BY alias_roles.id;


--
-- Name: aliases_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE aliases_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: aliases_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE aliases_id_seq OWNED BY aliases.id;


--
-- Name: all_lits.v_cost_data_raw_qa-vtc; Type: VIEW; Schema: core; Owner: -
--

CREATE VIEW "all_lits.v_cost_data_raw_qa-vtc" AS
 SELECT t.dim_litigation_id,
    t.dim_defendant_id,
    t.ent_id,
    (t.revenue)::numeric AS revenue,
    (t.legal_cost)::numeric AS legal_cost,
    (t.settlement_cost)::numeric AS settlement_cost,
    t.production_area,
    t.company_name,
    t.dim_litigation_cost_data_id
   FROM ( SELECT fl.lit_id AS dim_litigation_id,
            ( SELECT lit_defendants.id
                   FROM all_lits.lit_defendants
                  WHERE (lit_defendants.defendant_ent_id = fl.ent_id)
                 LIMIT 1) AS dim_defendant_id,
            fl.ent_id,
            fl.revenue,
            fl.legal_cost,
            fl.settlement_cost,
            fl.production_area,
            fl.company_name,
            row_number() OVER () AS dim_litigation_cost_data_id
           FROM ( SELECT e.name AS company_name,
                    a.ent_id,
                    50000 AS revenue,
                    500 AS legal_cost,
                    100000 AS settlement_cost,
                    'iTunes, iPod, Mac'::character varying AS production_area,
                    rank() OVER (PARTITION BY l.case_key ORDER BY a.ent_id) AS rid,
                    l.id AS lit_id
                   FROM lits l,
                    lit_parties lp,
                    aliases a,
                    ents e
                  WHERE ((a.ent_id = 63973) AND (l.id = lp.lit_id) AND (lp.alias_id = a.id) AND ((lp.dj_party_normalized_type)::text = 'defendant'::text) AND (e.id = a.ent_id) AND (EXISTS ( SELECT 1
                           FROM ((lit_annotations la
                             JOIN lit_curated_cause_types lcct ON ((lcct.id = la.lit_curated_cause_type_id)))
                             JOIN lit_types lt ON ((la.lit_type_id = lt.id)))
                          WHERE ((lcct.id = ANY (ARRAY[1, 7, 8])) AND (lt.id = ANY (ARRAY[1, 4, 7, 11, 16, 23, 24])) AND (la.lit_id = lp.lit_id)))))) fl
          WHERE (fl.rid = 1)
         LIMIT 100) t;


--
-- Name: assignees_aliases_map_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE assignees_aliases_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: assignees_aliases_map_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE assignees_aliases_map_id_seq OWNED BY assignees_aliases_map.id;


--
-- Name: assignors_aliases_map_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE assignors_aliases_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: assignors_aliases_map_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE assignors_aliases_map_id_seq OWNED BY assignors_aliases_map.id;


SET default_tablespace = '';

--
-- Name: court_abbreviations; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE court_abbreviations (
    id integer NOT NULL,
    court_name character varying(255),
    court_abbrev character varying(100),
    court_abbrev_clean character varying(100),
    created_at timestamp(6) without time zone DEFAULT now() NOT NULL,
    updated_at timestamp(6) without time zone DEFAULT now() NOT NULL
);


--
-- Name: court_abbreviations_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE court_abbreviations_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: court_abbreviations_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE court_abbreviations_id_seq OWNED BY court_abbreviations.id;


SET default_tablespace = rpx_user_default;

--
-- Name: cpc_descriptions; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE cpc_descriptions (
    id integer NOT NULL,
    code character varying(20) NOT NULL,
    code_type character varying(50) NOT NULL,
    code_desc character varying(1000),
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now()
);


--
-- Name: cpc_descriptions_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE cpc_descriptions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cpc_descriptions_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE cpc_descriptions_id_seq OWNED BY cpc_descriptions.id;


--
-- Name: deleted_entities_with_rpx_account; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE deleted_entities_with_rpx_account (
    id integer,
    ent_type_id integer,
    name character varying,
    core_name character varying(255),
    fingerprint character varying(255),
    lower_stripped character varying(255),
    deactivation_date date,
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    created_by character varying(255),
    updated_by character varying(255),
    rpx_account_id character varying(30),
    ultimate_parent_id integer,
    rollup_parent_id integer
);


--
-- Name: dma_lit_annotations_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE dma_lit_annotations_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: dma_lit_annotations_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE dma_lit_annotations_id_seq OWNED BY dma_lit_annotations.id;


--
-- Name: dma_lits_pats_map_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE dma_lits_pats_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: dma_lits_pats_map_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE dma_lits_pats_map_id_seq OWNED BY dma_lits_pats_map.id;


--
-- Name: docket_entries_deleted; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE docket_entries_deleted (
    id integer,
    lit_id integer,
    docketx_id character varying(32),
    date_entered date,
    date_filed date,
    docket_text text,
    entry_number integer,
    row_number integer,
    original_docket_text text,
    updated_at timestamp(6) without time zone,
    created_at timestamp(6) without time zone,
    is_mixed_action boolean,
    event text,
    category character varying(255)
);


--
-- Name: docket_entry_documents_map_deleted; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE docket_entry_documents_map_deleted (
    id integer,
    docketx_id character varying(32),
    lit_document_id integer,
    docket_entry_id integer,
    is_main boolean,
    updated_at timestamp(6) without time zone,
    created_at timestamp(6) without time zone
);


--
-- Name: duns_details_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE duns_details_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ent_advanced_relationship_types_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ent_advanced_relationship_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ent_advanced_relationship_types; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE ent_advanced_relationship_types (
    id integer DEFAULT nextval('ent_advanced_relationship_types_id_seq'::regclass) NOT NULL,
    name character varying(100) NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    created_at timestamp(6) without time zone NOT NULL
);


--
-- Name: ent_advanced_relationships_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ent_advanced_relationships_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ent_advanced_relationships; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE ent_advanced_relationships (
    id integer DEFAULT nextval('ent_advanced_relationships_id_seq'::regclass) NOT NULL,
    ent_id integer NOT NULL,
    related_ent_id integer NOT NULL,
    start_date date,
    end_date date,
    ent_advanced_relationship_type_id integer NOT NULL,
    description text,
    updated_at timestamp(6) without time zone NOT NULL,
    created_at timestamp(6) without time zone NOT NULL,
    updated_by character varying(255) DEFAULT "current_user"() NOT NULL,
    created_by character varying(255) DEFAULT "current_user"() NOT NULL,
    title text
);


--
-- Name: ent_advanced_relationships_temporal_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ent_advanced_relationships_temporal_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ent_advanced_relationships_temporal; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE ent_advanced_relationships_temporal (
    id integer DEFAULT nextval('ent_advanced_relationships_temporal_id_seq'::regclass) NOT NULL,
    ent_id integer NOT NULL,
    related_ent_id integer NOT NULL,
    start_date date,
    end_date date,
    ent_advanced_relationship_type_id integer NOT NULL,
    description text,
    updated_at timestamp(6) without time zone NOT NULL,
    created_at timestamp(6) without time zone NOT NULL,
    updated_by character varying(255) NOT NULL,
    created_by character varying(255) NOT NULL,
    title text
);


--
-- Name: ent_co_subtypes_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ent_co_subtypes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ent_npe_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ent_npe_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


SET default_tablespace = '';

--
-- Name: ent_relationship_types; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE ent_relationship_types (
    id integer NOT NULL,
    name character varying(100) NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    is_default boolean DEFAULT false NOT NULL
);


--
-- Name: TABLE ent_relationship_types; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE ent_relationship_types IS 'Types to describe ent_relationships (Parent, Attorney at, etc.)';


--
-- Name: COLUMN ent_relationship_types.name; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ent_relationship_types.name IS 'Type of relationship between entities. (Parent, Attorney at, Judge for, etc.)';


--
-- Name: COLUMN ent_relationship_types.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ent_relationship_types.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN ent_relationship_types.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ent_relationship_types.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: COLUMN ent_relationship_types.is_default; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ent_relationship_types.is_default IS 'When TRUE, the value is the one that should be used for any new record where the value is not known. There should only be one TRUE record in the table.';


--
-- Name: ent_relationship_types_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ent_relationship_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ent_relationship_types_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE ent_relationship_types_id_seq OWNED BY ent_relationship_types.id;


--
-- Name: ent_relationships; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE ent_relationships (
    id integer NOT NULL,
    ent_id integer NOT NULL,
    related_ent_id integer NOT NULL,
    ent_relationship_type_id integer NOT NULL,
    description text NOT NULL,
    start_date date,
    end_date date,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    created_by character varying DEFAULT "current_user"(),
    updated_by character varying DEFAULT "current_user"()
);


--
-- Name: COLUMN ent_relationships.ent_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ent_relationships.ent_id IS 'Entity ID for one part of the relationship (key to link to ents)';


--
-- Name: COLUMN ent_relationships.related_ent_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ent_relationships.related_ent_id IS 'Entity ID for other part of the relationship (key to link to ents)';


--
-- Name: COLUMN ent_relationships.ent_relationship_type_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ent_relationships.ent_relationship_type_id IS 'Relationship type ID (key to link to ent_relationship_types)';


--
-- Name: COLUMN ent_relationships.description; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ent_relationships.description IS 'Descriptive text about this relationship. Free text.';


--
-- Name: COLUMN ent_relationships.start_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ent_relationships.start_date IS 'Date the relationship started';


--
-- Name: COLUMN ent_relationships.end_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ent_relationships.end_date IS 'Date the relationship ended';


--
-- Name: COLUMN ent_relationships.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ent_relationships.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN ent_relationships.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ent_relationships.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: ent_relationships_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ent_relationships_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ent_relationships_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE ent_relationships_id_seq OWNED BY ent_relationships.id;


SET default_tablespace = rpx_user_default;

--
-- Name: ent_relationships_temporal; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE ent_relationships_temporal (
    id integer NOT NULL,
    ent_id integer NOT NULL,
    related_ent_id integer NOT NULL,
    ent_relationship_type_id integer NOT NULL,
    description text NOT NULL,
    start_date date,
    end_date date,
    updated_at timestamp(6) without time zone NOT NULL,
    created_at timestamp(6) without time zone NOT NULL
);


--
-- Name: ent_relationships_temporal_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ent_relationships_temporal_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ent_relationships_temporal_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE ent_relationships_temporal_id_seq OWNED BY ent_relationships_temporal.id;


--
-- Name: ent_types_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ent_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ent_types_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE ent_types_id_seq OWNED BY ent_types.id;


--
-- Name: entity_contacts_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE entity_contacts_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: entity_contacts_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE entity_contacts_id_seq OWNED BY entity_contacts.id;


--
-- Name: ents_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ents_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ents_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE ents_id_seq OWNED BY ents.id;


--
-- Name: ents_market_sector_types_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ents_market_sector_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


SET default_tablespace = '';

--
-- Name: ents_market_sector_types; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE ents_market_sector_types (
    ent_id integer NOT NULL,
    market_sector_type_id integer NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    id integer DEFAULT nextval('ents_market_sector_types_id_seq'::regclass) NOT NULL
);


--
-- Name: TABLE ents_market_sector_types; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE ents_market_sector_types IS 'Market sector type that applys to an entity. Entities may have multiple market sectors.';


--
-- Name: COLUMN ents_market_sector_types.ent_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ents_market_sector_types.ent_id IS 'Entity ID (key connects to ents)';


--
-- Name: COLUMN ents_market_sector_types.market_sector_type_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ents_market_sector_types.market_sector_type_id IS 'Market sector type ID (key connects to market_sector_types)';


--
-- Name: COLUMN ents_market_sector_types.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ents_market_sector_types.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN ents_market_sector_types.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN ents_market_sector_types.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: file_types; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE file_types (
    id integer NOT NULL,
    description character varying(50),
    is_default boolean,
    updated_at timestamp without time zone,
    created_at timestamp without time zone
);


--
-- Name: file_types_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE file_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: file_types_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE file_types_id_seq OWNED BY file_types.id;


--
-- Name: foreign_application_priority_docs_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE foreign_application_priority_docs_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: foreign_application_priority_docs; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE foreign_application_priority_docs (
    pat_id integer NOT NULL,
    document_id character varying(255) NOT NULL,
    country character varying(255) NOT NULL,
    document_date date NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    id integer DEFAULT nextval('foreign_application_priority_docs_id_seq'::regclass) NOT NULL
);


--
-- Name: invention_owners; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE invention_owners (
    id integer NOT NULL,
    invention_id integer,
    owner character varying,
    alias_ids integer[],
    ownership_start date,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying DEFAULT "current_user"(),
    updated_by character varying DEFAULT "current_user"()
);


--
-- Name: invention_owners_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE invention_owners_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: invention_owners_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE invention_owners_id_seq OWNED BY invention_owners.id;


--
-- Name: ipc_classes; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE ipc_classes (
    id integer NOT NULL,
    code character varying(3) NOT NULL,
    ipc_section_id integer,
    description character varying(3000),
    job_id integer,
    updated_at timestamp without time zone DEFAULT now(),
    created_at timestamp without time zone DEFAULT now()
);


--
-- Name: ipc_classes_hist; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE ipc_classes_hist (
    id integer NOT NULL,
    ipc_class_id integer,
    code character varying(3) NOT NULL,
    ipc_section_id integer,
    description character varying(3000),
    transaction_type character varying(10) NOT NULL,
    xml_edition character varying(50),
    job_id integer,
    created_at timestamp(6) without time zone DEFAULT now(),
    updated_at timestamp(6) without time zone DEFAULT now(),
    effective_date tsrange
);


--
-- Name: ipc_classes_hist_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ipc_classes_hist_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ipc_classes_hist_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE ipc_classes_hist_id_seq OWNED BY ipc_classes_hist.id;


--
-- Name: ipc_classes_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ipc_classes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ipc_classes_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE ipc_classes_id_seq OWNED BY ipc_classes.id;


--
-- Name: ipc_groups; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE ipc_groups (
    id integer NOT NULL,
    code character varying(8) NOT NULL,
    orig_code character varying(14) NOT NULL,
    ipc_section_id integer,
    ipc_class_id integer,
    ipc_subclass_id integer,
    description character varying(5000),
    job_id integer,
    updated_at timestamp without time zone DEFAULT now(),
    created_at timestamp without time zone DEFAULT now()
);


--
-- Name: ipc_groups_hist; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE ipc_groups_hist (
    id integer NOT NULL,
    ipc_group_id integer,
    code character varying(8) NOT NULL,
    orig_code character varying(14) NOT NULL,
    ipc_section_id integer,
    ipc_class_id integer,
    ipc_subclass_id integer,
    description character varying(5000),
    transaction_type character varying(10) NOT NULL,
    xml_edition character varying(50),
    job_id integer,
    created_at timestamp(6) without time zone DEFAULT now(),
    updated_at timestamp(6) without time zone DEFAULT now(),
    effective_date tsrange
);


--
-- Name: ipc_groups_hist_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ipc_groups_hist_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ipc_groups_hist_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE ipc_groups_hist_id_seq OWNED BY ipc_groups_hist.id;


--
-- Name: ipc_groups_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ipc_groups_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ipc_groups_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE ipc_groups_id_seq OWNED BY ipc_groups.id;


--
-- Name: ipc_sections; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE ipc_sections (
    id integer NOT NULL,
    code character varying(1) NOT NULL,
    description character varying(1000),
    job_id integer,
    updated_at timestamp without time zone DEFAULT now(),
    created_at timestamp without time zone DEFAULT now()
);


--
-- Name: ipc_sections_hist; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE ipc_sections_hist (
    id integer NOT NULL,
    ipc_section_id integer,
    code character varying(1) NOT NULL,
    description character varying(1000),
    transaction_type character varying(10) NOT NULL,
    xml_edition character varying(50),
    job_id integer,
    created_at timestamp(6) without time zone DEFAULT now(),
    updated_at timestamp(6) without time zone DEFAULT now(),
    effective_date tsrange
);


--
-- Name: ipc_sections_hist_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ipc_sections_hist_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ipc_sections_hist_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE ipc_sections_hist_id_seq OWNED BY ipc_sections_hist.id;


--
-- Name: ipc_sections_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ipc_sections_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ipc_sections_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE ipc_sections_id_seq OWNED BY ipc_sections.id;


--
-- Name: ipc_subclasses; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE ipc_subclasses (
    id integer NOT NULL,
    code character varying(4) NOT NULL,
    ipc_class_id integer,
    ipc_section_id integer,
    description character varying(5000),
    job_id integer,
    updated_at timestamp without time zone DEFAULT now(),
    created_at timestamp without time zone DEFAULT now()
);


--
-- Name: ipc_subclasses_hist; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE ipc_subclasses_hist (
    id integer NOT NULL,
    ipc_subclass_id integer,
    code character varying(4) NOT NULL,
    ipc_class_id integer,
    ipc_section_id integer,
    description character varying(5000),
    transaction_type character varying(10) NOT NULL,
    xml_edition character varying(50),
    job_id integer,
    created_at timestamp(6) without time zone DEFAULT now(),
    updated_at timestamp(6) without time zone DEFAULT now(),
    effective_date tsrange
);


--
-- Name: ipc_subclasses_hist_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ipc_subclasses_hist_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ipc_subclasses_hist_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE ipc_subclasses_hist_id_seq OWNED BY ipc_subclasses_hist.id;


--
-- Name: ipc_subclasses_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ipc_subclasses_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ipc_subclasses_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE ipc_subclasses_id_seq OWNED BY ipc_subclasses.id;


--
-- Name: ipc_subgroups; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE ipc_subgroups (
    id integer NOT NULL,
    code character varying(14) NOT NULL,
    code_docdb character varying(14) NOT NULL,
    orig_code character varying(14) NOT NULL,
    ipc_section_id integer,
    ipc_class_id integer,
    ipc_subclass_id integer,
    ipc_group_id integer,
    ipc_edition character varying(100),
    parent_subgroup_id integer,
    description character varying(5000),
    job_id integer,
    updated_at timestamp without time zone DEFAULT now(),
    created_at timestamp without time zone DEFAULT now()
);


--
-- Name: ipc_subgroups_hist; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE ipc_subgroups_hist (
    id integer NOT NULL,
    ipc_subgroup_id integer,
    code character varying(14) NOT NULL,
    code_docdb character varying(14) NOT NULL,
    orig_code character varying(14) NOT NULL,
    ipc_section_id integer,
    ipc_class_id integer,
    ipc_subclass_id integer,
    ipc_group_id integer,
    ipc_edition character varying(100),
    parent_subgroup_id integer,
    description character varying(5000),
    transaction_type character varying(10) NOT NULL,
    xml_edition character varying(50),
    job_id integer,
    created_at timestamp(6) without time zone DEFAULT now(),
    updated_at timestamp(6) without time zone DEFAULT now(),
    effective_date tsrange
);


--
-- Name: ipc_subgroups_hist_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ipc_subgroups_hist_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ipc_subgroups_hist_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE ipc_subgroups_hist_id_seq OWNED BY ipc_subgroups_hist.id;


--
-- Name: ipc_subgroups_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ipc_subgroups_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ipc_subgroups_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE ipc_subgroups_id_seq OWNED BY ipc_subgroups.id;


--
-- Name: ipc_transfer; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE ipc_transfer (
    id integer NOT NULL,
    from_code character varying(14) NOT NULL,
    to_code character varying(14) NOT NULL,
    kind_code character varying(1),
    compilation_file_name character varying(100) NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL
);


--
-- Name: ipc_transfer_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ipc_transfer_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ipc_transfer_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE ipc_transfer_id_seq OWNED BY ipc_transfer.id;


--
-- Name: judge_assignment_types; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE judge_assignment_types (
    id integer NOT NULL,
    name character varying(255) NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    is_default boolean DEFAULT false NOT NULL
);


--
-- Name: TABLE judge_assignment_types; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE judge_assignment_types IS 'Assignments for judges. (docketx: caseassignment)';


--
-- Name: COLUMN judge_assignment_types.id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN judge_assignment_types.id IS 'Assignment type ID (key connects to lit_judges_map)';


--
-- Name: COLUMN judge_assignment_types.name; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN judge_assignment_types.name IS 'Name/description of assignment (ASSIGNED, REFFERED) (docketx:  caseassignment.assignmenttype)';


--
-- Name: COLUMN judge_assignment_types.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN judge_assignment_types.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN judge_assignment_types.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN judge_assignment_types.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: COLUMN judge_assignment_types.is_default; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN judge_assignment_types.is_default IS 'When TRUE, the value is the one that should be used for any new record where the value is not known. There should only be one TRUE record in the table.';


--
-- Name: judge_assignment_types_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE judge_assignment_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: judge_assignment_types_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE judge_assignment_types_id_seq OWNED BY judge_assignment_types.id;


--
-- Name: lawfirm_aliases_to_map_tmp; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lawfirm_aliases_to_map_tmp (
    lawfirm_alias_id bigint,
    lawfirm_core_name character varying,
    lawfirm_alias_ids_to_map bigint[],
    lawfirm_ent_id integer,
    lawfirm_ent_ids integer[],
    lawfirm_ent_id_cnt bigint,
    cluster_lawfirm_alias_ids bigint[],
    alias_id_to_create_ent_id bigint,
    proposed_ent_name text
);


--
-- Name: lawfirm_core_names_tmp_ds_5676; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lawfirm_core_names_tmp_ds_5676 (
    lawfirm_alias_id bigint,
    lawfirm_ent_id integer,
    lawfirm_alias_name character varying(512),
    lawfirm_core_name character varying,
    lawfirm_sources text[]
);


--
-- Name: lawfirm_ent_core_names_ds_5676; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lawfirm_ent_core_names_ds_5676 (
    lawfirm_ent_id integer,
    ent_lawfirm_core_name character varying,
    lawfirm_sources text[]
);


--
-- Name: lawfirm_maps; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lawfirm_maps (
    lawfirm_alias_id bigint,
    lawfirm_core_name character varying,
    sim_lawfirm_alias_id bigint,
    sim_lawfirm_core_name character varying,
    sim_score real
);


SET default_tablespace = rpx_user_default;

--
-- Name: lit_annotations_deleted; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE lit_annotations_deleted (
    lit_id integer,
    rpx_lit_id character varying(16),
    lit_type_id integer,
    is_npe_suit boolean,
    is_dj boolean,
    market_sector_type_id integer,
    lit_classification_type_id integer,
    lit_stage_id integer,
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    is_abandon boolean,
    ad_hoc_1 text,
    ad_hoc_2 text,
    ad_hoc_3 text,
    ad_hoc_4 text,
    ad_hoc_5 text,
    lit_curated_cause_type_id integer,
    id integer,
    is_ncl_suit boolean,
    is_dcl_corrected boolean,
    display_on_portal boolean,
    portal_display_override boolean
);


--
-- Name: lit_annotations_lits_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_annotations_lits_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_annotations_lits_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE lit_annotations_lits_id_seq OWNED BY lit_annotations.lit_id;


SET default_tablespace = '';

--
-- Name: lit_party_types; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lit_party_types (
    id integer NOT NULL,
    name character varying(255) NOT NULL,
    created_at timestamp without time zone NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    is_default boolean DEFAULT false NOT NULL,
    lit_party_normalized_type character varying(255) DEFAULT 'unknown'::character varying
);


--
-- Name: TABLE lit_party_types; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE lit_party_types IS 'Litigation party type (defendant, plaintiff, etc.) (docketx: representation.litigationtype)';


--
-- Name: COLUMN lit_party_types.id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_party_types.id IS 'Lit party type ID (1-143; key connects to lit_parties)';


--
-- Name: COLUMN lit_party_types.name; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_party_types.name IS 'Name of lit party type (e.g. plaintiff, defendant, counter defendant, etc.) (docketx: representation.litigationtype)';


--
-- Name: COLUMN lit_party_types.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_party_types.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: COLUMN lit_party_types.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_party_types.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN lit_party_types.is_default; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_party_types.is_default IS 'When TRUE, the value is the one that should be used for any new record where the value is not known. There should only be one TRUE record in the table.';


--
-- Name: lit_campaigns_entity_vw; Type: VIEW; Schema: core; Owner: -
--

CREATE VIEW lit_campaigns_entity_vw AS
 SELECT DISTINCT c.id AS campaign_id,
    e1.id,
    e1.name AS ent_name,
    pt.name,
    e1.ultimate_parent_id,
    e2.name AS ult_parent_name,
    min(COALESCE(lp.start_date, ll.filed_date)) AS start_date,
    max(lp.end_date) AS terminate_date,
    c.start_date AS campaign_start_date,
    c.closed_date AS campaign_closed_date
   FROM (((((((lit_campaigns.campaigns c
     JOIN lit_campaigns.campaign_lits cl ON ((cl.campaign_id = c.id)))
     JOIN lits ll ON ((ll.id = cl.lit_id)))
     JOIN lit_parties lp ON ((lp.lit_id = cl.lit_id)))
     JOIN lit_party_types pt ON ((lp.lit_party_type_id = pt.id)))
     JOIN aliases a ON ((a.id = lp.alias_id)))
     JOIN ents e1 ON ((e1.id = a.ent_id)))
     JOIN ents e2 ON ((e2.id = e1.ultimate_parent_id)))
  GROUP BY c.id, e1.id, e1.name, pt.name, e1.ultimate_parent_id, e2.name, c.start_date, c.closed_date;


--
-- Name: lit_campaigns_patent_vw; Type: VIEW; Schema: core; Owner: -
--

CREATE VIEW lit_campaigns_patent_vw AS
 SELECT cp.campaign_id,
    p.patnum,
    p.stripped_patnum,
    p.id AS pat_id,
    p.issue_date,
    p.title,
    cp.pat_family_id
   FROM (lit_campaigns.campaign_patents cp
     JOIN pats p ON (((p.stripped_patnum)::text = (cp.stripped_patnum)::text)))
  WHERE ((p.country_code)::text = 'US'::text)
  ORDER BY cp.campaign_id;


--
-- Name: lit_relationship_types; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lit_relationship_types (
    id integer NOT NULL,
    name character varying(255) NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    is_default boolean DEFAULT false NOT NULL
);


--
-- Name: TABLE lit_relationship_types; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE lit_relationship_types IS 'Types of relationships between litigations (transfer, etc.)';


--
-- Name: COLUMN lit_relationship_types.name; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_relationship_types.name IS 'Type of relationship (transfer, etc.)';


--
-- Name: COLUMN lit_relationship_types.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_relationship_types.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN lit_relationship_types.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_relationship_types.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: COLUMN lit_relationship_types.is_default; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_relationship_types.is_default IS 'When TRUE, the value is the one that should be used for any new record where the value is not known. There should only be one TRUE record in the table.';


--
-- Name: lit_campaigns_vw; Type: VIEW; Schema: core; Owner: -
--

CREATE VIEW lit_campaigns_vw AS
 SELECT DISTINCT c.id AS campaign_id,
    array_length(lp1.plaintiff_ult_parent_ids, 1) AS total_plaintiff_ult_parents_ids,
    array_length(lp1.stripped_patnums, 1) AS total_patents_in_campaign,
    array_length(a.defendant_ult_parent_ids, 1) AS total_defendat_ult_parents_ids,
        CASE
            WHEN (c.closed_date IS NULL) THEN false
            ELSE true
        END AS is_open,
    to_char((COALESCE((c.closed_date)::timestamp with time zone, now()) - (c.start_date)::timestamp with time zone), 'dd'::text) AS length_of_campaign_in_days,
    rc.transfer_count,
    rc.severance_count,
    rc.consolidation_count,
    ov.original_venue
   FROM (((((lit_campaigns.campaigns c
     JOIN lit_campaigns.campaign_lits cl ON ((cl.campaign_id = c.id)))
     JOIN ( SELECT array_agg(DISTINCT a_1.uu) AS stripped_patnums,
            array_agg(DISTINCT a_1.uu1) AS plaintiff_ult_parent_ids,
            a_1.campaign_id
           FROM ( SELECT unnest(lp.stripped_patnums) AS uu,
                    unnest(lp.plaintiff_ult_parent_ids) AS uu1,
                    c1.campaign_id
                   FROM (lit_campaigns.lit_info_lookup lp
                     JOIN lit_campaigns.campaign_lits c1 ON ((c1.lit_id = lp.lit_id)))) a_1
          GROUP BY a_1.campaign_id) lp1 ON ((lp1.campaign_id = c.id)))
     JOIN ( SELECT array_agg(DISTINCT e.ultimate_parent_id) AS defendant_ult_parent_ids,
            p.lit_id
           FROM ((((ents e
             JOIN aliases a_1 ON ((a_1.ent_id = e.id)))
             JOIN lit_parties p ON ((p.alias_id = a_1.id)))
             JOIN lit_party_types t ON ((t.id = p.lit_party_type_id)))
             JOIN lits l ON ((p.lit_id = l.id)))
          WHERE (((t.name)::text = 'defendant'::text) AND (e.ultimate_parent_id IS NOT NULL))
          GROUP BY e.ultimate_parent_id, p.lit_id) a ON ((a.lit_id = cl.lit_id)))
     JOIN ( SELECT cc.campaign_id,
            sum(
                CASE lrt.name
                    WHEN 'transfer'::text THEN 1
                    ELSE 0
                END) AS transfer_count,
            sum(
                CASE lrt.name
                    WHEN 'severance'::text THEN 1
                    ELSE 0
                END) AS severance_count,
            sum(
                CASE lrt.name
                    WHEN 'consolidation'::text THEN 1
                    ELSE 0
                END) AS consolidation_count
           FROM lits l,
            lit_relationships lr,
            lit_relationship_types lrt,
            lit_campaigns.campaign_lits cc
          WHERE ((lr.from_lit_id = l.id) AND (lr.lit_relationship_type_id = lrt.id) AND (cc.lit_id = l.id))
          GROUP BY cc.campaign_id) rc ON ((rc.campaign_id = c.id)))
     JOIN ( SELECT array_agg(DISTINCT substr((ls2.case_key)::text, 1, ("position"((ls2.case_key)::text, 'e-'::text) - 1))) AS original_venue,
            cm.id AS campaign_id
           FROM ((lits ls2
             JOIN lit_campaigns.campaign_lits cl2 ON ((cl2.lit_id = ls2.id)))
             JOIN lit_campaigns.campaigns cm ON ((cm.id = cl2.campaign_id)))
          WHERE (ls2.filed_date = cm.start_date)
          GROUP BY cm.id) ov ON ((ov.campaign_id = c.id)));


--
-- Name: lit_case_aliases; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lit_case_aliases (
    id integer NOT NULL,
    lit_id integer,
    new_docket_info_id integer,
    old_docket_info_id integer,
    new_docket_number character varying(32),
    old_docket_number character varying(32),
    new_case_key character varying(32),
    old_case_key character varying(32)
);


--
-- Name: lit_case_aliases_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_case_aliases_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_case_aliases_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE lit_case_aliases_id_seq OWNED BY lit_case_aliases.id;


SET default_tablespace = rpx_user_default;

--
-- Name: lit_case_stages_deleted; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE lit_case_stages_deleted (
    id integer,
    lit_id integer,
    lit_stage_id integer,
    is_current boolean,
    comment text,
    start_date date,
    start_entry_index integer,
    end_date date,
    end_entry_index integer,
    created_at timestamp without time zone,
    updated_at timestamp without time zone
);


--
-- Name: lit_case_stages_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_case_stages_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_case_stages_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE lit_case_stages_id_seq OWNED BY lit_case_stages.id;


--
-- Name: lit_cause_types_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_cause_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_cause_types_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE lit_cause_types_id_seq OWNED BY lit_cause_types.id;


SET default_tablespace = '';

--
-- Name: lit_classification_types; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lit_classification_types (
    id integer NOT NULL,
    name character varying(255) NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    is_default boolean DEFAULT false NOT NULL
);


--
-- Name: TABLE lit_classification_types; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE lit_classification_types IS '(data01: rpx_casedata.case_classification)';


--
-- Name: COLUMN lit_classification_types.name; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_classification_types.name IS 'RPX Lit Classification (Nuisance/Credible/Sophisticated)';


--
-- Name: COLUMN lit_classification_types.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_classification_types.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN lit_classification_types.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_classification_types.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: COLUMN lit_classification_types.is_default; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_classification_types.is_default IS 'When TRUE, the value is the one that should be used for any new record where the value is not known. There should only be one TRUE record in the table.';


--
-- Name: lit_classification_types_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_classification_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_classification_types_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE lit_classification_types_id_seq OWNED BY lit_classification_types.id;


SET default_tablespace = rpx_user_default;

--
-- Name: lit_courts_deleted; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE lit_courts_deleted (
    lit_id integer,
    alias_id integer,
    start_date date,
    end_date date,
    is_verified boolean,
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    id integer,
    verified_by character varying(255)
);


--
-- Name: lit_curated_cause_types_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_curated_cause_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_curated_cause_types_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE lit_curated_cause_types_id_seq OWNED BY lit_curated_cause_types.id;


--
-- Name: lit_document_orphans; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE lit_document_orphans (
    id integer NOT NULL,
    lit_document_id integer NOT NULL,
    lit_id integer,
    case_key character varying(32),
    original_docket_text text,
    entry_number integer,
    entry_date_filed date,
    updated_at timestamp without time zone,
    created_at timestamp without time zone
);


--
-- Name: COLUMN lit_document_orphans.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_document_orphans.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: COLUMN lit_document_orphans.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_document_orphans.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: lit_document_orphans_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_document_orphans_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_document_orphans_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE lit_document_orphans_id_seq OWNED BY lit_document_orphans.id;


SET default_tablespace = '';

--
-- Name: lit_document_statuses; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lit_document_statuses (
    id integer NOT NULL,
    description character varying(50),
    note text,
    is_default boolean,
    updated_at timestamp without time zone,
    created_at timestamp without time zone
);


--
-- Name: lit_document_statuses_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_document_statuses_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_document_statuses_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE lit_document_statuses_id_seq OWNED BY lit_document_statuses.id;


--
-- Name: lit_document_types; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lit_document_types (
    id integer NOT NULL,
    description character varying(50),
    is_default boolean DEFAULT false,
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    is_archived boolean
);


--
-- Name: lit_document_types_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_document_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_document_types_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE lit_document_types_id_seq OWNED BY lit_document_types.id;


SET default_tablespace = rpx_user_default;

--
-- Name: lit_documents_download_semaphore; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE lit_documents_download_semaphore (
    semaphore integer
);


--
-- Name: lit_families; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE lit_families (
    id integer NOT NULL,
    is_obsolete boolean,
    new_family_id integer[],
    updated_at timestamp without time zone,
    created_at timestamp without time zone
);


--
-- Name: lit_families_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_families_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_families_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE lit_families_id_seq OWNED BY lit_families.id;


--
-- Name: lit_family_info_vw; Type: VIEW; Schema: core; Owner: -
--

CREATE VIEW lit_family_info_vw AS
 SELECT lr.lit_family_id,
    min(lits.filed_date) AS family_start_date,
        CASE
            WHEN (( SELECT max(((xx.xx IS NULL))::integer) AS max
               FROM unnest(array_agg(lits.closed_date)) xx(xx)) = 1) THEN NULL::date
            ELSE max(lits.closed_date)
        END AS family_closed_date,
    count(DISTINCT lits.id) AS lit_count,
    ( SELECT array_agg(DISTINCT xx.lit_id) AS array_agg
           FROM ( SELECT lr1.from_lit_id AS lit_id
                   FROM lit_relationships lr1
                  WHERE (lr1.lit_family_id = lr.lit_family_id)
                UNION
                 SELECT lr2.to_lit_id AS lit_id
                   FROM lit_relationships lr2
                  WHERE (lr2.lit_family_id = lr.lit_family_id)) xx) AS lits_in_family
   FROM (lits
     JOIN lit_relationships lr ON (((lits.id = lr.from_lit_id) OR (lits.id = lr.to_lit_id))))
  GROUP BY lr.lit_family_id;


--
-- Name: lit_family_lit_party_vw; Type: VIEW; Schema: core; Owner: -
--

CREATE VIEW lit_family_lit_party_vw AS
 SELECT lr.lit_family_id,
    vw.family_start_date,
    COALESCE(ents.name, al.name) AS lit_party_name,
    al.ent_id AS lit_party_ent_id,
    lpt.lit_party_normalized_type,
    min(COALESCE(lp.start_date, lits.filed_date)) AS lit_party_start_date,
    max(lp.end_date) AS lit_party_end_date,
    ult.name AS ultimate_parent_name,
    ult.id AS ultimate_parent_ent_id
   FROM (((((((lits
     JOIN lit_relationships lr ON ((((lits.id = lr.from_lit_id) OR (lits.id = lr.to_lit_id)) AND (lr.from_lit_id <> lr.to_lit_id))))
     JOIN lit_family_info_vw vw ON ((lr.lit_family_id = vw.lit_family_id)))
     JOIN lit_parties lp ON ((lits.id = lp.lit_id)))
     JOIN lit_party_types lpt ON ((lp.lit_party_type_id = lpt.id)))
     JOIN aliases al ON ((lp.alias_id = al.id)))
     LEFT JOIN ents ON ((al.ent_id = ents.id)))
     LEFT JOIN ents ult ON ((ents.ultimate_parent_id = ult.id)))
  WHERE ((lpt.lit_party_normalized_type)::text <> 'unknown'::text)
  GROUP BY lr.lit_family_id, vw.family_start_date, COALESCE(ents.name, al.name), al.ent_id, lpt.lit_party_normalized_type, ult.name, ult.id
  ORDER BY lr.lit_family_id, lpt.lit_party_normalized_type;


--
-- Name: lit_judges_map_deleted; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE lit_judges_map_deleted (
    alias_id integer,
    lit_id integer,
    assignment_type_id integer,
    is_terminated boolean,
    assignment_role_as_filed character varying(255),
    end_date date,
    start_date date,
    is_verified boolean,
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    id integer,
    verified_by character varying(255),
    missing_from_source_date date
);


--
-- Name: lit_parties_deleted; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE lit_parties_deleted (
    id integer,
    alias_id integer,
    lit_party_type_id integer,
    lit_id integer,
    alias_contact_id integer,
    lit_party_practice_type_id integer,
    start_date date,
    end_date date,
    is_verified boolean,
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    is_removed_from_pacer boolean,
    verified_by character varying(255),
    salesforce_id character varying(18),
    missing_from_source_date date,
    dj_party_normalized_type character varying(255),
    is_dcl_corrected boolean,
    campaign_party_normalized_type character varying(255)
);


--
-- Name: lit_parties_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_parties_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_parties_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE lit_parties_id_seq OWNED BY lit_parties.id;


--
-- Name: lit_parties_representations_deleted; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE lit_parties_representations_deleted (
    lit_parties_id integer,
    lawfirm_alias_id integer,
    lawyer_alias_id integer,
    is_lead_lawyer boolean,
    is_notify_lawyer boolean,
    lawyer_alias_contact_id integer,
    lawfirm_alias_contact_id integer,
    is_local_lawyer boolean,
    start_date date,
    end_date date,
    is_verified boolean,
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    id integer,
    verified_by character varying(255),
    missing_from_source_date date,
    is_dcl_corrected boolean
);


--
-- Name: lit_party_normalized_types; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE lit_party_normalized_types (
    id integer NOT NULL,
    name character varying(255) NOT NULL,
    is_default boolean DEFAULT false,
    created_at timestamp without time zone,
    updated_at timestamp without time zone
);


--
-- Name: COLUMN lit_party_normalized_types.created_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_party_normalized_types.created_at IS 'Date and time the record was created. Controlled automatically by the database.';


--
-- Name: COLUMN lit_party_normalized_types.updated_at; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN lit_party_normalized_types.updated_at IS 'Date and time the record was last updated. Controlled automatically by the database.';


--
-- Name: lit_party_normalized_types_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_party_normalized_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_party_normalized_types_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE lit_party_normalized_types_id_seq OWNED BY lit_party_normalized_types.id;


--
-- Name: lit_party_outcome_subtypes; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE lit_party_outcome_subtypes (
    id integer NOT NULL,
    name character varying(64),
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now()
);


--
-- Name: lit_party_outcome_subtypes_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_party_outcome_subtypes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_party_outcome_subtypes_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE lit_party_outcome_subtypes_id_seq OWNED BY lit_party_outcome_subtypes.id;


--
-- Name: lit_party_outcome_type_subtype_map; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE lit_party_outcome_type_subtype_map (
    id integer NOT NULL,
    lit_party_outcome_type_id integer,
    lit_party_outcome_subtype_id integer
);


--
-- Name: lit_party_outcome_type_subtype_map_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_party_outcome_type_subtype_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_party_outcome_type_subtype_map_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE lit_party_outcome_type_subtype_map_id_seq OWNED BY lit_party_outcome_type_subtype_map.id;


--
-- Name: lit_party_outcome_types; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE lit_party_outcome_types (
    id integer NOT NULL,
    name character varying(64),
    description text,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now()
);


--
-- Name: lit_party_outcome_types_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_party_outcome_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_party_outcome_types_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE lit_party_outcome_types_id_seq OWNED BY lit_party_outcome_types.id;


--
-- Name: lit_party_outcomes; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE lit_party_outcomes (
    id integer NOT NULL,
    lit_parties_id integer,
    lit_party_outcome_type_id integer,
    lit_party_outcome_subtype_id integer,
    comments text,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    updated_by character varying(64) DEFAULT "current_user"(),
    docket_entry_reference integer
);


SET default_tablespace = '';

--
-- Name: lit_party_outcomes_deleted; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lit_party_outcomes_deleted (
    id integer,
    lit_parties_id integer,
    lit_party_outcome_type_id integer,
    lit_party_outcome_subtype_id integer,
    comments text,
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    updated_by character varying(64),
    docket_entry_reference integer
);


--
-- Name: lit_party_outcomes_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_party_outcomes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_party_outcomes_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE lit_party_outcomes_id_seq OWNED BY lit_party_outcomes.id;


--
-- Name: lit_party_types_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_party_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_party_types_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE lit_party_types_id_seq OWNED BY lit_party_types.id;


--
-- Name: lit_relationship_types_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_relationship_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_relationship_types_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE lit_relationship_types_id_seq OWNED BY lit_relationship_types.id;


SET default_tablespace = rpx_user_default;

--
-- Name: lit_relationships_deleted; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE lit_relationships_deleted (
    from_lit_id integer,
    to_lit_id integer,
    lit_relationship_type_id integer,
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    id integer,
    lit_family_id integer
);


--
-- Name: lit_stages_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_stages_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_stages_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE lit_stages_id_seq OWNED BY lit_stages.id;


--
-- Name: lit_types_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lit_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lit_types_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE lit_types_id_seq OWNED BY lit_types.id;


--
-- Name: lits_deleted; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE lits_deleted (
    id integer,
    docketx_id character varying(32),
    case_key character varying(32),
    lit_cause_id integer,
    nos integer,
    demand numeric(16,2),
    docket_number character varying(13),
    docket_number_long character varying(128),
    jurisdiction character varying(40),
    jury_demand character varying(30),
    filed_date date,
    closed_date date,
    judgment_date date,
    decided_date date,
    reopened_date date,
    disposed_date date,
    is_open boolean,
    title character varying(255),
    case_type character(2),
    last_pacer_retrieval_for_summary timestamp without time zone,
    last_pacer_retrieval_for_docket timestamp without time zone,
    last_pacer_retrieval_for_parties timestamp without time zone,
    has_spammy_parties boolean,
    has_spammy_patents boolean,
    has_complaint boolean,
    added_at timestamp without time zone,
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    docket_info_id integer,
    is_administratively_closed boolean,
    salesforce_id character varying(18),
    original_filed_date date,
    pacer_docket_not_found boolean,
    pacer_docket_is_sealed boolean,
    is_dcl_corrected boolean
);


--
-- Name: lits_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lits_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lits_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE lits_id_seq OWNED BY lits.id;


--
-- Name: lits_pats_map_deleted; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE lits_pats_map_deleted (
    lit_id integer,
    patnum character varying(15),
    start_date date,
    end_date date,
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    id integer,
    salesforce_id character varying(18),
    created_by character varying
);


SET default_tablespace = '';

--
-- Name: lits_pats_other; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE lits_pats_other (
    id integer NOT NULL,
    lit_id integer NOT NULL,
    pat_id integer NOT NULL,
    stripped_patnum character varying NOT NULL,
    start_date date,
    end_date date,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying DEFAULT "current_user"()
);


--
-- Name: lits_pats_other_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE lits_pats_other_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lits_pats_other_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE lits_pats_other_id_seq OWNED BY lits_pats_other.id;


--
-- Name: lits_pats_tmp; Type: VIEW; Schema: core; Owner: -
--

CREATE VIEW lits_pats_tmp AS
 SELECT lits_pats_map.lit_id,
    lits_pats_map.patnum,
    lits_pats_map.start_date,
    lits_pats_map.end_date,
    lits_pats_map.created_at,
    lits_pats_map.updated_at,
    lits_pats_map.id,
    lits_pats_map.salesforce_id
   FROM lits_pats_map;


--
-- Name: market_sector_types_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE market_sector_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: market_sector_types_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE market_sector_types_id_seq OWNED BY market_sector_types.id;


--
-- Name: mc_license_date_3677_dump; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE mc_license_date_3677_dump (
    member_credit_history_id integer,
    license_date date
);


--
-- Name: mc_tech_description_3709_dump; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE mc_tech_description_3709_dump (
    member_credit_history_id integer,
    new_technology_description text
);


SET default_tablespace = rpx_user_default;

--
-- Name: missing_lit_pat_numbers; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE missing_lit_pat_numbers (
    patnum character varying
);


SET default_tablespace = '';

--
-- Name: msg_queue_log; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE msg_queue_log (
    msg_id integer,
    msg_key character varying(100),
    msg_body text,
    create_tsp timestamp without time zone,
    priority smallint,
    org_create_tsp timestamp without time zone NOT NULL,
    msg_type integer,
    push_client character varying(20) NOT NULL
);


--
-- Name: pat_abstracts; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pat_abstracts (
    id integer NOT NULL,
    pat_id integer NOT NULL,
    abstract_text text,
    lang character varying(2),
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    word_count integer
);


--
-- Name: TABLE pat_abstracts; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE pat_abstracts IS 'Paragraph briefly describing invention from high level.
tds:abst';


--
-- Name: COLUMN pat_abstracts.abstract_text; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_abstracts.abstract_text IS 'tds:atxt
Abstract Text paragraphs';


--
-- Name: COLUMN pat_abstracts.lang; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_abstracts.lang IS 'language code of the abstract';


--
-- Name: pat_abstracts_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_abstracts_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_abstracts_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_abstracts_id_seq OWNED BY pat_abstracts.id;


--
-- Name: pat_assignments; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pat_assignments (
    id integer NOT NULL,
    reel_number integer DEFAULT 0 NOT NULL,
    frame_number integer DEFAULT 0 NOT NULL,
    recorded_date date,
    correspondent_alias_id integer,
    conveyance text,
    page_count integer,
    is_purged boolean DEFAULT false NOT NULL,
    is_transaction boolean DEFAULT false NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    correspondent_alias_contact_id integer,
    is_verified boolean DEFAULT false NOT NULL,
    notes text,
    verified_by character varying(255),
    pat_assignment_file_id integer,
    primary_conveyance_logic_id integer DEFAULT '-1'::integer NOT NULL,
    primary_conveyance_logic_version integer DEFAULT '-1'::integer NOT NULL,
    primary_conveyance_type_id integer DEFAULT '-1'::integer NOT NULL,
    associated_reel_frame_status integer DEFAULT 0 NOT NULL,
    secondary_conveyance_logic_version integer DEFAULT 0 NOT NULL,
    possible_secondary_conveyance boolean DEFAULT true NOT NULL,
    is_dcl_corrected boolean
);


--
-- Name: TABLE pat_assignments; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE pat_assignments IS 'tds:assi';


--
-- Name: COLUMN pat_assignments.reel_number; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_assignments.reel_number IS 'The reel number according the  USPTO. If the reel number = 0, the assignment is "the name on the face of the Patent" and not an actually recorded assignment on USPTO. Comment updated at: 2012-11-06';


--
-- Name: COLUMN pat_assignments.frame_number; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_assignments.frame_number IS 'The frame number according the  USPTO. If the frame number = 0, the assignment is "the name on the face of the Patent" and not an actually recorded assignment on USPTO. Comment updated at: 2012-11-06';


--
-- Name: COLUMN pat_assignments.recorded_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_assignments.recorded_date IS 'The recordation date of the given assignment according to the USPTO. Comment updated at: 2012-11-06';


--
-- Name: COLUMN pat_assignments.correspondent_alias_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_assignments.correspondent_alias_id IS 'The alias id of the correspondent of the given assignment. Maps to the alias table. Comment updated at: 2012-11-06';


--
-- Name: COLUMN pat_assignments.conveyance; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_assignments.conveyance IS 'The "as listed" conveyance for the given assignment according to the USPTO. Comment updated at: 2012-11-06';


--
-- Name: COLUMN pat_assignments.is_purged; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_assignments.is_purged IS 'record indicator from PTO';


--
-- Name: COLUMN pat_assignments.is_transaction; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_assignments.is_transaction IS 'RPX calculated field - means patent changed hands';


--
-- Name: COLUMN pat_assignments.correspondent_alias_contact_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_assignments.correspondent_alias_contact_id IS 'The alias contact if for the correspondent for the given assignment. This maps to the alias_contacts table.  Comment updated at: 2012-11-06';


--
-- Name: COLUMN pat_assignments.is_verified; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_assignments.is_verified IS 'If the correspondent alias_id match to an entity has been verified.  Comment updated at: 2012-11-06';


--
-- Name: COLUMN pat_assignments.verified_by; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_assignments.verified_by IS 'Who verified the correspondent alias_id match to an entity. Comment updated at: 2012-11-06';


SET default_tablespace = rpx_user_default;

--
-- Name: pat_assignments_assoc_r_f; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_assignments_assoc_r_f (
    id integer NOT NULL,
    pat_assignment_id integer NOT NULL,
    reel integer NOT NULL,
    frame integer NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE pat_assignments_assoc_r_f; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE pat_assignments_assoc_r_f IS 'This table represents relationships between an assignment and other assignments that the aforementioned assignment references within the given assignment for the associated patent. The relation ship is 1 assignment to 1 to many related assignments.  Comment updated at: 2012-11-06';


--
-- Name: COLUMN pat_assignments_assoc_r_f.pat_assignment_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_assignments_assoc_r_f.pat_assignment_id IS 'That assignment that is referencing other assignments. Comment updated at: 2012-11-06';


--
-- Name: COLUMN pat_assignments_assoc_r_f.reel; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_assignments_assoc_r_f.reel IS 'The reel of the current assignment referenced.  Comment updated at: 2012-11-06';


--
-- Name: COLUMN pat_assignments_assoc_r_f.frame; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_assignments_assoc_r_f.frame IS 'The frame of the current assignment referenced.  Comment updated at: 2012-11-06';


--
-- Name: pat_assignments_assoc_r_f_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_assignments_assoc_r_f_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_assignments_assoc_r_f_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_assignments_assoc_r_f_id_seq OWNED BY pat_assignments_assoc_r_f.id;


--
-- Name: pat_assignments_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_assignments_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_assignments_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_assignments_id_seq OWNED BY pat_assignments.id;


--
-- Name: pat_bad_titles; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_bad_titles (
    pat_id integer,
    title text
);


--
-- Name: pat_claim_relationships_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_claim_relationships_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_claim_relationships_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_claim_relationships_id_seq OWNED BY pat_claim_relationships.id;


SET default_tablespace = '';

--
-- Name: pat_claims_s3; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pat_claims_s3 (
    id integer NOT NULL,
    pat_id integer,
    loaded_to_s3 boolean DEFAULT false,
    created_at timestamp(6) without time zone DEFAULT now() NOT NULL,
    updated_at timestamp(6) without time zone DEFAULT now() NOT NULL
);


--
-- Name: pat_claims_s3_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_claims_s3_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_claims_s3_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_claims_s3_id_seq OWNED BY pat_claims_s3.id;


--
-- Name: pat_cpc_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_cpc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


SET default_tablespace = rpx_user_default;

--
-- Name: pat_cpc; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_cpc (
    id integer DEFAULT nextval('pat_cpc_id_seq'::regclass) NOT NULL,
    country_code character varying(32),
    doc_kind_code character varying(32),
    application_number character varying(32),
    grant_pub_number character varying(32),
    pat_id integer,
    cpc_section character varying(32),
    cpc_class character varying(32),
    cpc_subclass character varying(32),
    cpc_main_group character varying(32),
    separator character varying(32),
    cpc_subgroup character varying(32),
    cpc_version_date date,
    cpc_symbol_position character varying(32),
    cpc_value_code character varying(32),
    cpc_comb_set_group_number character varying(32),
    cpc_comb_set_rank_number character varying(32),
    application_type character varying(32),
    md5_pat_cpc character varying(32),
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now()
);


--
-- Name: pat_cross_ref_classes_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_cross_ref_classes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


SET default_tablespace = '';

--
-- Name: pat_cross_ref_classes; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pat_cross_ref_classes (
    pat_id integer NOT NULL,
    cross_ref_element character varying(20) NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    id integer DEFAULT nextval('pat_cross_ref_classes_id_seq'::regclass) NOT NULL
);


--
-- Name: TABLE pat_cross_ref_classes; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE pat_cross_ref_classes IS 'tds:crcu';


--
-- Name: COLUMN pat_cross_ref_classes.cross_ref_element; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_cross_ref_classes.cross_ref_element IS 'tds:crun
Single cross-reference class element';


SET default_tablespace = rpx_user_default;

--
-- Name: pat_current; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_current (
    app_num_country character varying(2048) NOT NULL,
    pat_id integer,
    patnum character varying(255),
    stripped_patnum character varying(32),
    maintenance_code_id integer,
    id integer NOT NULL,
    updated_at timestamp with time zone,
    created_at timestamp with time zone
);


--
-- Name: pat_current_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_current_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_current_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_current_id_seq OWNED BY pat_current.id;


SET default_tablespace = '';

--
-- Name: pat_descriptions; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pat_descriptions (
    id integer NOT NULL,
    pat_id integer NOT NULL,
    lang character varying(2),
    description text,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    word_count integer
);


--
-- Name: TABLE pat_descriptions; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE pat_descriptions IS 'tds:descr';


--
-- Name: COLUMN pat_descriptions.lang; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_descriptions.lang IS 'Language';


--
-- Name: COLUMN pat_descriptions.description; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_descriptions.description IS 'Description';


--
-- Name: pat_descriptions_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_descriptions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_descriptions_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_descriptions_id_seq OWNED BY pat_descriptions.id;


SET default_tablespace = rpx_user_default;

--
-- Name: pat_document_types; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_document_types (
    id integer NOT NULL,
    document_type character varying(255) NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    is_default boolean DEFAULT false NOT NULL
);


--
-- Name: pat_document_types_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_document_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_document_types_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_document_types_id_seq OWNED BY pat_document_types.id;


SET default_tablespace = '';

--
-- Name: pat_documents; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pat_documents (
    id integer NOT NULL,
    pat_id integer NOT NULL,
    country character varying(255),
    description character varying(255),
    doc_date character(8),
    doc_name character varying(255),
    doc_number character varying(255),
    doc_type character varying(255),
    kind character varying(255),
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL
);


--
-- Name: TABLE pat_documents; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE pat_documents IS 'if the related doc is provisional application or related publication then this table else pat_related_docs';


--
-- Name: pat_documents_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_documents_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_documents_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_documents_id_seq OWNED BY pat_documents.id;


--
-- Name: pat_drawings; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pat_drawings (
    id integer NOT NULL,
    pat_id integer NOT NULL,
    alt character varying(255),
    figure_id character varying(255),
    file text,
    img_content character varying(255),
    img_format character varying(255),
    img_id character varying(255),
    he character varying(255),
    wi character varying(255),
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL
);


--
-- Name: TABLE pat_drawings; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE pat_drawings IS 'big zip files have embeded docs in them which this table points to';


--
-- Name: COLUMN pat_drawings.alt; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_drawings.alt IS 'alternate title; eg "embedded image"';


--
-- Name: COLUMN pat_drawings.file; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_drawings.file IS 'filename of the image in big zip';


--
-- Name: COLUMN pat_drawings.he; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_drawings.he IS 'height';


--
-- Name: COLUMN pat_drawings.wi; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_drawings.wi IS 'width';


--
-- Name: pat_drawings_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_drawings_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_drawings_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_drawings_id_seq OWNED BY pat_drawings.id;


--
-- Name: pat_ent_relationships; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pat_ent_relationships (
    pat_id integer,
    inventor_alias_ids integer[],
    inventor_ent_ids integer[],
    primary_examiner_alias_ids integer[],
    primary_examiner_ent_ids integer[],
    secondary_examiner_alias_ids integer[],
    secondary_examiner_ent_ids integer[],
    original_assignee_alias_ids integer[],
    original_assignee_ent_ids integer[],
    sponsoring_party_alias_ids integer[],
    sponsoring_party_ent_ids integer[],
    current_assignee_alias_ids integer[],
    current_assignee_ent_ids integer[],
    any_assignee_alias_ids integer[],
    any_assignee_ent_ids integer[],
    litigated_by_district_court_alias_ids integer[],
    litigated_by_district_court_ent_ids integer[],
    litigated_by_itc_alias_ids integer[],
    litigated_by_itc_ent_ids integer[],
    ptab_patent_owner_alias_ids integer[],
    ptab_patent_owner_ent_ids integer[],
    litigated_against_district_court_alias_ids integer[],
    litigated_against_district_court_ent_ids integer[],
    litigated_against_itc_alias_ids integer[],
    litigated_against_itc_ent_ids integer[],
    ptab_petitioner_alias_ids integer[],
    ptab_petitioner_ent_ids integer[],
    current_assignee_citation_alias_ids integer[],
    current_assignee_citation_ent_ids integer[],
    current_assignee_citee_alias_ids integer[],
    current_assignee_citee_ent_ids integer[],
    potentially_relevant_company_alias_ids integer[],
    potentially_relevant_company_ent_ids integer[],
    pa_web_licensee_alias_ids integer[],
    pa_web_licensee_ent_ids integer[],
    correspondent_alias_ids integer[],
    correspondent_ent_ids integer[],
    id integer NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    created_by character varying(255) DEFAULT "current_user"(),
    run_id integer DEFAULT 0,
    updated_at timestamp without time zone DEFAULT now()
);


--
-- Name: pat_ent_relationships_tmp; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pat_ent_relationships_tmp (
    pat_id integer,
    inventor_alias_ids integer[],
    inventor_ent_ids integer[],
    primary_examiner_alias_ids integer[],
    primary_examiner_ent_ids integer[],
    secondary_examiner_alias_ids integer[],
    secondary_examiner_ent_ids integer[],
    original_assignee_alias_ids integer[],
    original_assignee_ent_ids integer[],
    sponsoring_party_alias_ids integer[],
    sponsoring_party_ent_ids integer[],
    current_assignee_alias_ids integer[],
    current_assignee_ent_ids integer[],
    any_assignee_alias_ids integer[],
    any_assignee_ent_ids integer[],
    litigated_by_district_court_alias_ids integer[],
    litigated_by_district_court_ent_ids integer[],
    litigated_by_itc_alias_ids integer[],
    litigated_by_itc_ent_ids integer[],
    ptab_patent_owner_alias_ids integer[],
    ptab_patent_owner_ent_ids integer[],
    litigated_against_district_court_alias_ids integer[],
    litigated_against_district_court_ent_ids integer[],
    litigated_against_itc_alias_ids integer[],
    litigated_against_itc_ent_ids integer[],
    ptab_petitioner_alias_ids integer[],
    ptab_petitioner_ent_ids integer[],
    current_assignee_citation_alias_ids integer[],
    current_assignee_citation_ent_ids integer[],
    current_assignee_citee_alias_ids integer[],
    current_assignee_citee_ent_ids integer[],
    potentially_relevant_company_alias_ids integer[],
    potentially_relevant_company_ent_ids integer[],
    pa_web_licensee_alias_ids integer[],
    pa_web_licensee_ent_ids integer[],
    correspondent_alias_ids integer[],
    correspondent_ent_ids integer[],
    id integer NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    created_by character varying(255) DEFAULT "current_user"(),
    run_id integer,
    updated_at timestamp without time zone DEFAULT now()
);


--
-- Name: pat_ent_relationships_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_ent_relationships_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_ent_relationships_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_ent_relationships_id_seq OWNED BY pat_ent_relationships_tmp.id;


--
-- Name: pat_ent_relationships_temp_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_ent_relationships_temp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_ent_relationships_temp_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_ent_relationships_temp_id_seq OWNED BY pat_ent_relationships.id;


--
-- Name: pat_family_family_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_family_family_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_family_pats_details; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pat_family_pats_details (
    id integer NOT NULL,
    pat_id integer,
    patnum character varying(32),
    stripped_patnum character varying(32),
    country_code character varying(16),
    pat_family_id integer,
    pat_family_name character varying(128),
    pat_family_priority_date date,
    pat_family_expiry_date date,
    pat_family_us_patent_count integer,
    pat_family_us_application_count integer,
    pat_family_non_us_patent_count integer,
    pat_family_non_us_application_count integer,
    pat_family_first_us_stripped_patnum character varying(32),
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    created_by character varying DEFAULT "session_user"(),
    updated_by character varying DEFAULT "session_user"()
);


--
-- Name: pat_family_pats_details_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_family_pats_details_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_family_pats_details_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_family_pats_details_id_seq OWNED BY pat_family_pats_details.id;


--
-- Name: pat_family_pats_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_family_pats_id_seq
    START WITH 19119593
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


SET default_tablespace = rpx_user_default;

--
-- Name: pat_ipc_classes; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_ipc_classes (
    id integer NOT NULL,
    pat_id integer NOT NULL,
    name character varying(255) NOT NULL,
    version character varying(255) NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL
);


--
-- Name: pat_ipc_classes_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_ipc_classes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_ipc_classes_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_ipc_classes_id_seq OWNED BY pat_ipc_classes.id;


--
-- Name: pat_maintenance_code; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_maintenance_code (
    id integer NOT NULL,
    code character varying(2) NOT NULL,
    description character varying(70) NOT NULL,
    created_by character varying(255) NOT NULL,
    updated_by character varying(255) NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


--
-- Name: pat_maintenance_fee_entity_types; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_maintenance_fee_entity_types (
    id integer NOT NULL,
    code character varying(1) NOT NULL,
    description character varying(25) NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


--
-- Name: pat_maintenance_fee_entity_types_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_maintenance_fee_entity_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_maintenance_fee_entity_types_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_maintenance_fee_entity_types_id_seq OWNED BY pat_maintenance_fee_entity_types.id;


--
-- Name: pat_maintenance_fee_event_types; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_maintenance_fee_event_types (
    id integer NOT NULL,
    code character varying(5) NOT NULL,
    description character varying(100) NOT NULL,
    is_important boolean DEFAULT false,
    is_default boolean DEFAULT false,
    job_id integer,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL
);


--
-- Name: pat_maintenance_fee_event_types_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_maintenance_fee_event_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_maintenance_fee_event_types_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_maintenance_fee_event_types_id_seq OWNED BY pat_maintenance_fee_event_types.id;


--
-- Name: pat_maintenance_fee_events; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_maintenance_fee_events (
    id integer NOT NULL,
    pat_id integer NOT NULL,
    pat_maintenance_fee_event_type_id integer NOT NULL,
    pat_maintenance_fee_entity_type_id integer NOT NULL,
    event_date date NOT NULL,
    is_deleted boolean DEFAULT false,
    job_id integer,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL
);


--
-- Name: pat_maintenance_fee_events_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_maintenance_fee_events_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_maintenance_fee_events_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_maintenance_fee_events_id_seq OWNED BY pat_maintenance_fee_events.id;


--
-- Name: pat_orig_app_num_country; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_orig_app_num_country (
    id integer NOT NULL,
    pat_id integer NOT NULL,
    parent_link_type character varying(255) NOT NULL,
    parent_app_num_country character varying(255) NOT NULL,
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL
);


--
-- Name: pat_orig_app_num_country_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_orig_app_num_country_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_orig_app_num_country_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_orig_app_num_country_id_seq OWNED BY pat_orig_app_num_country.id;


SET default_tablespace = '';

--
-- Name: pat_other_references; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pat_other_references (
    id integer NOT NULL,
    pat_id integer NOT NULL,
    other_reference text,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL
);


--
-- Name: TABLE pat_other_references; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE pat_other_references IS 'Other materials such as scholarly papers this pat refferences as prior art
tds:orfs';


--
-- Name: COLUMN pat_other_references.other_reference; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_other_references.other_reference IS 'tds:oref
Other Reference';


--
-- Name: pat_other_references_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_other_references_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_other_references_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_other_references_id_seq OWNED BY pat_other_references.id;


SET default_tablespace = rpx_user_default;

--
-- Name: pat_primary_conveyance_types; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_primary_conveyance_types (
    id integer NOT NULL,
    primary_conveyance_text text,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    is_default boolean DEFAULT false
);


--
-- Name: pat_primary_conveyance_types_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_primary_conveyance_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_primary_conveyance_types_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_primary_conveyance_types_id_seq OWNED BY pat_primary_conveyance_types.id;


--
-- Name: pat_priority_claims; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_priority_claims (
    id integer NOT NULL,
    pat_id integer NOT NULL,
    priority_patnum character varying(255) NOT NULL,
    priority_app_date date,
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL
);


--
-- Name: pat_priority_claims_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_priority_claims_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_priority_claims_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_priority_claims_id_seq OWNED BY pat_priority_claims.id;


SET default_tablespace = '';

--
-- Name: pat_references; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pat_references (
    id integer NOT NULL,
    pat_id integer NOT NULL,
    pub_date date,
    ref_patnum character varying(18),
    title text,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    ref_pat_id integer
);


--
-- Name: TABLE pat_references; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE pat_references IS 'Patents this pat refferences as prior art.
tds:refs';


--
-- Name: COLUMN pat_references.pub_date; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_references.pub_date IS 'tds:issd
Publication date of reference';


--
-- Name: COLUMN pat_references.ref_patnum; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_references.ref_patnum IS 'tds:ref_patnum
US + patent number + kind code of reference';


--
-- Name: COLUMN pat_references.title; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_references.title IS 'tds:titl
Title of reference';


SET default_tablespace = rpx_user_default;

--
-- Name: pat_references_deleted; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_references_deleted (
    id integer,
    pat_id integer,
    pub_date date,
    ref_patnum character varying(18),
    title text,
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    ref_pat_id integer,
    deleted_at timestamp with time zone
);


--
-- Name: pat_references_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_references_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_references_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_references_id_seq OWNED BY pat_references.id;


SET default_tablespace = '';

--
-- Name: pat_references_staging; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pat_references_staging (
    patnum text,
    issd text,
    ref_patnum text,
    titl text
);


SET default_tablespace = rpx_user_default;

--
-- Name: pat_reissue_number; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_reissue_number (
    pat_id integer NOT NULL,
    reissue_number character varying,
    reissue_stripped_patnum character varying(32)
);


--
-- Name: TABLE pat_reissue_number; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE pat_reissue_number IS 'Table with latest reissue number for a pat_id';


--
-- Name: COLUMN pat_reissue_number.pat_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_reissue_number.pat_id IS 'pat_id points to core.pats.id';


--
-- Name: COLUMN pat_reissue_number.reissue_number; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_reissue_number.reissue_number IS 'reissue patent number';


--
-- Name: COLUMN pat_reissue_number.reissue_stripped_patnum; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_reissue_number.reissue_stripped_patnum IS 'reissue stripped_patnum';


SET default_tablespace = '';

--
-- Name: pat_related_documents; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pat_related_documents (
    id integer NOT NULL,
    rupt text,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    pat_id integer NOT NULL
);


--
-- Name: TABLE pat_related_documents; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE pat_related_documents IS 'tds:rupd';


--
-- Name: pat_related_documents_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_related_documents_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_related_documents_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_related_documents_id_seq OWNED BY pat_related_documents.id;


SET default_tablespace = rpx_user_default;

--
-- Name: pat_secondary_conveyance; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_secondary_conveyance (
    id integer NOT NULL,
    pat_assignment_id integer NOT NULL,
    secondary_conveyance_logic_version integer NOT NULL,
    pat_secondary_conveyance_type_id integer NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


--
-- Name: pat_secondary_conveyance_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_secondary_conveyance_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_secondary_conveyance_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_secondary_conveyance_id_seq OWNED BY pat_secondary_conveyance.id;


--
-- Name: pat_secondary_conveyance_types; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_secondary_conveyance_types (
    id integer NOT NULL,
    secondary_conveyance_text text,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    is_default boolean DEFAULT false
);


--
-- Name: pat_secondary_conveyance_types_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_secondary_conveyance_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_secondary_conveyance_types_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_secondary_conveyance_types_id_seq OWNED BY pat_secondary_conveyance_types.id;


SET default_tablespace = '';

--
-- Name: pat_stats_all_assignees; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pat_stats_all_assignees (
    id integer NOT NULL,
    pat_id integer,
    alias_id integer,
    run_id integer,
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    created_by character varying(255),
    updated_by character varying(255)
);


--
-- Name: pat_stats_all_assignees_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_stats_all_assignees_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_stats_all_assignees_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_stats_all_assignees_id_seq OWNED BY pat_stats_all_assignees.id;


SET default_tablespace = rpx_user_default;

--
-- Name: pat_stats_continuances; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_stats_continuances (
    id integer NOT NULL,
    pat_stats_id integer,
    cont_stripped_patnum character varying(255),
    cont_kind_code character varying(255),
    cont_country_code character varying(255),
    app_num_intl character varying(255),
    app_num_country character varying(255),
    priority_linkage_type character varying(255),
    updated_at timestamp without time zone,
    created_at timestamp without time zone
);


--
-- Name: TABLE pat_stats_continuances; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE pat_stats_continuances IS 'A list of documents that this patent is a continuance of, compiled from DocDB.';


--
-- Name: COLUMN pat_stats_continuances.cont_stripped_patnum; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats_continuances.cont_stripped_patnum IS 'The stripped patent number for the document that the patent is a continuance of.';


--
-- Name: COLUMN pat_stats_continuances.cont_kind_code; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats_continuances.cont_kind_code IS 'The kind code for the document that the patent is a continuance of.';


--
-- Name: COLUMN pat_stats_continuances.cont_country_code; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats_continuances.cont_country_code IS 'The country for the document that the patent is a continuance of.';


--
-- Name: COLUMN pat_stats_continuances.app_num_intl; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats_continuances.app_num_intl IS 'The application country listed for the document that the patent is a continuation of.';


--
-- Name: COLUMN pat_stats_continuances.priority_linkage_type; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pat_stats_continuances.priority_linkage_type IS 'The DocDB linkage type for the continuance.';


--
-- Name: pat_stats_continuances_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_stats_continuances_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_stats_continuances_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_stats_continuances_id_seq OWNED BY pat_stats_continuances.id;


SET default_tablespace = '';

--
-- Name: pat_stats_current_assignees_dups_ds_3454; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pat_stats_current_assignees_dups_ds_3454 (
    id integer,
    pat_stats_id integer,
    alias_id integer,
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    run_id integer
);


--
-- Name: pat_stats_current_assignees_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_stats_current_assignees_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_stats_current_assignees_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_stats_current_assignees_id_seq OWNED BY pat_stats_current_assignees.id;


SET default_tablespace = rpx_user_default;

--
-- Name: pat_stats_current_assignors; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_stats_current_assignors (
    id integer NOT NULL,
    pat_id bigint,
    pat_stats_id bigint,
    assignment_id bigint,
    alias_id bigint,
    execution_date date,
    created_at date DEFAULT clock_timestamp(),
    updated_at date DEFAULT clock_timestamp(),
    created_by character varying DEFAULT "session_user"(),
    updated_by character varying DEFAULT "session_user"()
);


--
-- Name: pat_stats_current_assignors_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_stats_current_assignors_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_stats_current_assignors_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_stats_current_assignors_id_seq OWNED BY pat_stats_current_assignors.id;


SET default_tablespace = '';

--
-- Name: pat_stats_dups_ds_3454; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pat_stats_dups_ds_3454 (
    id integer,
    stripped_patnum character varying(32),
    doc_kind_code character varying(16),
    country_code character varying(16),
    patnum character varying(255),
    num_backward_ref integer,
    num_forward_ref integer,
    num_claims_independant integer,
    num_claims_dependant integer,
    assignment_chain_break boolean,
    priority_date date,
    is_continuation boolean,
    num_open_continuances integer,
    time_in_review integer,
    word_cnt_indep_claims integer,
    word_cnt_dep_claims integer,
    word_cnt_patent integer,
    num_npl_ref integer,
    num_ents_citing integer,
    num_ult_parents_transacted integer,
    num_family_members integer,
    year_4_pay_date date,
    year_8_pay_date date,
    year_12_pay_date date,
    is_assign_pre_issue boolean,
    last_updated_by_tds_etl timestamp without time zone,
    last_updated_by_docdb_etl timestamp without time zone,
    last_updated_by_assign_etl timestamp without time zone,
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    last_updated_by_family_etl timestamp without time zone,
    run_id integer,
    expiration_date date,
    is_rpx_owned boolean,
    is_rpx_member_owned boolean,
    is_litigated boolean
);


--
-- Name: pat_stats_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_stats_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_stats_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_stats_id_seq OWNED BY pat_stats.id;


--
-- Name: pat_stats_inventors; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pat_stats_inventors (
    id integer NOT NULL,
    pat_id integer,
    alias_id integer,
    run_id integer,
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    created_by character varying(255),
    updated_by character varying(255)
);


--
-- Name: pat_stats_inventors_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_stats_inventors_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_stats_inventors_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_stats_inventors_id_seq OWNED BY pat_stats_inventors.id;


SET default_tablespace = rpx_user_default;

--
-- Name: pat_stats_sponsoring_parties; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_stats_sponsoring_parties (
    id integer NOT NULL,
    pat_stats_id integer NOT NULL,
    alias_id integer NOT NULL,
    updated_by character varying(255),
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    run_id integer,
    pat_id integer
);


--
-- Name: TABLE pat_stats_sponsoring_parties; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE pat_stats_sponsoring_parties IS 'A list of the alias ids of the sponsoring party for the patent (patent developer).';


--
-- Name: pat_stats_sponsoring_parties_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pat_stats_sponsoring_parties_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_stats_sponsoring_parties_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pat_stats_sponsoring_parties_id_seq OWNED BY pat_stats_sponsoring_parties.id;


--
-- Name: patent_assignments_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE patent_assignments_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: patent_assignors_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE patent_assignors_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: patent_group; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE patent_group (
    patent_number character varying(32),
    core_pat_id integer,
    app_num_country character varying(2048)
);


--
-- Name: patent_owners_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE patent_owners_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: patent_owners_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE patent_owners_id_seq OWNED BY patent_owners.id;


--
-- Name: pats_aliases_relationship_types_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pats_aliases_relationship_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pats_aliases_relationship_types_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pats_aliases_relationship_types_id_seq OWNED BY pats_aliases_relationship_types.id;


--
-- Name: pats_assignments_map_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pats_assignments_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pats_assignments_map_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pats_assignments_map_id_seq OWNED BY pats_assignments_map.id;


SET default_tablespace = '';

--
-- Name: pats_field_of_search; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pats_field_of_search (
    id integer NOT NULL,
    pat_id integer NOT NULL,
    stripped_patnum character varying(32),
    field_of_search character varying(1024),
    updated_at timestamp(6) without time zone NOT NULL,
    created_at timestamp(6) without time zone NOT NULL
);


--
-- Name: COLUMN pats_field_of_search.pat_id; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats_field_of_search.pat_id IS 'This column references to the patents from core.pats table.';


--
-- Name: COLUMN pats_field_of_search.stripped_patnum; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats_field_of_search.stripped_patnum IS 'This column contains the central piece of the patnum column, with the two digit country prefix and the kind code suffix stripped off.';


--
-- Name: COLUMN pats_field_of_search.field_of_search; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON COLUMN pats_field_of_search.field_of_search IS 'tds:foss
Field of Search: Only in EPB is electronic A3 available (scanned search reports cant be used). Field of Search - 1st class/subclass entry - omit prior to first FOS entry';


--
-- Name: pats_field_of_search_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pats_field_of_search_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pats_field_of_search_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pats_field_of_search_id_seq OWNED BY pats_field_of_search.id;


SET default_tablespace = rpx_user_default;

--
-- Name: pats_invention; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pats_invention (
    id integer NOT NULL,
    app_num_country character varying(30) NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    created_at timestamp(6) without time zone NOT NULL
);


--
-- Name: pats_invention_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pats_invention_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pats_invention_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pats_invention_id_seq OWNED BY pats_invention.id;


--
-- Name: pats_invention_link; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pats_invention_link (
    id integer NOT NULL,
    invention_id integer NOT NULL,
    pat_id integer NOT NULL,
    is_original boolean NOT NULL,
    is_current boolean NOT NULL,
    rnk integer NOT NULL,
    document_type character varying(30) NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    created_at timestamp(6) without time zone NOT NULL
);


--
-- Name: pats_invention_link_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pats_invention_link_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pats_invention_link_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pats_invention_link_id_seq OWNED BY pats_invention_link.id;


--
-- Name: pats_pat_collections_map_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pats_pat_collections_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pats_related_applications_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pats_related_applications_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


SET default_tablespace = '';

--
-- Name: pats_withdrawn; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE pats_withdrawn (
    id integer NOT NULL,
    stripped_patnum character varying(32) NOT NULL
);


--
-- Name: pats_withdrawn_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE pats_withdrawn_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pats_withdrawn_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE pats_withdrawn_id_seq OWNED BY pats_withdrawn.id;


--
-- Name: queue_app_types; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE queue_app_types (
    app_desc text,
    app_id integer NOT NULL
);


--
-- Name: queue_msg_types; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE queue_msg_types (
    msg_type_id integer NOT NULL,
    msg_type_desc text
);


--
-- Name: queue_semaphore; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE queue_semaphore (
    flag integer NOT NULL
);


--
-- Name: rails_admin_histories; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE rails_admin_histories (
    id integer NOT NULL,
    message text,
    username character varying(255),
    item integer,
    "table" character varying(255),
    month smallint,
    year bigint,
    created_at timestamp without time zone,
    updated_at timestamp without time zone
);


--
-- Name: rails_admin_histories_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE rails_admin_histories_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: rails_admin_histories_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE rails_admin_histories_id_seq OWNED BY rails_admin_histories.id;


--
-- Name: ravel_judges; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE ravel_judges (
    id integer NOT NULL,
    judge_ent_id integer,
    judge_name character varying,
    num_of_opinions integer,
    ravel_link text,
    updated_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone NOT NULL,
    created_by character varying(255),
    updated_by character varying(255)
);


--
-- Name: ravel_judges_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE ravel_judges_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ravel_judges_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE ravel_judges_id_seq OWNED BY ravel_judges.id;


--
-- Name: rockstar_assets_dump; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE rockstar_assets_dump (
    case_number text,
    country text,
    app_num_country_raw text,
    stripped_patnum_raw text,
    status text,
    file_date date,
    issue_date date,
    expiration_date date,
    title text,
    app_num_country character varying(2048),
    stripped_patnum character varying(2048)
);


--
-- Name: round_rock_dump; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE round_rock_dump (
    aqf_status character varying(50),
    case_number character varying(50),
    case_type character varying(50),
    patent_number character varying(50),
    publication_number character varying(50),
    application_number character varying(50),
    country character varying(50),
    title text,
    status character varying(50),
    file_date character varying(50),
    publication_date character varying(50),
    issue_date character varying(50),
    current_assignees character varying(50),
    expiration_date character varying(50),
    acquisition_name character varying(50),
    portfolio_name character varying(50),
    priority_date character varying(50),
    cpi_tracking character varying(50),
    annuity_payment_date character varying(50),
    terminal_disclaimer character varying(50),
    rpx_ownership_rights_owned character varying(50),
    rpx_ownership_rights_cns character varying(50),
    rpx_ownership_rights_sublicense character varying(50),
    rpx_ownership_rights_sold character varying(50),
    asset_source character(1),
    asset_source_id integer,
    file_date_date date,
    publication_date_date date,
    issue_date_date date,
    expiration_date_date date,
    priority_date_date date,
    annuity_payment_date_date date,
    id integer,
    acquisition_id integer,
    portfolio_id integer,
    app_num_country character varying(2048)
);


--
-- Name: schema_migrations; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE schema_migrations (
    version character varying(255) NOT NULL
);


SET default_tablespace = rpx_user_default;

--
-- Name: search_doc_misc; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE search_doc_misc (
    value character varying(255),
    key character varying(64)
);


--
-- Name: search_misc; Type: TABLE; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE search_misc (
    "Search_Amended_Complaint" text,
    "Search_Appeal_Outcome" text,
    "Search_Judgment" text,
    "Search_Markman" text,
    "Search_Verdict" text
);


SET default_tablespace = '';

--
-- Name: similar_ents_tmp; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE similar_ents_tmp (
    ent_id integer,
    ent_name character varying,
    ent_id_to_delete integer,
    ent_name_to_delete character varying,
    score integer
);


--
-- Name: tx_sequential_control; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE tx_sequential_control (
    id integer NOT NULL,
    function_name character varying(64),
    description text,
    flag integer
);


--
-- Name: tx_sequential_control_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE tx_sequential_control_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: tx_sequential_control_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE tx_sequential_control_id_seq OWNED BY tx_sequential_control.id;


--
-- Name: unicodes; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE unicodes (
    id integer NOT NULL,
    unicode_char character varying,
    rep_char character varying
);


--
-- Name: unicodes_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE unicodes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: unicodes_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE unicodes_id_seq OWNED BY unicodes.id;


--
-- Name: users; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE users (
    id integer NOT NULL,
    email character varying(255) DEFAULT ''::character varying NOT NULL,
    encrypted_password character varying(128) DEFAULT ''::character varying NOT NULL,
    reset_password_token character varying(255),
    reset_password_sent_at timestamp without time zone,
    remember_created_at timestamp without time zone,
    sign_in_count integer DEFAULT 0,
    current_sign_in_at timestamp without time zone,
    last_sign_in_at timestamp without time zone,
    current_sign_in_ip character varying(255),
    last_sign_in_ip character varying(255),
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    roles_mask integer
);


--
-- Name: TABLE users; Type: COMMENT; Schema: core; Owner: -
--

COMMENT ON TABLE users IS 'This is the user table for the DMA application Comment updated at: 2012-11-06';


--
-- Name: users_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE users_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: users_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE users_id_seq OWNED BY users.id;


--
-- Name: uspcs_classes; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE uspcs_classes (
    id integer NOT NULL,
    code character varying(3) NOT NULL,
    description character varying(1000),
    job_id integer,
    updated_at timestamp without time zone DEFAULT now(),
    created_at timestamp without time zone DEFAULT now()
);


--
-- Name: uspcs_classes_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE uspcs_classes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: uspcs_classes_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE uspcs_classes_id_seq OWNED BY uspcs_classes.id;


--
-- Name: uspcs_subclasses; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE uspcs_subclasses (
    id integer NOT NULL,
    description character varying(1000),
    uspcs_class_id integer,
    code character varying(11),
    orig_code character varying(11),
    parent_uspcs_subclass_id integer,
    job_id integer,
    updated_at timestamp without time zone DEFAULT now(),
    created_at timestamp without time zone DEFAULT now()
);


--
-- Name: uspcs_subclasses_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE uspcs_subclasses_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: uspcs_subclasses_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE uspcs_subclasses_id_seq OWNED BY uspcs_subclasses.id;


--
-- Name: uspcs_to_ipc_mapping; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE uspcs_to_ipc_mapping (
    id integer NOT NULL,
    uspcs_subclass character varying(50),
    ipc_subclass_code character varying(14),
    ipc_subgroup_code character varying(14),
    code_type character varying(5),
    created_at timestamp(6) without time zone DEFAULT now(),
    updated_at timestamp(6) without time zone DEFAULT now()
);


--
-- Name: uspcs_to_ipc_mapping_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE uspcs_to_ipc_mapping_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: uspcs_to_ipc_mapping_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE uspcs_to_ipc_mapping_id_seq OWNED BY uspcs_to_ipc_mapping.id;


--
-- Name: uspto_practitioner_roster; Type: TABLE; Schema: core; Owner: -
--

CREATE TABLE uspto_practitioner_roster (
    id integer NOT NULL,
    alias_id integer,
    firm_name character varying(128),
    role character varying(8),
    emp_status character varying(10),
    registration_number character varying(15),
    alias_contact_id integer,
    missing_from_source_date date,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone
);


--
-- Name: uspto_practioner_roster_id_seq; Type: SEQUENCE; Schema: core; Owner: -
--

CREATE SEQUENCE uspto_practioner_roster_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: uspto_practioner_roster_id_seq; Type: SEQUENCE OWNED BY; Schema: core; Owner: -
--

ALTER SEQUENCE uspto_practioner_roster_id_seq OWNED BY uspto_practitioner_roster.id;


--
-- Name: v_classification; Type: VIEW; Schema: core; Owner: -
--

CREATE VIEW v_classification AS
 SELECT ipc_subgroups.code,
    (((((((((( SELECT ipc_sections.description
           FROM ipc_sections
          WHERE (ipc_sections.id = ipc_subgroups.ipc_section_id)))::text || ' / '::text) || (( SELECT ipc_classes.description
           FROM ipc_classes
          WHERE (ipc_classes.id = ipc_subgroups.ipc_class_id)))::text) || ' / '::text) || (( SELECT ipc_subclasses.description
           FROM ipc_subclasses
          WHERE (ipc_subclasses.id = ipc_subgroups.ipc_subclass_id)))::text) || ' / '::text) || (( SELECT ipc_groups.description
           FROM ipc_groups
          WHERE (ipc_groups.id = ipc_subgroups.ipc_group_id)))::text) || ' / '::text) || (ipc_subgroups.description)::text) AS description
   FROM ipc_subgroups
UNION ALL
 SELECT ipc_groups.code,
    (((((((( SELECT ipc_sections.description
           FROM ipc_sections
          WHERE (ipc_sections.id = ipc_groups.ipc_section_id)))::text || ' / '::text) || (( SELECT ipc_classes.description
           FROM ipc_classes
          WHERE (ipc_classes.id = ipc_groups.ipc_class_id)))::text) || ' / '::text) || (( SELECT ipc_subclasses.description
           FROM ipc_subclasses
          WHERE (ipc_subclasses.id = ipc_groups.ipc_subclass_id)))::text) || ' / '::text) || (ipc_groups.description)::text) AS description
   FROM ipc_groups
UNION ALL
 SELECT ipc_subclasses.code,
    (((((( SELECT ipc_sections.description
           FROM ipc_sections
          WHERE (ipc_sections.id = ipc_subclasses.ipc_section_id)))::text || ' / '::text) || (( SELECT ipc_classes.description
           FROM ipc_classes
          WHERE (ipc_classes.id = ipc_subclasses.ipc_class_id)))::text) || ' / '::text) || (ipc_subclasses.description)::text) AS description
   FROM ipc_subclasses
UNION ALL
 SELECT ipc_classes.code,
    (((( SELECT ipc_sections.description
           FROM ipc_sections
          WHERE (ipc_sections.id = ipc_classes.ipc_section_id)))::text || ' / '::text) || (ipc_classes.description)::text) AS description
   FROM ipc_classes
UNION ALL
 SELECT ipc_sections.code,
    ipc_sections.description
   FROM ipc_sections
UNION ALL
 SELECT uspcs_classes.code,
    uspcs_classes.description
   FROM uspcs_classes
UNION ALL
 SELECT uspcs_subclasses.code,
    (((( SELECT uspcs_classes.description
           FROM uspcs_classes
          WHERE (uspcs_classes.id = uspcs_subclasses.uspcs_class_id)))::text || ' / '::text) || (uspcs_subclasses.description)::text) AS description
   FROM uspcs_subclasses;


--
-- Name: v_lit_parties; Type: VIEW; Schema: core; Owner: -
--

CREATE VIEW v_lit_parties AS
 SELECT p.id AS lit_parties_id,
    p.alias_id AS party_alias_id,
    e1.id AS party_ent_id,
    p.lit_party_type_id,
    p.lit_id,
    p.start_date,
    p.missing_from_source_date,
    COALESCE(p.end_date, '3001-01-01'::date) AS end_date,
    p.is_verified,
    pt.name AS party_type,
    pt.lit_party_normalized_type,
    pr.lawfirm_alias_id,
    pr.lawyer_alias_id,
    pr.id AS lit_party_representation_id,
    a2.name AS lawfirm,
    a3.name AS lawyer,
    e1.name AS party_name,
    a1.name AS party_alias_name,
    e1.rollup_parent_id AS rollup_parent_ent_id,
    e1.ultimate_parent_id AS ultimate_parent_ent_id,
    ( SELECT COALESCE(lits.closed_date, '3001-01-01'::date) AS "coalesce"
           FROM lits
          WHERE (lits.id = p.lit_id)) AS lit_closed_date,
        CASE
            WHEN ((p.dj_party_normalized_type)::text = 'defendant'::text) THEN 2
            WHEN ((p.dj_party_normalized_type)::text = 'plaintiff'::text) THEN 1
            ELSE 0
        END AS party_type_portal_id,
    p.dj_party_normalized_type
   FROM (((lit_parties p
     JOIN lit_party_types pt ON ((p.lit_party_type_id = pt.id)))
     LEFT JOIN ((lit_parties_representations pr
     LEFT JOIN aliases a2 ON ((pr.lawfirm_alias_id = a2.id)))
     LEFT JOIN aliases a3 ON ((pr.lawyer_alias_id = a3.id))) ON ((p.id = pr.lit_parties_id)))
     LEFT JOIN (aliases a1
     LEFT JOIN ents e1 ON ((a1.ent_id = e1.id))) ON ((p.alias_id = a1.id)));


SET search_path = ptab, pg_catalog;

--
-- Name: ptab_case_details; Type: TABLE; Schema: ptab; Owner: -
--

CREATE TABLE ptab_case_details (
    id integer NOT NULL,
    ptab_case_id integer NOT NULL,
    ptab_case_detail_party_type_id integer NOT NULL,
    doc_name character varying(500) NOT NULL,
    doc_type character varying(100),
    exhibit_num integer NOT NULL,
    filing_date date NOT NULL,
    availability character varying(50) NOT NULL,
    document_path character varying(300),
    attachment_handle character varying(100),
    attachment_url character varying(500),
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    created_by character varying(15) NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_by character varying(15) NOT NULL,
    is_dcl_corrected boolean DEFAULT false,
    attachment_type character varying(100),
    missing_from_source_date date,
    attachment_name character varying(500),
    ocr_text text,
    ocr_completed_at timestamp without time zone,
    needs_ocr boolean DEFAULT false
);


--
-- Name: COLUMN ptab_case_details.document_path; Type: COMMENT; Schema: ptab; Owner: -
--

COMMENT ON COLUMN ptab_case_details.document_path IS 'Path of the document in Amazon S3 is stored in this field.';


--
-- Name: COLUMN ptab_case_details.missing_from_source_date; Type: COMMENT; Schema: ptab; Owner: -
--

COMMENT ON COLUMN ptab_case_details.missing_from_source_date IS 'Date when we finalized (after confirming after multiple crawls) that this record is no longer in the site';


--
-- Name: ptab_party_types; Type: TABLE; Schema: ptab; Owner: -
--

CREATE TABLE ptab_party_types (
    id integer NOT NULL,
    name character varying(50) NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    created_by character varying(15) NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_by character varying(15) NOT NULL,
    is_default boolean
);


--
-- Name: ptab_case_types_id_seq; Type: SEQUENCE; Schema: ptab; Owner: -
--

CREATE SEQUENCE ptab_case_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ptab_case_types; Type: TABLE; Schema: ptab; Owner: -
--

CREATE TABLE ptab_case_types (
    id integer DEFAULT nextval('ptab_case_types_id_seq'::regclass) NOT NULL,
    case_type character varying(4) NOT NULL,
    case_type_desc character varying(50) NOT NULL,
    created_at timestamp(6) without time zone DEFAULT now() NOT NULL,
    created_by character varying(15) NOT NULL,
    updated_at timestamp(6) without time zone DEFAULT now() NOT NULL,
    updated_by character varying(15) NOT NULL,
    is_default boolean
);


--
-- Name: COLUMN ptab_case_types.case_type; Type: COMMENT; Schema: ptab; Owner: -
--

COMMENT ON COLUMN ptab_case_types.case_type IS 'first 3 characters from case number';


--
-- Name: COLUMN ptab_case_types.case_type_desc; Type: COMMENT; Schema: ptab; Owner: -
--

COMMENT ON COLUMN ptab_case_types.case_type_desc IS 'brief description of the case type';


SET search_path = docdb, pg_catalog;

--
-- Name: docdb_abstracts_id_seq; Type: SEQUENCE; Schema: docdb; Owner: -
--

CREATE SEQUENCE docdb_abstracts_id_seq
    START WITH 90000000000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


SET default_tablespace = rpx_user_default;

--
-- Name: docdb_abstracts; Type: TABLE; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE docdb_abstracts (
    id bigint DEFAULT nextval('docdb_abstracts_id_seq'::regclass) NOT NULL,
    pat_id bigint NOT NULL,
    text text NOT NULL,
    lang character varying(255),
    updated_at timestamp(6) without time zone,
    created_at timestamp(6) without time zone,
    source character varying(255),
    country character varying(255),
    doc_number character varying(255),
    kind character varying(255),
    date_published character varying(255),
    status character varying(255),
    data_format character varying(255),
    batch_id integer,
    run_id integer
);


--
-- Name: docdb_applicants_id_seq; Type: SEQUENCE; Schema: docdb; Owner: -
--

CREATE SEQUENCE docdb_applicants_id_seq
    START WITH 90000000000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: docdb_applicants; Type: TABLE; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE docdb_applicants (
    id bigint DEFAULT nextval('docdb_applicants_id_seq'::regclass) NOT NULL,
    pat_id bigint NOT NULL,
    name character varying(2048),
    country character varying(255),
    sequence character varying(255),
    data_format character varying(255),
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    app_type character varying(255),
    designation character varying(255),
    status character varying(255),
    address character varying(255),
    nationality character varying(255),
    us_rights character varying(255),
    designated_states character varying(250),
    designated_states_as_inventor character varying(255),
    batch_id integer,
    run_id integer
);


--
-- Name: docdb_batch; Type: TABLE; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE docdb_batch (
    id integer NOT NULL,
    info text,
    range character varying(255),
    procedure character varying(255),
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    run_id integer
);


--
-- Name: docdb_batch_id_seq; Type: SEQUENCE; Schema: docdb; Owner: -
--

CREATE SEQUENCE docdb_batch_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: docdb_batch_id_seq; Type: SEQUENCE OWNED BY; Schema: docdb; Owner: -
--

ALTER SEQUENCE docdb_batch_id_seq OWNED BY docdb_batch.id;


--
-- Name: docdb_citations_id_seq; Type: SEQUENCE; Schema: docdb; Owner: -
--

CREATE SEQUENCE docdb_citations_id_seq
    START WITH 90000000000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: docdb_citations; Type: TABLE; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE docdb_citations (
    id bigint DEFAULT nextval('docdb_citations_id_seq'::regclass) NOT NULL,
    pat_id bigint NOT NULL,
    cit_id character varying(255),
    srep_phase character varying(255),
    srep_office character varying(255),
    sequence character varying(255),
    sub_id character varying(255),
    num character varying(255),
    dnum character varying(255),
    dnum_type character varying(255),
    file character varying(255),
    url character varying(255),
    lang character varying(255),
    npl_type character varying(255),
    medium character varying(255),
    country character varying(255),
    doc_number character varying(255),
    kind character varying(255),
    name character varying(255),
    text text,
    article character varying(255),
    book character varying(255),
    online character varying(255),
    othercit character varying(255),
    rel_passage character varying(255),
    document_id character varying(255),
    refno character varying(255),
    category character varying(255),
    rel_claims character varying(255),
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    batch_id integer,
    run_id integer,
    date date
);


--
-- Name: docdb_classifications_id_seq; Type: SEQUENCE; Schema: docdb; Owner: -
--

CREATE SEQUENCE docdb_classifications_id_seq
    START WITH 90000000000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: docdb_classifications; Type: TABLE; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE docdb_classifications (
    id bigint DEFAULT nextval('docdb_classifications_id_seq'::regclass) NOT NULL,
    pat_id bigint NOT NULL,
    sequence character varying(255),
    office character varying(255),
    scheme character varying(255),
    classification character varying(255),
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    batch_id integer,
    run_id integer
);


--
-- Name: docdb_ipcs_id_seq; Type: SEQUENCE; Schema: docdb; Owner: -
--

CREATE SEQUENCE docdb_ipcs_id_seq
    START WITH 90000000000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: docdb_ipcs; Type: TABLE; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE docdb_ipcs (
    id bigint DEFAULT nextval('docdb_ipcs_id_seq'::regclass) NOT NULL,
    pat_id bigint NOT NULL,
    sequence character varying(255),
    ipc_ipcr_text character varying(255),
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    type character varying(255),
    edition character varying(255),
    batch_id integer,
    run_id integer
);


--
-- Name: docdb_logs; Type: TABLE; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE docdb_logs (
    id bigint NOT NULL,
    batch_id integer,
    procedure character varying(255),
    action text,
    table_name character varying(255),
    total_processed integer,
    status character varying(25),
    updated_at timestamp without time zone,
    created_at timestamp without time zone
);


--
-- Name: docdb_logs_id_seq; Type: SEQUENCE; Schema: docdb; Owner: -
--

CREATE SEQUENCE docdb_logs_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: docdb_logs_id_seq; Type: SEQUENCE OWNED BY; Schema: docdb; Owner: -
--

ALTER SEQUENCE docdb_logs_id_seq OWNED BY docdb_logs.id;


--
-- Name: docdb_national_classifications_id_seq; Type: SEQUENCE; Schema: docdb; Owner: -
--

CREATE SEQUENCE docdb_national_classifications_id_seq
    START WITH 90000000000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: docdb_national_classifications; Type: TABLE; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE docdb_national_classifications (
    id bigint DEFAULT nextval('docdb_national_classifications_id_seq'::regclass) NOT NULL,
    pat_id bigint NOT NULL,
    classification_national character varying(2550) NOT NULL,
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    batch_id integer,
    run_id integer
);


--
-- Name: docdb_pats_old; Type: TABLE; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE docdb_pats_old (
    id integer,
    patnum character varying(255),
    is_representative character varying(10),
    originating_office character varying(25),
    status character varying(25),
    filedate character varying,
    title text,
    title_lang character varying(255),
    family_id integer,
    stripped_patnum character varying(255),
    extended_kind_code character varying(255),
    app_num_intl character varying(25),
    app_num_country character varying(25),
    lang_of_publication character varying(25),
    lang_of_filing character varying(25),
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    doc_kind_code character varying(10),
    publication_number character varying(255),
    app_is_representative character varying(255),
    app_kind_code character varying(255),
    date_of_coming_into_force character varying(255),
    previously_filed_app character varying(255),
    country_code character varying(255),
    public_availability_category character varying(255),
    batch_id integer,
    run_id integer,
    publication_date_history character varying(255),
    issue_date date,
    app_date date,
    date_of_last_exchange date,
    date_of_previous_exchange date,
    publication_date date,
    date_added_docdb date,
    preceding_publication_date date,
    public_availability_date date,
    doc_number character varying(255),
    pat_family_processed boolean
);


--
-- Name: docdb_pats_revision_history; Type: TABLE; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE docdb_pats_revision_history (
    pat_id integer,
    patnum character varying(255),
    zip_file_name character varying(255),
    xml_file_name character varying(255),
    status character varying(50),
    week integer,
    year integer
);


--
-- Name: docdb_priority_claims_id_seq; Type: SEQUENCE; Schema: docdb; Owner: -
--

CREATE SEQUENCE docdb_priority_claims_id_seq
    START WITH 90000000000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: docdb_priority_claims; Type: TABLE; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE docdb_priority_claims (
    id bigint DEFAULT nextval('docdb_priority_claims_id_seq'::regclass) NOT NULL,
    pat_id bigint NOT NULL,
    sequence character varying(255),
    doc_number character varying(255),
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    claim_id character varying(255),
    data_format character varying(255),
    status character varying(255),
    lang character varying(255),
    country character varying(255),
    kind character varying(255),
    name character varying(255),
    office_of_filing character varying(255),
    priority_doc_requested character varying(255),
    priority_doc_attached character varying(255),
    priority_linkage_type character varying(255),
    priority_active_indicator character varying(255),
    batch_id integer,
    run_id integer,
    doc_date date,
    is_rpx_disabled boolean
);


--
-- Name: docdb_titles_id_seq; Type: SEQUENCE; Schema: docdb; Owner: -
--

CREATE SEQUENCE docdb_titles_id_seq
    START WITH 90000000000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: docdb_titles; Type: TABLE; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE docdb_titles (
    id bigint DEFAULT nextval('docdb_titles_id_seq'::regclass) NOT NULL,
    pat_id bigint NOT NULL,
    title text,
    lang character varying(255),
    data_format character varying(255),
    updated_at timestamp without time zone,
    created_at timestamp without time zone,
    batch_id integer,
    run_id integer
);


--
-- Name: inpadoc_ipr_events; Type: TABLE; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE inpadoc_ipr_events (
    id integer NOT NULL,
    country_code character varying(2),
    doc_format character varying(1),
    doc_number character varying(20),
    doc_kind_code character varying(2),
    ipr_type character varying(2),
    legal_event_date date,
    legal_event_code character varying(4),
    status character varying(1),
    pub_date date,
    pub_number character varying(17),
    last_date_exchanged date,
    event_created_date date,
    app_doc_id integer,
    national_office_code character varying(2),
    national_event_code character varying(4),
    national_doc_number character varying(20),
    national_country_code character varying(2),
    national_pub_date date,
    national_doc_kind_code character varying(2),
    states character varying(300),
    ext_state character varying(20),
    owner_name character varying(200),
    free_format_text text,
    spc_number character varying(30),
    spc_filing_date date,
    exp_date date,
    pub_lang character varying(2),
    inventor_name character varying(200),
    ipc text,
    representative_name character varying(200),
    payment_date date,
    opponent_name character varying(200),
    year_of_payment integer,
    requester_name character varying(200),
    spc_ext_date date,
    ext_states character varying(100),
    effective_date date,
    withdrawal_date date
);


--
-- Name: inpadoc_legal_status_codes; Type: TABLE; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE inpadoc_legal_status_codes (
    id integer NOT NULL,
    country_code character varying(2),
    legal_status_code character varying(4),
    impact character varying(1),
    description text
);


--
-- Name: log_data; Type: TABLE; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE log_data (
    id bigint NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    log_level_id integer NOT NULL,
    app_id integer,
    app_name character varying(50),
    run_id integer,
    db_user name DEFAULT "current_user"() NOT NULL,
    client_host character varying(512) DEFAULT COALESCE(((inet_client_addr() || ':'::text) || inet_client_port()), 'LOCAL'::text) NOT NULL,
    search_path character varying(256) DEFAULT btrim((current_schemas(true))::text, '{}'::text) NOT NULL,
    message text NOT NULL
);


SET default_tablespace = '';

--
-- Name: log_data_201609; Type: TABLE; Schema: docdb; Owner: -
--

CREATE TABLE log_data_201609 (
    CONSTRAINT log_data_201609_created_at_check CHECK (((created_at >= '2016-09-01 00:00:00'::timestamp without time zone) AND (created_at < '2016-10-01 00:00:00'::timestamp without time zone)))
)
INHERITS (log_data);


--
-- Name: log_data_201610; Type: TABLE; Schema: docdb; Owner: -
--

CREATE TABLE log_data_201610 (
    CONSTRAINT log_data_201610_created_at_check CHECK (((created_at >= '2016-10-01 00:00:00'::timestamp without time zone) AND (created_at < '2016-11-01 00:00:00'::timestamp without time zone)))
)
INHERITS (log_data);


--
-- Name: log_data_201611; Type: TABLE; Schema: docdb; Owner: -
--

CREATE TABLE log_data_201611 (
    CONSTRAINT log_data_201611_created_at_check CHECK (((created_at >= '2016-11-01 00:00:00'::timestamp without time zone) AND (created_at < '2016-12-01 00:00:00'::timestamp without time zone)))
)
INHERITS (log_data);


--
-- Name: log_data_201612; Type: TABLE; Schema: docdb; Owner: -
--

CREATE TABLE log_data_201612 (
    CONSTRAINT log_data_201612_created_at_check CHECK (((created_at >= '2016-12-01 00:00:00'::timestamp without time zone) AND (created_at < '2017-01-01 00:00:00'::timestamp without time zone)))
)
INHERITS (log_data);


--
-- Name: log_data_201701; Type: TABLE; Schema: docdb; Owner: -
--

CREATE TABLE log_data_201701 (
    CONSTRAINT log_data_201701_created_at_check CHECK (((created_at >= '2017-01-01 00:00:00'::timestamp without time zone) AND (created_at < '2017-02-01 00:00:00'::timestamp without time zone)))
)
INHERITS (log_data);


--
-- Name: log_data_201702; Type: TABLE; Schema: docdb; Owner: -
--

CREATE TABLE log_data_201702 (
    CONSTRAINT log_data_201702_created_at_check CHECK (((created_at >= '2017-02-01 00:00:00'::timestamp without time zone) AND (created_at < '2017-03-01 00:00:00'::timestamp without time zone)))
)
INHERITS (log_data);


--
-- Name: log_data_201703; Type: TABLE; Schema: docdb; Owner: -
--

CREATE TABLE log_data_201703 (
    CONSTRAINT log_data_201703_created_at_check CHECK (((created_at >= '2017-03-01 00:00:00'::timestamp without time zone) AND (created_at < '2017-04-01 00:00:00'::timestamp without time zone)))
)
INHERITS (log_data);


--
-- Name: log_data_201704; Type: TABLE; Schema: docdb; Owner: -
--

CREATE TABLE log_data_201704 (
    CONSTRAINT log_data_201704_created_at_check CHECK (((created_at >= '2017-04-01 00:00:00'::timestamp without time zone) AND (created_at < '2017-05-01 00:00:00'::timestamp without time zone)))
)
INHERITS (log_data);


--
-- Name: log_data_201705; Type: TABLE; Schema: docdb; Owner: -
--

CREATE TABLE log_data_201705 (
    CONSTRAINT log_data_201705_created_at_check CHECK (((created_at >= '2017-05-01 00:00:00'::timestamp without time zone) AND (created_at < '2017-06-01 00:00:00'::timestamp without time zone)))
)
INHERITS (log_data);


--
-- Name: log_data_201706; Type: TABLE; Schema: docdb; Owner: -
--

CREATE TABLE log_data_201706 (
    CONSTRAINT log_data_201706_created_at_check CHECK (((created_at >= '2017-06-01 00:00:00'::timestamp without time zone) AND (created_at < '2017-07-01 00:00:00'::timestamp without time zone)))
)
INHERITS (log_data);


--
-- Name: log_data_201707; Type: TABLE; Schema: docdb; Owner: -
--

CREATE TABLE log_data_201707 (
    CONSTRAINT log_data_201707_created_at_check CHECK (((created_at >= '2017-07-01 00:00:00'::timestamp without time zone) AND (created_at < '2017-08-01 00:00:00'::timestamp without time zone)))
)
INHERITS (log_data);


--
-- Name: log_data_201708; Type: TABLE; Schema: docdb; Owner: -
--

CREATE TABLE log_data_201708 (
    CONSTRAINT log_data_201708_created_at_check CHECK (((created_at >= '2017-08-01 00:00:00'::timestamp without time zone) AND (created_at < '2017-09-01 00:00:00'::timestamp without time zone)))
)
INHERITS (log_data);


--
-- Name: log_data_id_seq; Type: SEQUENCE; Schema: docdb; Owner: -
--

CREATE SEQUENCE log_data_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: log_data_id_seq; Type: SEQUENCE OWNED BY; Schema: docdb; Owner: -
--

ALTER SEQUENCE log_data_id_seq OWNED BY log_data.id;


SET default_tablespace = rpx_user_default;

--
-- Name: pat_normalized_family_relationships; Type: TABLE; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE pat_normalized_family_relationships (
    patnum character varying(255),
    docdb_pat_id bigint,
    core_pat_id integer,
    invention_id integer,
    pat_is_current boolean,
    related_patnum character varying(255),
    related_docdb_pat_id integer,
    related_core_pat_id integer,
    related_invention_id integer,
    related_pat_is_current boolean,
    relationship_type text,
    pat_family_id integer,
    id integer NOT NULL
);


--
-- Name: pat_normalized_family_relationships_id_seq; Type: SEQUENCE; Schema: docdb; Owner: -
--

CREATE SEQUENCE pat_normalized_family_relationships_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pat_normalized_family_relationships_id_seq; Type: SEQUENCE OWNED BY; Schema: docdb; Owner: -
--

ALTER SEQUENCE pat_normalized_family_relationships_id_seq OWNED BY pat_normalized_family_relationships.id;


--
-- Name: v_docdb_priority_claims; Type: VIEW; Schema: docdb; Owner: -
--

CREATE VIEW v_docdb_priority_claims AS
 SELECT docdb_priority_claims.id,
    docdb_priority_claims.pat_id,
    docdb_priority_claims.sequence,
    docdb_priority_claims.doc_number,
    docdb_priority_claims.updated_at,
    docdb_priority_claims.created_at,
    docdb_priority_claims.claim_id,
    docdb_priority_claims.data_format,
    docdb_priority_claims.status,
    docdb_priority_claims.lang,
    docdb_priority_claims.country,
    docdb_priority_claims.kind,
    docdb_priority_claims.name,
    docdb_priority_claims.office_of_filing,
    docdb_priority_claims.priority_doc_requested,
    docdb_priority_claims.priority_doc_attached,
    docdb_priority_claims.priority_linkage_type,
    docdb_priority_claims.priority_active_indicator,
    docdb_priority_claims.batch_id,
    docdb_priority_claims.run_id,
    docdb_priority_claims.doc_date,
    docdb_priority_claims.is_rpx_disabled
   FROM docdb_priority_claims
  WHERE ((docdb_priority_claims.is_rpx_disabled IS NULL) OR (docdb_priority_claims.is_rpx_disabled = false));


--
-- Name: v_docdb_priority_claims_normalized; Type: VIEW; Schema: docdb; Owner: -
--

CREATE VIEW v_docdb_priority_claims_normalized AS
 SELECT t.id,
    t.patnum,
    t.docdb_pat_id,
    t.related_patnum,
    t.related_docdb_pat_id,
    t.relationship_type,
    t.pat_family_id
   FROM ( SELECT a.id,
            a.pat_id AS docdb_pat_id,
            h1.patnum,
                CASE COALESCE(a.priority_linkage_type, '-100'::character varying)
                    WHEN '1'::text THEN 'continuation'::text
                    WHEN '2'::text THEN 'continuation in part'::text
                    WHEN '3'::text THEN 'division'::text
                    WHEN '4'::text THEN 'substitute'::text
                    ELSE 'priority'::text
                END AS relationship_type,
            h.id AS related_docdb_pat_id,
            h.patnum AS related_patnum,
            pfp.pat_family_id
           FROM docdb_priority_claims a,
            docdb_pats h,
            docdb_pats h1,
            docdb_families.pat_family_pats pfp
          WHERE ((pfp.pat_id = a.pat_id) AND ((a.data_format)::text = 'docdb'::text) AND (a.pat_id = h1.id) AND ((a.doc_number)::text = (h.app_num_intl)::text) AND (a.doc_date = h.app_date) AND ((a.country)::text = (h.app_num_country)::text))) t
  WHERE (t.docdb_pat_id <> t.related_docdb_pat_id);


--
-- Name: v_pat_normalized_family_relationships; Type: VIEW; Schema: docdb; Owner: -
--

CREATE VIEW v_pat_normalized_family_relationships AS
 SELECT t.patnum,
    t.docdb_pat_id,
    t.core_pat_id,
        CASE
            WHEN (t.core_pat_id IS NOT NULL) THEN ( SELECT pats_invention_link.invention_id
               FROM core.pats_invention_link
              WHERE (pats_invention_link.pat_id = t.core_pat_id)
             LIMIT 1)
            ELSE NULL::integer
        END AS invention_id,
        CASE
            WHEN (t.core_pat_id IS NOT NULL) THEN ( SELECT pats_invention_link.is_current
               FROM core.pats_invention_link
              WHERE (pats_invention_link.pat_id = t.core_pat_id)
             LIMIT 1)
            ELSE NULL::boolean
        END AS pat_is_current,
    t.related_patnum,
    t.related_docdb_pat_id,
    t.related_core_pat_id,
        CASE
            WHEN (t.related_core_pat_id IS NOT NULL) THEN ( SELECT pats_invention_link.invention_id
               FROM core.pats_invention_link
              WHERE (pats_invention_link.pat_id = t.related_core_pat_id)
             LIMIT 1)
            ELSE NULL::integer
        END AS related_invention_id,
        CASE
            WHEN (t.related_core_pat_id IS NOT NULL) THEN ( SELECT pats_invention_link.is_current
               FROM core.pats_invention_link
              WHERE (pats_invention_link.pat_id = t.related_core_pat_id)
             LIMIT 1)
            ELSE NULL::boolean
        END AS related_pat_is_current,
    t.relationship_type,
    t.pat_family_id
   FROM ( SELECT a.pat_id AS docdb_pat_id,
            h1.patnum,
            ( SELECT
                        CASE
                            WHEN ((h1.country_code)::text = 'US'::text) THEN ( SELECT p.id
                               FROM core.pats p
                              WHERE (((p.stripped_patnum)::text = (h1.stripped_patnum)::text) AND ((h1.country_code)::text = 'US'::text))
                             LIMIT 1)
                            ELSE NULL::integer
                        END AS "case") AS core_pat_id,
                CASE COALESCE(a.priority_linkage_type, '-100'::character varying)
                    WHEN '1'::text THEN 'continuation'::text
                    WHEN '2'::text THEN 'continuation in part'::text
                    WHEN '3'::text THEN 'division'::text
                    WHEN '4'::text THEN 'substitute'::text
                    ELSE 'priority'::text
                END AS relationship_type,
            h.id AS related_docdb_pat_id,
            h.patnum AS related_patnum,
            ( SELECT
                        CASE
                            WHEN ((a.country)::text = 'US'::text) THEN ( SELECT p.id
                               FROM core.pats p
                              WHERE (((p.stripped_patnum)::text = (h.stripped_patnum)::text) AND ((h.country_code)::text = 'US'::text))
                             LIMIT 1)
                            ELSE NULL::integer
                        END AS "case") AS related_core_pat_id,
            pfp.pat_family_id
           FROM docdb_priority_claims a,
            docdb_pats h,
            docdb_pats h1,
            docdb_families.pat_family_pats pfp
          WHERE ((pfp.pat_id = a.pat_id) AND ((a.data_format)::text = 'docdb'::text) AND (a.pat_id = h1.id) AND ((a.doc_number)::text = (h.app_num_intl)::text) AND (a.doc_date = h.app_date) AND ((a.country)::text = (h.app_num_country)::text))) t
  WHERE (t.docdb_pat_id <> t.related_docdb_pat_id);


SET search_path = ptab, pg_catalog;

SET default_tablespace = '';

--
-- Name: ptab_case_detail_party_types; Type: TABLE; Schema: ptab; Owner: -
--

CREATE TABLE ptab_case_detail_party_types (
    id integer NOT NULL,
    name character varying(50) NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    created_by character varying(15) NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_by character varying(15) NOT NULL,
    is_default boolean
);


--
-- Name: COLUMN ptab_case_detail_party_types.name; Type: COMMENT; Schema: ptab; Owner: -
--

COMMENT ON COLUMN ptab_case_detail_party_types.name IS 'Filing Party value from ptab website in documents page';


--
-- Name: v_ptab_details; Type: TABLE; Schema: ptab; Owner: -
--

CREATE TABLE v_ptab_details (
    ptab_case_id integer,
    stripped_patnum character varying(255),
    full_patnum character varying(255),
    country_code character varying(16),
    pat_id integer,
    patent_family_id integer,
    case_number character varying(255),
    review_type character varying(255),
    filing_date date,
    institution_date date,
    go_no_go integer,
    application_num character varying(255),
    petitioner_alias_name character varying(255),
    petitioner_alias_id integer,
    petitioner_ent_id integer,
    petitioner_ent_name character varying,
    petitioner_ult_parent_name character varying,
    petitioner_ult_parent_id integer,
    petitioner_ult_parent_sf_type character varying(255),
    petitioner_ent_npe_check integer,
    patent_owner_alias_name character varying(255),
    patent_owner_alias_id integer,
    patent_owner_ent_id integer,
    patent_owner_ent_name character varying,
    patent_owner_ult_parent_name character varying,
    patent_owner_ult_parent_id integer,
    patent_owner_ult_parent_owner_sf_type character varying(255),
    patent_owner_ent_npe_check integer,
    status character varying(255),
    tech_center character varying(255),
    us_class_current character varying(2048),
    field_of_search character varying(4096),
    campaign_id integer[],
    campaign_names text[]
);

ALTER TABLE ONLY v_ptab_details REPLICA IDENTITY NOTHING;


--
-- Name: ptab_annotations; Type: TABLE; Schema: ptab; Owner: -
--

CREATE TABLE ptab_annotations (
    id integer NOT NULL,
    ptab_case_id integer NOT NULL,
    case_type_id integer NOT NULL,
    created_by character varying(255) DEFAULT "current_user"() NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_by character varying(255) DEFAULT "current_user"() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE ptab_annotations; Type: COMMENT; Schema: ptab; Owner: -
--

COMMENT ON TABLE ptab_annotations IS ' This table contains data which is extracted from ptab.find_ptab_case_type() ';


SET default_tablespace = rpx_user_default;

--
-- Name: ptab_attorney; Type: TABLE; Schema: ptab; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE ptab_attorney (
    id integer NOT NULL,
    petition_id integer,
    ptab_petition_party_id bigint,
    attorney_name text,
    attorney_alias_id integer,
    lawfirm_name text,
    lawfirm_alias_id integer,
    lawfirm_alias_contact_id integer,
    ptab_case_id bigint,
    ptab_party_id bigint,
    created_by text DEFAULT "current_user"() NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_by text DEFAULT "current_user"() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


--
-- Name: technology_centers; Type: TABLE; Schema: ptab; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE technology_centers (
    id integer NOT NULL,
    tech_center_number character varying(100),
    description text,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by character varying(15) DEFAULT "current_user"(),
    updated_by character varying(15) DEFAULT "current_user"()
);


SET default_tablespace = '';

--
-- Name: ipr_vw; Type: TABLE; Schema: ptab; Owner: -
--

CREATE TABLE ipr_vw (
    stripped_patnum character varying(255),
    full_patnum character varying(255),
    country_code character varying(16),
    pat_id integer,
    patent_family_id integer,
    case_number character varying(255),
    review_type character varying(255),
    filing_date date,
    institution_date date,
    go_no_go integer,
    application_num character varying(255),
    petitioner_entry_name character varying(255),
    petitioner_ent_id integer,
    petitioner_ent_name character varying,
    petitioner_ult_parent character varying,
    petitioner_ult_parent_sf_type character varying(255),
    petitioner_npe_check integer,
    patent_owner_name character varying(255),
    patent_owner_ent_id integer,
    patent_owner_ent_name character varying,
    patent_owner_ult_parent character varying,
    patent_owner_ult_parent_owner_sf_type character varying(255),
    patent_owner_npe_check integer,
    status character varying(255),
    tech_center character varying(255),
    us_class_current character varying(2048),
    field_of_search character varying(4096),
    campaign_id integer[],
    campaign_names text[]
);

ALTER TABLE ONLY ipr_vw REPLICA IDENTITY NOTHING;


--
-- Name: ptab_annotations_id_seq; Type: SEQUENCE; Schema: ptab; Owner: -
--

CREATE SEQUENCE ptab_annotations_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ptab_annotations_id_seq; Type: SEQUENCE OWNED BY; Schema: ptab; Owner: -
--

ALTER SEQUENCE ptab_annotations_id_seq OWNED BY ptab_annotations.id;


--
-- Name: ptab_attorney_id_seq; Type: SEQUENCE; Schema: ptab; Owner: -
--

CREATE SEQUENCE ptab_attorney_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ptab_attorney_id_seq; Type: SEQUENCE OWNED BY; Schema: ptab; Owner: -
--

ALTER SEQUENCE ptab_attorney_id_seq OWNED BY ptab_attorney.id;


--
-- Name: ptab_case_detail_party_types_id_seq; Type: SEQUENCE; Schema: ptab; Owner: -
--

CREATE SEQUENCE ptab_case_detail_party_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ptab_case_detail_party_types_id_seq; Type: SEQUENCE OWNED BY; Schema: ptab; Owner: -
--

ALTER SEQUENCE ptab_case_detail_party_types_id_seq OWNED BY ptab_case_detail_party_types.id;


--
-- Name: ptab_case_details_id_seq; Type: SEQUENCE; Schema: ptab; Owner: -
--

CREATE SEQUENCE ptab_case_details_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ptab_case_details_id_seq; Type: SEQUENCE OWNED BY; Schema: ptab; Owner: -
--

ALTER SEQUENCE ptab_case_details_id_seq OWNED BY ptab_case_details.id;


--
-- Name: ptab_case_relationships; Type: TABLE; Schema: ptab; Owner: -
--

CREATE TABLE ptab_case_relationships (
    id integer NOT NULL,
    lead_case_id integer NOT NULL,
    joined_case_id integer NOT NULL,
    join_date date DEFAULT now() NOT NULL,
    created_by text DEFAULT "current_user"() NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_by text DEFAULT "current_user"() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


--
-- Name: ptab_case_relationships_id_seq; Type: SEQUENCE; Schema: ptab; Owner: -
--

CREATE SEQUENCE ptab_case_relationships_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ptab_case_relationships_id_seq; Type: SEQUENCE OWNED BY; Schema: ptab; Owner: -
--

ALTER SEQUENCE ptab_case_relationships_id_seq OWNED BY ptab_case_relationships.id;


--
-- Name: ptab_case_status_changes; Type: TABLE; Schema: ptab; Owner: -
--

CREATE TABLE ptab_case_status_changes (
    id integer NOT NULL,
    ptab_case_id integer NOT NULL,
    case_status character varying(64),
    date_entered timestamp without time zone DEFAULT clock_timestamp() NOT NULL,
    created_at timestamp without time zone DEFAULT clock_timestamp() NOT NULL,
    created_by character varying(15) DEFAULT "current_user"() NOT NULL,
    updated_at timestamp without time zone DEFAULT clock_timestamp() NOT NULL,
    updated_by character varying(15) DEFAULT "current_user"() NOT NULL
);


--
-- Name: TABLE ptab_case_status_changes; Type: COMMENT; Schema: ptab; Owner: -
--

COMMENT ON TABLE ptab_case_status_changes IS 'Captures history of changes in ptab.status field';


--
-- Name: COLUMN ptab_case_status_changes.case_status; Type: COMMENT; Schema: ptab; Owner: -
--

COMMENT ON COLUMN ptab_case_status_changes.case_status IS 'old Status value';


--
-- Name: ptab_case_status_changes_id_seq; Type: SEQUENCE; Schema: ptab; Owner: -
--

CREATE SEQUENCE ptab_case_status_changes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ptab_case_status_changes_id_seq; Type: SEQUENCE OWNED BY; Schema: ptab; Owner: -
--

ALTER SEQUENCE ptab_case_status_changes_id_seq OWNED BY ptab_case_status_changes.id;


--
-- Name: ptab_cases_api; Type: TABLE; Schema: ptab; Owner: -
--

CREATE TABLE ptab_cases_api (
    ptab_case_id integer,
    case_num character varying(20) NOT NULL,
    inventor_name character varying(500),
    prosecution_status character varying(100),
    accorded_filing_date date
);


--
-- Name: ptab_cases_id_seq; Type: SEQUENCE; Schema: ptab; Owner: -
--

CREATE SEQUENCE ptab_cases_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ptab_cases_id_seq; Type: SEQUENCE OWNED BY; Schema: ptab; Owner: -
--

ALTER SEQUENCE ptab_cases_id_seq OWNED BY ptab_cases.id;


SET default_tablespace = rpx_user_default;

--
-- Name: ptab_doc_types; Type: TABLE; Schema: ptab; Owner: -; Tablespace: rpx_user_default
--

CREATE TABLE ptab_doc_types (
    id integer NOT NULL,
    doc_type character varying(100) NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL
);


--
-- Name: ptab_doc_types_id_seq; Type: SEQUENCE; Schema: ptab; Owner: -
--

CREATE SEQUENCE ptab_doc_types_id_seq
    START WITH 19
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ptab_doc_types_id_seq; Type: SEQUENCE OWNED BY; Schema: ptab; Owner: -
--

ALTER SEQUENCE ptab_doc_types_id_seq OWNED BY ptab_doc_types.id;


--
-- Name: ptab_etl_properties_id_seq; Type: SEQUENCE; Schema: ptab; Owner: -
--

CREATE SEQUENCE ptab_etl_properties_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


SET default_tablespace = '';

--
-- Name: ptab_etl_properties; Type: TABLE; Schema: ptab; Owner: -
--

CREATE TABLE ptab_etl_properties (
    id integer DEFAULT nextval('ptab_etl_properties_id_seq'::regclass) NOT NULL,
    property_name character varying(50),
    property_datatype character varying(50),
    property_value character varying(100),
    job_id integer,
    updated_at timestamp(6) without time zone
);


--
-- Name: ptab_expert_info_id_seq; Type: SEQUENCE; Schema: ptab; Owner: -
--

CREATE SEQUENCE ptab_expert_info_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ptab_expert_info_id_seq; Type: SEQUENCE OWNED BY; Schema: ptab; Owner: -
--

ALTER SEQUENCE ptab_expert_info_id_seq OWNED BY ptab_expert_info.src_id;


--
-- Name: ptab_judges_map_id_seq; Type: SEQUENCE; Schema: ptab; Owner: -
--

CREATE SEQUENCE ptab_judges_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ptab_judges_map_id_seq; Type: SEQUENCE OWNED BY; Schema: ptab; Owner: -
--

ALTER SEQUENCE ptab_judges_map_id_seq OWNED BY ptab_judges_map.id;


--
-- Name: ptab_parties_deleted; Type: TABLE; Schema: ptab; Owner: -
--

CREATE TABLE ptab_parties_deleted (
    ptab_case_id integer,
    ptab_party_type_id integer,
    alias_id integer,
    created_at timestamp without time zone,
    created_by character varying(15),
    updated_at timestamp without time zone,
    updated_by character varying(15),
    id integer,
    is_primary boolean,
    missing_from_source_date date
);


--
-- Name: ptab_parties_id_seq; Type: SEQUENCE; Schema: ptab; Owner: -
--

CREATE SEQUENCE ptab_parties_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ptab_parties_id_seq; Type: SEQUENCE OWNED BY; Schema: ptab; Owner: -
--

ALTER SEQUENCE ptab_parties_id_seq OWNED BY ptab_parties.id;


--
-- Name: ptab_parties_representations_id_seq; Type: SEQUENCE; Schema: ptab; Owner: -
--

CREATE SEQUENCE ptab_parties_representations_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ptab_parties_representations_id_seq; Type: SEQUENCE OWNED BY; Schema: ptab; Owner: -
--

ALTER SEQUENCE ptab_parties_representations_id_seq OWNED BY ptab_parties_representations.id;


--
-- Name: ptab_party_types_id_seq; Type: SEQUENCE; Schema: ptab; Owner: -
--

CREATE SEQUENCE ptab_party_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ptab_party_types_id_seq; Type: SEQUENCE OWNED BY; Schema: ptab; Owner: -
--

ALTER SEQUENCE ptab_party_types_id_seq OWNED BY ptab_party_types.id;


--
-- Name: technology_centers_id_seq; Type: SEQUENCE; Schema: ptab; Owner: -
--

CREATE SEQUENCE technology_centers_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: technology_centers_id_seq; Type: SEQUENCE OWNED BY; Schema: ptab; Owner: -
--

ALTER SEQUENCE technology_centers_id_seq OWNED BY technology_centers.id;


--
-- Name: v_docblaster_ptab_parties; Type: VIEW; Schema: ptab; Owner: -
--

CREATE VIEW v_docblaster_ptab_parties AS
 SELECT a.core_case_key,
    a.party_name,
    a.party_type,
    a.status
   FROM ( SELECT pet.core_case_key,
            pet.party_name,
            pet.party_type,
            pet.status
           FROM docs_materialized.ptab_petition_party_info pet
          WHERE (((pet.status)::text = 'Supervisor Accepted'::text) AND (pet.party_type = ANY (ARRAY['1'::text, '2'::text, '3'::text, '4'::text])))
        UNION
         SELECT pomn.core_case_key,
            pomn.party_name,
            pomn.party_type,
            pomn.status
           FROM docs_materialized.ptab_patent_owner_mandatory_notice_party_info pomn
          WHERE (((pomn.status)::text = 'Supervisor Accepted'::text) AND (pomn.party_type = ANY (ARRAY['1'::text, '2'::text, '3'::text, '4'::text])))
        UNION
         SELECT ind.core_case_key,
            ind.ptab_party,
            ind.ptab_party_type,
            ind.status
           FROM docs_materialized.ptab_institution_decision_party_info ind
          WHERE (((ind.status)::text = 'Supervisor Accepted'::text) AND (ind.ptab_party_type = ANY (ARRAY['1'::text, '2'::text, '3'::text, '4'::text])))
        UNION
         SELECT fd.core_case_key,
            fd.ptab_party,
            fd.ptab_party_type,
            fd.status
           FROM docs_materialized.ptab_final_decision_party_info fd
          WHERE (((fd.status)::text = 'Supervisor Accepted'::text) AND (fd.ptab_party_type = ANY (ARRAY['1'::text, '2'::text, '3'::text, '4'::text])))
        UNION
         SELECT term.core_case_key,
            term.ptab_party,
            term.ptab_party_type,
            term.status
           FROM docs_materialized.ptab_termination_party_info term
          WHERE (((term.status)::text = 'Supervisor Accepted'::text) AND (term.ptab_party_type = ANY (ARRAY['1'::text, '2'::text, '3'::text, '4'::text])))) a;


--
-- Name: v_ptab_cases; Type: VIEW; Schema: ptab; Owner: -
--

CREATE VIEW v_ptab_cases AS
 SELECT pc.id,
    pc.case_num,
    pc.filing_date,
    pc.institution_decision_date,
    pc.stripped_patnum,
    pc.country_code,
    pc.application_num,
    pc.status,
    pc.tech_center,
    pc.created_at,
    pc.created_by,
    pc.updated_at,
    pc.updated_by,
    pc.ptab_case_type_id,
    pc.is_dcl_corrected,
    pc.final_decision_date,
    pc.final_outcome_date,
    pc.notice_date,
    pc.reason_for_notice_filing_date,
    pc.final_decision_outcome,
    pc.final_outcome,
    pc.petitioner_application_num,
    pc.petitioner_stripped_patnum,
    pc.petitioner_tech_center
   FROM ptab_cases pc
  WHERE (pc.missing_from_source_date IS NULL);


--
-- Name: v_ptab_case_details; Type: VIEW; Schema: ptab; Owner: -
--

CREATE VIEW v_ptab_case_details AS
 SELECT pcd.id,
    pcd.ptab_case_id,
    pcd.ptab_case_detail_party_type_id,
    pcd.doc_name,
    pcd.doc_type,
    pcd.exhibit_num,
    pcd.filing_date,
    pcd.availability,
    pcd.document_path,
    pcd.attachment_handle,
    pcd.attachment_url,
    pcd.created_at,
    pcd.created_by,
    pcd.updated_at,
    pcd.updated_by,
    pcd.is_dcl_corrected,
    pcd.attachment_type,
    pcd.missing_from_source_date,
    pcd.attachment_name,
    pcd.ocr_text,
    pcd.ocr_completed_at
   FROM ptab_case_details pcd
  WHERE ((pcd.missing_from_source_date IS NULL) AND (EXISTS ( SELECT 1
           FROM v_ptab_cases pc
          WHERE (pc.id = pcd.ptab_case_id))));


--
-- Name: v_ptab_case_status; Type: VIEW; Schema: ptab; Owner: -
--

CREATE VIEW v_ptab_case_status AS
 SELECT c.id AS ptab_case_id,
    c.case_num AS ptab_case_number,
    c.created_at AS ptab_case_created_at,
    sc.status AS ptab_case_status_etl,
    c.status AS ptab_case_status,
        CASE
            WHEN ((sc.status)::text = (c.status)::text) THEN false
            ELSE true
        END AS dcl_corrected,
    fc.is_final AS dcl_is_final,
    fc.updated_at AS dcl_last_updated_at,
    fc.updated_by AS dcl_last_updated_by,
    fc.comments AS notes
   FROM ((ptab_cases c
     JOIN ptab_staging.ptab_cases sc ON (((c.case_num)::text = (sc.case_num)::text)))
     LEFT JOIN ( SELECT ptab_field_corrections.id,
            ptab_field_corrections.table_name,
            ptab_field_corrections.pk_field_name,
            ptab_field_corrections.pk_field_value,
            ptab_field_corrections.source_pk_id,
            ptab_field_corrections.field_name,
            ptab_field_corrections.value,
            ptab_field_corrections.last_source_value,
            ptab_field_corrections.updated_by,
            ptab_field_corrections.created_by,
            ptab_field_corrections.is_final,
            ptab_field_corrections.is_newly_initiated,
            ptab_field_corrections.is_correction_active,
            ptab_field_corrections.updated_at,
            ptab_field_corrections.created_at,
            ptab_field_corrections.comments,
            ptab_field_corrections.is_disabled
           FROM data_dcl.ptab_field_corrections
          WHERE (((ptab_field_corrections.table_name)::text = 'ptab.ptab_cases'::text) AND ((ptab_field_corrections.field_name)::text = 'status'::text))) fc ON (((fc.pk_field_value)::text = (c.case_num)::text)));


--
-- Name: v_ptab_document_stats; Type: VIEW; Schema: ptab; Owner: -
--

CREATE VIEW v_ptab_document_stats AS
 SELECT cd.ptab_case_id,
    c.case_num AS ptab_case_num,
    cd.total_documents,
    cd.documents_successfully_downloaded,
    cd.documents_failed_to_downloaded,
    ((((cd.documents_successfully_downloaded)::numeric(5,2) / (cd.total_documents)::numeric(5,2)) * (100)::numeric))::numeric(5,2) AS success_percentage
   FROM (( SELECT ptab_case_details.ptab_case_id,
            count(1) AS total_documents,
            sum(
                CASE ((ptab_case_details.document_path IS NULL) OR ((ptab_case_details.document_path)::text = ''::text) OR (length((ptab_case_details.document_path)::text) < 4))
                    WHEN true THEN 0
                    ELSE 1
                END) AS documents_successfully_downloaded,
            sum(
                CASE ((ptab_case_details.document_path IS NULL) OR ((ptab_case_details.document_path)::text = ''::text) OR (length((ptab_case_details.document_path)::text) < 4))
                    WHEN true THEN 1
                    ELSE 0
                END) AS documents_failed_to_downloaded
           FROM ptab_case_details
          WHERE ((lower((ptab_case_details.availability)::text) = 'public'::text) AND (ptab_case_details.missing_from_source_date IS NULL) AND ((ptab_case_details.attachment_type IS NULL) OR ((ptab_case_details.attachment_type)::text = ANY (ARRAY[('application/pdf'::character varying)::text, ('application/msword'::character varying)::text]))))
          GROUP BY ptab_case_details.ptab_case_id) cd
     JOIN ptab_cases c ON ((cd.ptab_case_id = c.id)));


--
-- Name: v_ptab_judges_map; Type: VIEW; Schema: ptab; Owner: -
--

CREATE VIEW v_ptab_judges_map AS
 SELECT c.id AS ptab_case_id,
    min(pj.alias_id) AS judge_alias_id,
    min(pj.start_date) AS start_date
   FROM ((ldc.lit_docs_ptab_judges_map pj
     JOIN ptab_cases c ON ((pj.ptab_case_id = c.id)))
     LEFT JOIN core.aliases al ON ((pj.alias_id = al.id)))
  WHERE ((al.ent_id IS NOT NULL) AND (pj.alias_id <> 2242165))
  GROUP BY c.id, al.ent_id
UNION ALL
 SELECT c.id AS ptab_case_id,
    pj.alias_id AS judge_alias_id,
    min(pj.start_date) AS start_date
   FROM ((ldc.lit_docs_ptab_judges_map pj
     JOIN ptab_cases c ON ((pj.ptab_case_id = c.id)))
     LEFT JOIN core.aliases al ON ((pj.alias_id = al.id)))
  WHERE ((al.ent_id IS NULL) AND (pj.alias_id <> 2242165))
  GROUP BY c.id, pj.alias_id;


--
-- Name: v_ptab_missing_documents; Type: VIEW; Schema: ptab; Owner: -
--

CREATE VIEW v_ptab_missing_documents AS
 SELECT a.ptab_case_id,
    a.ptab_case_num,
    a.doc_name,
    a.doc_id,
    a.doc_filing_date,
    a.missing_from_source_date,
    a.number_of_attempts_to_download,
    a.last_download_attempt
   FROM ( SELECT DISTINCT c.id AS ptab_case_id,
            c.case_num AS ptab_case_num,
            cd.doc_name,
            cd.id AS doc_id,
            cd.filing_date AS doc_filing_date,
            cd.missing_from_source_date,
            ( SELECT count(1) AS count
                   FROM job_control.job_control_log
                  WHERE (((job_control_log.job_name)::text = 'PTAB_DOCUMENTS'::text) AND ((job_control_log.status_name)::text = 'Complete'::text) AND (cd.updated_at < job_control_log.created_ts))) AS number_of_attempts_to_download,
            ( SELECT max(job_control_log.created_ts) AS max
                   FROM job_control.job_control_log
                  WHERE (((job_control_log.job_name)::text = 'PTAB_DOCUMENTS'::text) AND ((job_control_log.status_name)::text = 'Complete'::text))) AS last_download_attempt
           FROM ptab_case_details cd,
            ptab_cases c
          WHERE ((lower((cd.availability)::text) = 'public'::text) AND (cd.ptab_case_id = c.id) AND (cd.missing_from_source_date IS NULL) AND ((cd.document_path IS NULL) OR ((cd.document_path)::text = ''::text) OR (length((cd.document_path)::text) < 4)) AND ((cd.attachment_type IS NULL) OR ((cd.attachment_type)::text = ANY (ARRAY[('application/pdf'::character varying)::text, ('application/msword'::character varying)::text]))))) a
  WHERE (a.number_of_attempts_to_download > 0);


--
-- Name: v_ptab_parties; Type: VIEW; Schema: ptab; Owner: -
--

CREATE VIEW v_ptab_parties AS
 SELECT pp.ptab_case_id,
    pp.ptab_party_type_id,
    pp.alias_id,
    pp.created_at,
    pp.created_by,
    pp.updated_at,
    pp.updated_by,
    pp.id,
    pp.is_primary,
    pp.missing_from_source_date
   FROM ptab_parties pp
  WHERE ((pp.missing_from_source_date IS NULL) AND (EXISTS ( SELECT 1
           FROM v_ptab_cases pc
          WHERE (pc.id = pp.ptab_case_id))));


SET search_path = public, pg_catalog;

--
-- Name: ar_internal_metadata; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE ar_internal_metadata (
    key character varying NOT NULL,
    value character varying,
    created_at timestamp without time zone NOT NULL,
    updated_at timestamp without time zone NOT NULL
);


--
-- Name: documents; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE documents (
    id bigint NOT NULL,
    ocr_text text,
    file character varying,
    created_at timestamp without time zone NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    status integer DEFAULT 1,
    exception character varying
);


--
-- Name: documents_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE documents_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: documents_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE documents_id_seq OWNED BY documents.id;


--
-- Name: dual; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW dual AS
 SELECT 'X'::character varying AS dummy;


--
-- Name: passwd; Type: FOREIGN TABLE; Schema: public; Owner: -
--

CREATE FOREIGN TABLE passwd (
    username text,
    pass text,
    uid integer,
    gid integer,
    gecos text,
    home text,
    shell text
)
SERVER file_server
OPTIONS (
    delimiter ':',
    filename '/etc/passwd',
    format 'text',
    "null" ''
);


--
-- Name: patents; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE patents (
    id bigint NOT NULL,
    patnum character varying,
    asset_source integer,
    asset_source_id integer,
    patent_number integer,
    country_code character varying,
    matched_with_country_code boolean DEFAULT true,
    document_id integer,
    created_at timestamp without time zone NOT NULL,
    updated_at timestamp without time zone NOT NULL
);


--
-- Name: patents_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE patents_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: patents_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE patents_id_seq OWNED BY patents.id;


--
-- Name: pg_stat_activity; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW pg_stat_activity AS
 SELECT pg_stat_activity.pid AS procpid,
    pg_stat_activity.usesysid,
    pg_stat_activity.usename,
    pg_stat_activity.application_name,
    pg_stat_activity.client_addr,
    pg_stat_activity.client_hostname,
    pg_stat_activity.client_port,
    pg_stat_activity.backend_start,
    pg_stat_activity.xact_start,
    pg_stat_activity.query_start,
    pg_stat_activity.state_change,
    pg_stat_activity.waiting,
    pg_stat_activity.state,
    pg_stat_activity.query
   FROM pg_catalog.pg_stat_activity;


--
-- Name: ps_activity_log; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW ps_activity_log AS
 SELECT postgres_log.log_time,
    postgres_log.user_name,
    postgres_log.process_id,
    postgres_log.connection_from,
    postgres_log.command_tag,
    postgres_log.session_start_time,
    postgres_log.error_severity,
        CASE
            WHEN (postgres_log.message ~* '^duration: '::text) THEN regexp_replace(postgres_log.message, '^duration: [0-9]*.[0-9]* ms  '::text, ''::text)
            ELSE postgres_log.message
        END AS query_text,
        CASE
            WHEN (postgres_log.message ~* '^duration: '::text) THEN (regexp_replace(regexp_replace(postgres_log.message, '^duration\:\ '::text, ''::text), '.[0-9]+ ms(.)*'::text, ''::text))::integer
            ELSE NULL::integer
        END AS "duration(ms)",
    postgres_log.detail,
    postgres_log.query
   FROM rpx_dba.postgres_log
  ORDER BY postgres_log.log_time DESC;


--
-- Name: ps_etl_app_conn_snapshot; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW ps_etl_app_conn_snapshot AS
 SELECT user_connections.user_name,
    user_connections.ip_address,
    user_connections.connected_time,
    user_connections.query_time,
    user_connections.query_ddl,
    user_connections.recorded_at
   FROM rpx_dba.user_connections
  WHERE (((user_connections.user_name)::text = 'ps_etl_app'::text) AND (user_connections.recorded_at = '2013-05-07 14:15:06.199924'::timestamp without time zone));


--
-- Name: schema_migrations; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE schema_migrations (
    version character varying(255) NOT NULL
);


--
-- Name: v_rpx_app_roles; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW v_rpx_app_roles AS
 SELECT DISTINCT pg_roles.rolname AS groupname,
    pg_user.usename AS username
   FROM ((pg_user
     JOIN pg_auth_members ON ((pg_user.usesysid = pg_auth_members.member)))
     JOIN pg_roles ON ((pg_roles.oid = pg_auth_members.roleid)))
  WHERE ((pg_roles.rolname)::text = ANY (ARRAY['ro_group'::text, 'rpx'::text, 'rpx_api'::text, 'rpx_service'::text, 'dblink_role'::text, 'localcore'::text, 'coreapp'::text, 'application_role'::text]));


--
-- Name: v_rpx_consultants; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW v_rpx_consultants AS
 SELECT ldap_imaginea.full_name,
    ldap_imaginea.department,
    ldap_imaginea.username,
    ldap_imaginea.email,
    ldap_imaginea.telephone,
    ldap_imaginea.mobile
   FROM ldap_etl_app.ldap_imaginea
  WHERE (((ldap_imaginea.full_name)::text !~* 'test'::text) AND ((ldap_imaginea.full_name)::text !~* 'investor re'::text) AND (((ldap_imaginea.full_name)::text ~ '^[A-Z][a-z](.)* [A-Z][a-z](.)*$'::text) OR ((ldap_imaginea.full_name)::text ~ '^[A-Z].(.)* [A-Z][a-z](.)*$'::text)));


--
-- Name: v_rpx_employees; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW v_rpx_employees AS
 SELECT ldap_people.full_name,
    ldap_people.department,
    ldap_people.username,
    ldap_people.email,
    ldap_people.telephone,
    ldap_people.mobile
   FROM ldap_etl_app.ldap_people
  WHERE (((ldap_people.full_name)::text !~* 'test'::text) AND ((ldap_people.full_name)::text !~* 'investor re'::text) AND (((ldap_people.full_name)::text ~ '^[A-Z][a-z](.)* [A-Z][a-z](.)*$'::text) OR ((ldap_people.full_name)::text ~ '^[A-Z].(.)* [A-Z][a-z](.)*$'::text)));


--
-- Name: v_rpx_sysdev; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW v_rpx_sysdev AS
 SELECT ldap_sysdev.full_name,
    ldap_sysdev.department,
    ldap_sysdev.username,
    ldap_sysdev.email,
    ldap_sysdev.telephone,
    ldap_sysdev.mobile
   FROM ldap_etl_app.ldap_sysdev
  WHERE (((ldap_sysdev.full_name)::text !~* 'test'::text) AND ((ldap_sysdev.full_name)::text !~* 'investor re'::text) AND (((ldap_sysdev.full_name)::text ~ '^[A-Z][a-z](.)* [A-Z][a-z](.)*$'::text) OR ((ldap_sysdev.full_name)::text ~ '^[A-Z].(.)* [A-Z][a-z](.)*$'::text)));


SET search_path = acquiflow, pg_catalog;

--
-- Name: acquisition_agreements id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_agreements ALTER COLUMN id SET DEFAULT nextval('acquisition_agreements_id_seq'::regclass);


--
-- Name: acquisition_agreements_agreement_types id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_agreements_agreement_types ALTER COLUMN id SET DEFAULT nextval('acquisition_agreements_agreement_types_id_seq'::regclass);


--
-- Name: acquisition_encumbrance_patents id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_encumbrance_patents ALTER COLUMN id SET DEFAULT nextval('acquisition_encumbrance_patents_id_seq'::regclass);


--
-- Name: acquisition_encumbrances id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_encumbrances ALTER COLUMN id SET DEFAULT nextval('acquisition_encumbrances_id_seq'::regclass);


--
-- Name: acquisition_opportunities_portfolios id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_opportunities_portfolios ALTER COLUMN id SET DEFAULT nextval('acquisition_opportunities_portfolios_id_seq'::regclass);


--
-- Name: acquisition_option_patents id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_option_patents ALTER COLUMN id SET DEFAULT nextval('acquisition_option_patents_id_seq'::regclass);


--
-- Name: acquisition_options id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_options ALTER COLUMN id SET DEFAULT nextval('acquisition_options_id_seq'::regclass);


--
-- Name: acquisition_patent_attributes id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patent_attributes ALTER COLUMN id SET DEFAULT nextval('acquisition_patent_attributes_id_seq'::regclass);


--
-- Name: acquisition_patent_attributes_dcl id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patent_attributes_dcl ALTER COLUMN id SET DEFAULT nextval('acquisition_patent_attributes_dcl_id_seq'::regclass);


--
-- Name: acquisition_patents id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patents ALTER COLUMN id SET DEFAULT nextval('acquisition_patents_id_seq'::regclass);


--
-- Name: acquisition_patents_current_assignee_aliases id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patents_current_assignee_aliases ALTER COLUMN id SET DEFAULT nextval('acquisition_patents_current_assignee_aliases_id_seq'::regclass);


--
-- Name: acquisition_patents_dcl id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patents_dcl ALTER COLUMN id SET DEFAULT nextval('acquisition_patents_dcl_id_seq'::regclass);


--
-- Name: acquisition_patents_dcl_current_assignee_aliases id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patents_dcl_current_assignee_aliases ALTER COLUMN id SET DEFAULT nextval('acquisition_patents_dcl_current_assignee_aliases_id_seq'::regclass);


--
-- Name: acquisition_patents_dcl_rpx_ownership_rights id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patents_dcl_rpx_ownership_rights ALTER COLUMN id SET DEFAULT nextval('acquisition_patents_dcl_rpx_ownership_rights_id_seq'::regclass);


--
-- Name: acquisition_restriction_patents id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_restriction_patents ALTER COLUMN id SET DEFAULT nextval('acquisition_restriction_patents_id_seq'::regclass);


--
-- Name: acquisition_restrictions id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_restrictions ALTER COLUMN id SET DEFAULT nextval('acquisition_restrictions_id_seq'::regclass);


--
-- Name: acquisition_syndications id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_syndications ALTER COLUMN id SET DEFAULT nextval('acquisition_syndications_id_seq'::regclass);


--
-- Name: acquisition_types id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_types ALTER COLUMN id SET DEFAULT nextval('acquisition_types_id_seq'::regclass);


--
-- Name: acquisitions id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisitions ALTER COLUMN id SET DEFAULT nextval('acquisitions_id_seq'::regclass);


--
-- Name: agreement_terms id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY agreement_terms ALTER COLUMN id SET DEFAULT nextval('agreement_terms_id_seq'::regclass);


--
-- Name: agreement_types id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY agreement_types ALTER COLUMN id SET DEFAULT nextval('agreement_types_id_seq'::regclass);


--
-- Name: asset_inventory_cpi id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY asset_inventory_cpi ALTER COLUMN id SET DEFAULT nextval('asset_inventory_cpi_id_seq'::regclass);


--
-- Name: asset_sources id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY asset_sources ALTER COLUMN id SET DEFAULT nextval('asset_sources_id_seq'::regclass);


--
-- Name: asset_status_types id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY asset_status_types ALTER COLUMN id SET DEFAULT nextval('asset_status_types_id_seq'::regclass);


--
-- Name: batch_generated_option_ents id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY batch_generated_option_ents ALTER COLUMN id SET DEFAULT nextval('batch_generated_option_ents_id_seq'::regclass);


--
-- Name: batch_generated_option_statuses id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY batch_generated_option_statuses ALTER COLUMN id SET DEFAULT nextval('batch_generated_option_statuses_id_seq'::regclass);


--
-- Name: batch_generated_option_types id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY batch_generated_option_types ALTER COLUMN id SET DEFAULT nextval('batch_generated_option_types_id_seq'::regclass);


--
-- Name: case_types id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY case_types ALTER COLUMN id SET DEFAULT nextval('case_types_id_seq'::regclass);


--
-- Name: counter_party_types id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY counter_party_types ALTER COLUMN id SET DEFAULT nextval('counter_party_types_id_seq'::regclass);


--
-- Name: cpi_file_snapshot id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY cpi_file_snapshot ALTER COLUMN id SET DEFAULT nextval('cpi_file_snapshot_id_seq'::regclass);


--
-- Name: cpi_tracking_status id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY cpi_tracking_status ALTER COLUMN id SET DEFAULT nextval('cpi_tracking_status_id_seq'::regclass);


--
-- Name: divestiture_patents id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY divestiture_patents ALTER COLUMN id SET DEFAULT nextval('divestiture_patents_id_seq'::regclass);


--
-- Name: divestitures id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY divestitures ALTER COLUMN id SET DEFAULT nextval('divestitures_id_seq'::regclass);


--
-- Name: encumbrance_types id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY encumbrance_types ALTER COLUMN id SET DEFAULT nextval('encumbrance_types_id_seq'::regclass);


--
-- Name: exercised_batch_options id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY exercised_batch_options ALTER COLUMN id SET DEFAULT nextval('exercised_batch_options_id_seq'::regclass);


--
-- Name: manual_assets id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY manual_assets ALTER COLUMN id SET DEFAULT nextval('manual_assets_id_seq'::regclass);


--
-- Name: market_sector_portfolios_map id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY market_sector_portfolios_map ALTER COLUMN id SET DEFAULT nextval('market_sector_portfolios_map_id_seq'::regclass);


--
-- Name: option_types id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY option_types ALTER COLUMN id SET DEFAULT nextval('option_types_id_seq'::regclass);


--
-- Name: options_report_download_requests id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY options_report_download_requests ALTER COLUMN id SET DEFAULT nextval('options_report_download_requests_id_seq'::regclass);


--
-- Name: portfolios id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY portfolios ALTER COLUMN id SET DEFAULT nextval('portfolios_id_seq'::regclass);


--
-- Name: restriction_types id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY restriction_types ALTER COLUMN id SET DEFAULT nextval('restriction_types_id_seq'::regclass);


--
-- Name: rpx_cpi_asset_tracking_log id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY rpx_cpi_asset_tracking_log ALTER COLUMN id SET DEFAULT nextval('rpx_cpi_asset_tracking_log_id_seq'::regclass);


--
-- Name: rpx_ownership_rights id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY rpx_ownership_rights ALTER COLUMN id SET DEFAULT nextval('rpx_ownership_rights_id_seq'::regclass);


--
-- Name: selected_batch_generated_option_types id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY selected_batch_generated_option_types ALTER COLUMN id SET DEFAULT nextval('selected_batch_generated_option_types_id_seq'::regclass);


--
-- Name: stage_cpi_weekly_master id; Type: DEFAULT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY stage_cpi_weekly_master ALTER COLUMN id SET DEFAULT nextval('stage_cpi_weekly_master_id_seq'::regclass);


SET search_path = core, pg_catalog;

--
-- Name: alias_contacts id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY alias_contacts ALTER COLUMN id SET DEFAULT nextval('alias_contacts_id_seq'::regclass);


--
-- Name: alias_ent_details id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY alias_ent_details ALTER COLUMN id SET DEFAULT nextval('alias_ent_details_id_seq'::regclass);


--
-- Name: alias_roles id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY alias_roles ALTER COLUMN id SET DEFAULT nextval('alias_roles_id_seq'::regclass);


--
-- Name: aliases id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY aliases ALTER COLUMN id SET DEFAULT nextval('aliases_id_seq'::regclass);


--
-- Name: assignees_aliases_map id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY assignees_aliases_map ALTER COLUMN id SET DEFAULT nextval('assignees_aliases_map_id_seq'::regclass);


--
-- Name: assignors_aliases_map id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY assignors_aliases_map ALTER COLUMN id SET DEFAULT nextval('assignors_aliases_map_id_seq'::regclass);


--
-- Name: court_abbreviations id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY court_abbreviations ALTER COLUMN id SET DEFAULT nextval('court_abbreviations_id_seq'::regclass);


--
-- Name: cpc_descriptions id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY cpc_descriptions ALTER COLUMN id SET DEFAULT nextval('cpc_descriptions_id_seq'::regclass);


--
-- Name: dma_lit_annotations id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY dma_lit_annotations ALTER COLUMN id SET DEFAULT nextval('dma_lit_annotations_id_seq'::regclass);


--
-- Name: dma_lits_pats_map id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY dma_lits_pats_map ALTER COLUMN id SET DEFAULT nextval('dma_lits_pats_map_id_seq'::regclass);


--
-- Name: ent_relationship_types id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY ent_relationship_types ALTER COLUMN id SET DEFAULT nextval('ent_relationship_types_id_seq'::regclass);


--
-- Name: ent_relationships id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY ent_relationships ALTER COLUMN id SET DEFAULT nextval('ent_relationships_id_seq'::regclass);


--
-- Name: ent_relationships_temporal id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY ent_relationships_temporal ALTER COLUMN id SET DEFAULT nextval('ent_relationships_temporal_id_seq'::regclass);


--
-- Name: ent_types id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY ent_types ALTER COLUMN id SET DEFAULT nextval('ent_types_id_seq'::regclass);


--
-- Name: entity_contacts id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY entity_contacts ALTER COLUMN id SET DEFAULT nextval('entity_contacts_id_seq'::regclass);


--
-- Name: ents id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY ents ALTER COLUMN id SET DEFAULT nextval('ents_id_seq'::regclass);


--
-- Name: file_types id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY file_types ALTER COLUMN id SET DEFAULT nextval('file_types_id_seq'::regclass);


--
-- Name: invention_owners id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY invention_owners ALTER COLUMN id SET DEFAULT nextval('invention_owners_id_seq'::regclass);


--
-- Name: ipc_classes id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_classes ALTER COLUMN id SET DEFAULT nextval('ipc_classes_id_seq'::regclass);


--
-- Name: ipc_classes_hist id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_classes_hist ALTER COLUMN id SET DEFAULT nextval('ipc_classes_hist_id_seq'::regclass);


--
-- Name: ipc_groups id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_groups ALTER COLUMN id SET DEFAULT nextval('ipc_groups_id_seq'::regclass);


--
-- Name: ipc_groups_hist id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_groups_hist ALTER COLUMN id SET DEFAULT nextval('ipc_groups_hist_id_seq'::regclass);


--
-- Name: ipc_sections id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_sections ALTER COLUMN id SET DEFAULT nextval('ipc_sections_id_seq'::regclass);


--
-- Name: ipc_sections_hist id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_sections_hist ALTER COLUMN id SET DEFAULT nextval('ipc_sections_hist_id_seq'::regclass);


--
-- Name: ipc_subclasses id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_subclasses ALTER COLUMN id SET DEFAULT nextval('ipc_subclasses_id_seq'::regclass);


--
-- Name: ipc_subclasses_hist id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_subclasses_hist ALTER COLUMN id SET DEFAULT nextval('ipc_subclasses_hist_id_seq'::regclass);


--
-- Name: ipc_subgroups id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_subgroups ALTER COLUMN id SET DEFAULT nextval('ipc_subgroups_id_seq'::regclass);


--
-- Name: ipc_subgroups_hist id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_subgroups_hist ALTER COLUMN id SET DEFAULT nextval('ipc_subgroups_hist_id_seq'::regclass);


--
-- Name: ipc_transfer id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_transfer ALTER COLUMN id SET DEFAULT nextval('ipc_transfer_id_seq'::regclass);


--
-- Name: judge_assignment_types id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY judge_assignment_types ALTER COLUMN id SET DEFAULT nextval('judge_assignment_types_id_seq'::regclass);


--
-- Name: lit_annotations lit_id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_annotations ALTER COLUMN lit_id SET DEFAULT nextval('lit_annotations_lits_id_seq'::regclass);


--
-- Name: lit_case_aliases id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_case_aliases ALTER COLUMN id SET DEFAULT nextval('lit_case_aliases_id_seq'::regclass);


--
-- Name: lit_case_stages id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_case_stages ALTER COLUMN id SET DEFAULT nextval('lit_case_stages_id_seq'::regclass);


--
-- Name: lit_cause_types id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_cause_types ALTER COLUMN id SET DEFAULT nextval('lit_cause_types_id_seq'::regclass);


--
-- Name: lit_classification_types id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_classification_types ALTER COLUMN id SET DEFAULT nextval('lit_classification_types_id_seq'::regclass);


--
-- Name: lit_curated_cause_types id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_curated_cause_types ALTER COLUMN id SET DEFAULT nextval('lit_curated_cause_types_id_seq'::regclass);


--
-- Name: lit_document_orphans id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_document_orphans ALTER COLUMN id SET DEFAULT nextval('lit_document_orphans_id_seq'::regclass);


--
-- Name: lit_document_statuses id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_document_statuses ALTER COLUMN id SET DEFAULT nextval('lit_document_statuses_id_seq'::regclass);


--
-- Name: lit_document_types id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_document_types ALTER COLUMN id SET DEFAULT nextval('lit_document_types_id_seq'::regclass);


--
-- Name: lit_families id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_families ALTER COLUMN id SET DEFAULT nextval('lit_families_id_seq'::regclass);


--
-- Name: lit_parties id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_parties ALTER COLUMN id SET DEFAULT nextval('lit_parties_id_seq'::regclass);


--
-- Name: lit_party_normalized_types id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_party_normalized_types ALTER COLUMN id SET DEFAULT nextval('lit_party_normalized_types_id_seq'::regclass);


--
-- Name: lit_party_outcome_subtypes id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_party_outcome_subtypes ALTER COLUMN id SET DEFAULT nextval('lit_party_outcome_subtypes_id_seq'::regclass);


--
-- Name: lit_party_outcome_type_subtype_map id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_party_outcome_type_subtype_map ALTER COLUMN id SET DEFAULT nextval('lit_party_outcome_type_subtype_map_id_seq'::regclass);


--
-- Name: lit_party_outcome_types id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_party_outcome_types ALTER COLUMN id SET DEFAULT nextval('lit_party_outcome_types_id_seq'::regclass);


--
-- Name: lit_party_outcomes id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_party_outcomes ALTER COLUMN id SET DEFAULT nextval('lit_party_outcomes_id_seq'::regclass);


--
-- Name: lit_party_types id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_party_types ALTER COLUMN id SET DEFAULT nextval('lit_party_types_id_seq'::regclass);


--
-- Name: lit_relationship_types id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_relationship_types ALTER COLUMN id SET DEFAULT nextval('lit_relationship_types_id_seq'::regclass);


--
-- Name: lit_stages id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_stages ALTER COLUMN id SET DEFAULT nextval('lit_stages_id_seq'::regclass);


--
-- Name: lit_types id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_types ALTER COLUMN id SET DEFAULT nextval('lit_types_id_seq'::regclass);


--
-- Name: lits id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY lits ALTER COLUMN id SET DEFAULT nextval('lits_id_seq'::regclass);


--
-- Name: lits_pats_other id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY lits_pats_other ALTER COLUMN id SET DEFAULT nextval('lits_pats_other_id_seq'::regclass);


--
-- Name: market_sector_types id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY market_sector_types ALTER COLUMN id SET DEFAULT nextval('market_sector_types_id_seq'::regclass);


--
-- Name: pat_abstracts id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_abstracts ALTER COLUMN id SET DEFAULT nextval('pat_abstracts_id_seq'::regclass);


--
-- Name: pat_assignments id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_assignments ALTER COLUMN id SET DEFAULT nextval('pat_assignments_id_seq'::regclass);


--
-- Name: pat_assignments_assoc_r_f id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_assignments_assoc_r_f ALTER COLUMN id SET DEFAULT nextval('pat_assignments_assoc_r_f_id_seq'::regclass);


--
-- Name: pat_claim_relationships id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_claim_relationships ALTER COLUMN id SET DEFAULT nextval('pat_claim_relationships_id_seq'::regclass);


--
-- Name: pat_claims_s3 id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_claims_s3 ALTER COLUMN id SET DEFAULT nextval('pat_claims_s3_id_seq'::regclass);


--
-- Name: pat_current id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_current ALTER COLUMN id SET DEFAULT nextval('pat_current_id_seq'::regclass);


--
-- Name: pat_descriptions id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_descriptions ALTER COLUMN id SET DEFAULT nextval('pat_descriptions_id_seq'::regclass);


--
-- Name: pat_document_types id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_document_types ALTER COLUMN id SET DEFAULT nextval('pat_document_types_id_seq'::regclass);


--
-- Name: pat_documents id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_documents ALTER COLUMN id SET DEFAULT nextval('pat_documents_id_seq'::regclass);


--
-- Name: pat_drawings id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_drawings ALTER COLUMN id SET DEFAULT nextval('pat_drawings_id_seq'::regclass);


--
-- Name: pat_ent_relationships id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_ent_relationships ALTER COLUMN id SET DEFAULT nextval('pat_ent_relationships_temp_id_seq'::regclass);


--
-- Name: pat_ent_relationships_tmp id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_ent_relationships_tmp ALTER COLUMN id SET DEFAULT nextval('pat_ent_relationships_id_seq'::regclass);


--
-- Name: pat_family_pats_details id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_family_pats_details ALTER COLUMN id SET DEFAULT nextval('pat_family_pats_details_id_seq'::regclass);


--
-- Name: pat_ipc_classes id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_ipc_classes ALTER COLUMN id SET DEFAULT nextval('pat_ipc_classes_id_seq'::regclass);


--
-- Name: pat_maintenance_fee_entity_types id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_maintenance_fee_entity_types ALTER COLUMN id SET DEFAULT nextval('pat_maintenance_fee_entity_types_id_seq'::regclass);


--
-- Name: pat_maintenance_fee_event_types id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_maintenance_fee_event_types ALTER COLUMN id SET DEFAULT nextval('pat_maintenance_fee_event_types_id_seq'::regclass);


--
-- Name: pat_maintenance_fee_events id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_maintenance_fee_events ALTER COLUMN id SET DEFAULT nextval('pat_maintenance_fee_events_id_seq'::regclass);


--
-- Name: pat_orig_app_num_country id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_orig_app_num_country ALTER COLUMN id SET DEFAULT nextval('pat_orig_app_num_country_id_seq'::regclass);


--
-- Name: pat_other_references id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_other_references ALTER COLUMN id SET DEFAULT nextval('pat_other_references_id_seq'::regclass);


--
-- Name: pat_primary_conveyance_types id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_primary_conveyance_types ALTER COLUMN id SET DEFAULT nextval('pat_primary_conveyance_types_id_seq'::regclass);


--
-- Name: pat_priority_claims id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_priority_claims ALTER COLUMN id SET DEFAULT nextval('pat_priority_claims_id_seq'::regclass);


--
-- Name: pat_references id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_references ALTER COLUMN id SET DEFAULT nextval('pat_references_id_seq'::regclass);


--
-- Name: pat_related_documents id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_related_documents ALTER COLUMN id SET DEFAULT nextval('pat_related_documents_id_seq'::regclass);


--
-- Name: pat_secondary_conveyance id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_secondary_conveyance ALTER COLUMN id SET DEFAULT nextval('pat_secondary_conveyance_id_seq'::regclass);


--
-- Name: pat_secondary_conveyance_types id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_secondary_conveyance_types ALTER COLUMN id SET DEFAULT nextval('pat_secondary_conveyance_types_id_seq'::regclass);


--
-- Name: pat_stats id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_stats ALTER COLUMN id SET DEFAULT nextval('pat_stats_id_seq'::regclass);


--
-- Name: pat_stats_all_assignees id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_stats_all_assignees ALTER COLUMN id SET DEFAULT nextval('pat_stats_all_assignees_id_seq'::regclass);


--
-- Name: pat_stats_continuances id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_stats_continuances ALTER COLUMN id SET DEFAULT nextval('pat_stats_continuances_id_seq'::regclass);


--
-- Name: pat_stats_current_assignees id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_stats_current_assignees ALTER COLUMN id SET DEFAULT nextval('pat_stats_current_assignees_id_seq'::regclass);


--
-- Name: pat_stats_current_assignors id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_stats_current_assignors ALTER COLUMN id SET DEFAULT nextval('pat_stats_current_assignors_id_seq'::regclass);


--
-- Name: pat_stats_inventors id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_stats_inventors ALTER COLUMN id SET DEFAULT nextval('pat_stats_inventors_id_seq'::regclass);


--
-- Name: pat_stats_sponsoring_parties id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_stats_sponsoring_parties ALTER COLUMN id SET DEFAULT nextval('pat_stats_sponsoring_parties_id_seq'::regclass);


--
-- Name: patent_owners id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY patent_owners ALTER COLUMN id SET DEFAULT nextval('patent_owners_id_seq'::regclass);


--
-- Name: pats_aliases_relationship_types id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pats_aliases_relationship_types ALTER COLUMN id SET DEFAULT nextval('pats_aliases_relationship_types_id_seq'::regclass);


--
-- Name: pats_assignments_map id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pats_assignments_map ALTER COLUMN id SET DEFAULT nextval('pats_assignments_map_id_seq'::regclass);


--
-- Name: pats_field_of_search id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pats_field_of_search ALTER COLUMN id SET DEFAULT nextval('pats_field_of_search_id_seq'::regclass);


--
-- Name: pats_invention id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pats_invention ALTER COLUMN id SET DEFAULT nextval('pats_invention_id_seq'::regclass);


--
-- Name: pats_invention_link id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pats_invention_link ALTER COLUMN id SET DEFAULT nextval('pats_invention_link_id_seq'::regclass);


--
-- Name: pats_withdrawn id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY pats_withdrawn ALTER COLUMN id SET DEFAULT nextval('pats_withdrawn_id_seq'::regclass);


--
-- Name: rails_admin_histories id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY rails_admin_histories ALTER COLUMN id SET DEFAULT nextval('rails_admin_histories_id_seq'::regclass);


--
-- Name: ravel_judges id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY ravel_judges ALTER COLUMN id SET DEFAULT nextval('ravel_judges_id_seq'::regclass);


--
-- Name: tx_sequential_control id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY tx_sequential_control ALTER COLUMN id SET DEFAULT nextval('tx_sequential_control_id_seq'::regclass);


--
-- Name: unicodes id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY unicodes ALTER COLUMN id SET DEFAULT nextval('unicodes_id_seq'::regclass);


--
-- Name: users id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY users ALTER COLUMN id SET DEFAULT nextval('users_id_seq'::regclass);


--
-- Name: uspcs_classes id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY uspcs_classes ALTER COLUMN id SET DEFAULT nextval('uspcs_classes_id_seq'::regclass);


--
-- Name: uspcs_subclasses id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY uspcs_subclasses ALTER COLUMN id SET DEFAULT nextval('uspcs_subclasses_id_seq'::regclass);


--
-- Name: uspcs_to_ipc_mapping id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY uspcs_to_ipc_mapping ALTER COLUMN id SET DEFAULT nextval('uspcs_to_ipc_mapping_id_seq'::regclass);


--
-- Name: uspto_practitioner_roster id; Type: DEFAULT; Schema: core; Owner: -
--

ALTER TABLE ONLY uspto_practitioner_roster ALTER COLUMN id SET DEFAULT nextval('uspto_practioner_roster_id_seq'::regclass);


SET search_path = docdb, pg_catalog;

--
-- Name: docdb_batch id; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY docdb_batch ALTER COLUMN id SET DEFAULT nextval('docdb_batch_id_seq'::regclass);


--
-- Name: docdb_logs id; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY docdb_logs ALTER COLUMN id SET DEFAULT nextval('docdb_logs_id_seq'::regclass);


--
-- Name: log_data id; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data ALTER COLUMN id SET DEFAULT nextval('log_data_id_seq'::regclass);


--
-- Name: log_data_201609 id; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201609 ALTER COLUMN id SET DEFAULT nextval('log_data_id_seq'::regclass);


--
-- Name: log_data_201609 created_at; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201609 ALTER COLUMN created_at SET DEFAULT now();


--
-- Name: log_data_201609 db_user; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201609 ALTER COLUMN db_user SET DEFAULT "current_user"();


--
-- Name: log_data_201609 client_host; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201609 ALTER COLUMN client_host SET DEFAULT COALESCE(((inet_client_addr() || ':'::text) || inet_client_port()), 'LOCAL'::text);


--
-- Name: log_data_201609 search_path; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201609 ALTER COLUMN search_path SET DEFAULT btrim((current_schemas(true))::text, '{}'::text);


--
-- Name: log_data_201610 id; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201610 ALTER COLUMN id SET DEFAULT nextval('log_data_id_seq'::regclass);


--
-- Name: log_data_201610 created_at; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201610 ALTER COLUMN created_at SET DEFAULT now();


--
-- Name: log_data_201610 db_user; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201610 ALTER COLUMN db_user SET DEFAULT "current_user"();


--
-- Name: log_data_201610 client_host; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201610 ALTER COLUMN client_host SET DEFAULT COALESCE(((inet_client_addr() || ':'::text) || inet_client_port()), 'LOCAL'::text);


--
-- Name: log_data_201610 search_path; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201610 ALTER COLUMN search_path SET DEFAULT btrim((current_schemas(true))::text, '{}'::text);


--
-- Name: log_data_201611 id; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201611 ALTER COLUMN id SET DEFAULT nextval('log_data_id_seq'::regclass);


--
-- Name: log_data_201611 created_at; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201611 ALTER COLUMN created_at SET DEFAULT now();


--
-- Name: log_data_201611 db_user; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201611 ALTER COLUMN db_user SET DEFAULT "current_user"();


--
-- Name: log_data_201611 client_host; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201611 ALTER COLUMN client_host SET DEFAULT COALESCE(((inet_client_addr() || ':'::text) || inet_client_port()), 'LOCAL'::text);


--
-- Name: log_data_201611 search_path; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201611 ALTER COLUMN search_path SET DEFAULT btrim((current_schemas(true))::text, '{}'::text);


--
-- Name: log_data_201612 id; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201612 ALTER COLUMN id SET DEFAULT nextval('log_data_id_seq'::regclass);


--
-- Name: log_data_201612 created_at; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201612 ALTER COLUMN created_at SET DEFAULT now();


--
-- Name: log_data_201612 db_user; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201612 ALTER COLUMN db_user SET DEFAULT "current_user"();


--
-- Name: log_data_201612 client_host; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201612 ALTER COLUMN client_host SET DEFAULT COALESCE(((inet_client_addr() || ':'::text) || inet_client_port()), 'LOCAL'::text);


--
-- Name: log_data_201612 search_path; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201612 ALTER COLUMN search_path SET DEFAULT btrim((current_schemas(true))::text, '{}'::text);


--
-- Name: log_data_201701 id; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201701 ALTER COLUMN id SET DEFAULT nextval('log_data_id_seq'::regclass);


--
-- Name: log_data_201701 created_at; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201701 ALTER COLUMN created_at SET DEFAULT now();


--
-- Name: log_data_201701 db_user; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201701 ALTER COLUMN db_user SET DEFAULT "current_user"();


--
-- Name: log_data_201701 client_host; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201701 ALTER COLUMN client_host SET DEFAULT COALESCE(((inet_client_addr() || ':'::text) || inet_client_port()), 'LOCAL'::text);


--
-- Name: log_data_201701 search_path; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201701 ALTER COLUMN search_path SET DEFAULT btrim((current_schemas(true))::text, '{}'::text);


--
-- Name: log_data_201702 id; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201702 ALTER COLUMN id SET DEFAULT nextval('log_data_id_seq'::regclass);


--
-- Name: log_data_201702 created_at; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201702 ALTER COLUMN created_at SET DEFAULT now();


--
-- Name: log_data_201702 db_user; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201702 ALTER COLUMN db_user SET DEFAULT "current_user"();


--
-- Name: log_data_201702 client_host; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201702 ALTER COLUMN client_host SET DEFAULT COALESCE(((inet_client_addr() || ':'::text) || inet_client_port()), 'LOCAL'::text);


--
-- Name: log_data_201702 search_path; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201702 ALTER COLUMN search_path SET DEFAULT btrim((current_schemas(true))::text, '{}'::text);


--
-- Name: log_data_201703 id; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201703 ALTER COLUMN id SET DEFAULT nextval('log_data_id_seq'::regclass);


--
-- Name: log_data_201703 created_at; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201703 ALTER COLUMN created_at SET DEFAULT now();


--
-- Name: log_data_201703 db_user; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201703 ALTER COLUMN db_user SET DEFAULT "current_user"();


--
-- Name: log_data_201703 client_host; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201703 ALTER COLUMN client_host SET DEFAULT COALESCE(((inet_client_addr() || ':'::text) || inet_client_port()), 'LOCAL'::text);


--
-- Name: log_data_201703 search_path; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201703 ALTER COLUMN search_path SET DEFAULT btrim((current_schemas(true))::text, '{}'::text);


--
-- Name: log_data_201704 id; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201704 ALTER COLUMN id SET DEFAULT nextval('log_data_id_seq'::regclass);


--
-- Name: log_data_201704 created_at; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201704 ALTER COLUMN created_at SET DEFAULT now();


--
-- Name: log_data_201704 db_user; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201704 ALTER COLUMN db_user SET DEFAULT "current_user"();


--
-- Name: log_data_201704 client_host; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201704 ALTER COLUMN client_host SET DEFAULT COALESCE(((inet_client_addr() || ':'::text) || inet_client_port()), 'LOCAL'::text);


--
-- Name: log_data_201704 search_path; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201704 ALTER COLUMN search_path SET DEFAULT btrim((current_schemas(true))::text, '{}'::text);


--
-- Name: log_data_201705 id; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201705 ALTER COLUMN id SET DEFAULT nextval('log_data_id_seq'::regclass);


--
-- Name: log_data_201705 created_at; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201705 ALTER COLUMN created_at SET DEFAULT now();


--
-- Name: log_data_201705 db_user; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201705 ALTER COLUMN db_user SET DEFAULT "current_user"();


--
-- Name: log_data_201705 client_host; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201705 ALTER COLUMN client_host SET DEFAULT COALESCE(((inet_client_addr() || ':'::text) || inet_client_port()), 'LOCAL'::text);


--
-- Name: log_data_201705 search_path; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201705 ALTER COLUMN search_path SET DEFAULT btrim((current_schemas(true))::text, '{}'::text);


--
-- Name: log_data_201706 id; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201706 ALTER COLUMN id SET DEFAULT nextval('log_data_id_seq'::regclass);


--
-- Name: log_data_201706 created_at; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201706 ALTER COLUMN created_at SET DEFAULT now();


--
-- Name: log_data_201706 db_user; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201706 ALTER COLUMN db_user SET DEFAULT "current_user"();


--
-- Name: log_data_201706 client_host; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201706 ALTER COLUMN client_host SET DEFAULT COALESCE(((inet_client_addr() || ':'::text) || inet_client_port()), 'LOCAL'::text);


--
-- Name: log_data_201706 search_path; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201706 ALTER COLUMN search_path SET DEFAULT btrim((current_schemas(true))::text, '{}'::text);


--
-- Name: log_data_201707 id; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201707 ALTER COLUMN id SET DEFAULT nextval('log_data_id_seq'::regclass);


--
-- Name: log_data_201707 created_at; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201707 ALTER COLUMN created_at SET DEFAULT now();


--
-- Name: log_data_201707 db_user; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201707 ALTER COLUMN db_user SET DEFAULT "current_user"();


--
-- Name: log_data_201707 client_host; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201707 ALTER COLUMN client_host SET DEFAULT COALESCE(((inet_client_addr() || ':'::text) || inet_client_port()), 'LOCAL'::text);


--
-- Name: log_data_201707 search_path; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201707 ALTER COLUMN search_path SET DEFAULT btrim((current_schemas(true))::text, '{}'::text);


--
-- Name: log_data_201708 id; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201708 ALTER COLUMN id SET DEFAULT nextval('log_data_id_seq'::regclass);


--
-- Name: log_data_201708 created_at; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201708 ALTER COLUMN created_at SET DEFAULT now();


--
-- Name: log_data_201708 db_user; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201708 ALTER COLUMN db_user SET DEFAULT "current_user"();


--
-- Name: log_data_201708 client_host; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201708 ALTER COLUMN client_host SET DEFAULT COALESCE(((inet_client_addr() || ':'::text) || inet_client_port()), 'LOCAL'::text);


--
-- Name: log_data_201708 search_path; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data_201708 ALTER COLUMN search_path SET DEFAULT btrim((current_schemas(true))::text, '{}'::text);


--
-- Name: pat_normalized_family_relationships id; Type: DEFAULT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY pat_normalized_family_relationships ALTER COLUMN id SET DEFAULT nextval('pat_normalized_family_relationships_id_seq'::regclass);


SET search_path = ptab, pg_catalog;

--
-- Name: ptab_annotations id; Type: DEFAULT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_annotations ALTER COLUMN id SET DEFAULT nextval('ptab_annotations_id_seq'::regclass);


--
-- Name: ptab_attorney id; Type: DEFAULT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_attorney ALTER COLUMN id SET DEFAULT nextval('ptab_attorney_id_seq'::regclass);


--
-- Name: ptab_case_detail_party_types id; Type: DEFAULT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_case_detail_party_types ALTER COLUMN id SET DEFAULT nextval('ptab_case_detail_party_types_id_seq'::regclass);


--
-- Name: ptab_case_details id; Type: DEFAULT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_case_details ALTER COLUMN id SET DEFAULT nextval('ptab_case_details_id_seq'::regclass);


--
-- Name: ptab_case_relationships id; Type: DEFAULT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_case_relationships ALTER COLUMN id SET DEFAULT nextval('ptab_case_relationships_id_seq'::regclass);


--
-- Name: ptab_case_status_changes id; Type: DEFAULT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_case_status_changes ALTER COLUMN id SET DEFAULT nextval('ptab_case_status_changes_id_seq'::regclass);


--
-- Name: ptab_cases id; Type: DEFAULT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_cases ALTER COLUMN id SET DEFAULT nextval('ptab_cases_id_seq'::regclass);


--
-- Name: ptab_doc_types id; Type: DEFAULT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_doc_types ALTER COLUMN id SET DEFAULT nextval('ptab_doc_types_id_seq'::regclass);


--
-- Name: ptab_expert_info id; Type: DEFAULT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_expert_info ALTER COLUMN id SET DEFAULT nextval('ptab_expert_info_id_seq'::regclass);


--
-- Name: ptab_judges_map id; Type: DEFAULT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_judges_map ALTER COLUMN id SET DEFAULT nextval('ptab_judges_map_id_seq'::regclass);


--
-- Name: ptab_parties id; Type: DEFAULT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_parties ALTER COLUMN id SET DEFAULT nextval('ptab_parties_id_seq'::regclass);


--
-- Name: ptab_parties_representations id; Type: DEFAULT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_parties_representations ALTER COLUMN id SET DEFAULT nextval('ptab_parties_representations_id_seq'::regclass);


--
-- Name: ptab_party_types id; Type: DEFAULT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_party_types ALTER COLUMN id SET DEFAULT nextval('ptab_party_types_id_seq'::regclass);


--
-- Name: technology_centers id; Type: DEFAULT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY technology_centers ALTER COLUMN id SET DEFAULT nextval('technology_centers_id_seq'::regclass);


SET search_path = public, pg_catalog;

--
-- Name: documents id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY documents ALTER COLUMN id SET DEFAULT nextval('documents_id_seq'::regclass);


--
-- Name: patents id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY patents ALTER COLUMN id SET DEFAULT nextval('patents_id_seq'::regclass);


SET search_path = acquiflow, pg_catalog;

SET default_tablespace = rpx_user_default;

--
-- Name: acquisition_agreements acquisition_agreement_pk; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY acquisition_agreements
    ADD CONSTRAINT acquisition_agreement_pk PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: acquisition_agreements_agreement_types acquisition_agreements_agreement_types_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_agreements_agreement_types
    ADD CONSTRAINT acquisition_agreements_agreement_types_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: acquisition_encumbrances acquisition_encumbrance_pk; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY acquisition_encumbrances
    ADD CONSTRAINT acquisition_encumbrance_pk PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: acquisition_opportunities_portfolios acquisition_opportunities_portfolios_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_opportunities_portfolios
    ADD CONSTRAINT acquisition_opportunities_portfolios_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: acquisition_options acquisition_options_pk; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY acquisition_options
    ADD CONSTRAINT acquisition_options_pk PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: acquisition_patent_attributes_dcl acquisition_patent_attributes_dcl_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patent_attributes_dcl
    ADD CONSTRAINT acquisition_patent_attributes_dcl_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: acquisition_patent_attributes acquisition_patent_attributes_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY acquisition_patent_attributes
    ADD CONSTRAINT acquisition_patent_attributes_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: acquisition_patents_current_assignee_aliases acquisition_patents_current_assignee_aliases_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patents_current_assignee_aliases
    ADD CONSTRAINT acquisition_patents_current_assignee_aliases_pkey PRIMARY KEY (id);


--
-- Name: acquisition_patents_dcl_current_assignee_aliases acquisition_patents_dcl_current_assignee_aliases_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patents_dcl_current_assignee_aliases
    ADD CONSTRAINT acquisition_patents_dcl_current_assignee_aliases_pkey PRIMARY KEY (id);


--
-- Name: acquisition_patents_dcl acquisition_patents_dcl_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patents_dcl
    ADD CONSTRAINT acquisition_patents_dcl_pkey PRIMARY KEY (id);


--
-- Name: acquisition_patents_dcl_rpx_ownership_rights acquisition_patents_dcl_rpx_ownership_rights_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patents_dcl_rpx_ownership_rights
    ADD CONSTRAINT acquisition_patents_dcl_rpx_ownership_rights_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: acquisition_patents acquisition_patents_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY acquisition_patents
    ADD CONSTRAINT acquisition_patents_pkey PRIMARY KEY (id);


--
-- Name: acquisitions acquisition_pk; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY acquisitions
    ADD CONSTRAINT acquisition_pk PRIMARY KEY (id);


--
-- Name: acquisition_restrictions acquisition_restriction_pk; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY acquisition_restrictions
    ADD CONSTRAINT acquisition_restriction_pk PRIMARY KEY (id);


--
-- Name: acquisition_syndications acquisition_syndication_pk; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY acquisition_syndications
    ADD CONSTRAINT acquisition_syndication_pk PRIMARY KEY (id);


--
-- Name: acquisition_types acquisition_type_pk; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY acquisition_types
    ADD CONSTRAINT acquisition_type_pk PRIMARY KEY (id);


--
-- Name: agreement_terms agreement_term_pk; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY agreement_terms
    ADD CONSTRAINT agreement_term_pk PRIMARY KEY (id);


--
-- Name: agreement_types agreement_type_pk; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY agreement_types
    ADD CONSTRAINT agreement_type_pk PRIMARY KEY (id);


--
-- Name: asset_inventory_cpi asset_inventory_cpi_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY asset_inventory_cpi
    ADD CONSTRAINT asset_inventory_cpi_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: asset_sources asset_sources_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY asset_sources
    ADD CONSTRAINT asset_sources_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: asset_status_types asset_status_types_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY asset_status_types
    ADD CONSTRAINT asset_status_types_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: batch_generated_option_ents batch_generated_option_ents_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY batch_generated_option_ents
    ADD CONSTRAINT batch_generated_option_ents_pkey PRIMARY KEY (id);


--
-- Name: batch_generated_option_statuses batch_generated_option_statuses_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY batch_generated_option_statuses
    ADD CONSTRAINT batch_generated_option_statuses_pkey PRIMARY KEY (id);


--
-- Name: batch_generated_option_types batch_generated_option_types_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY batch_generated_option_types
    ADD CONSTRAINT batch_generated_option_types_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: case_types case_types_name_key; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY case_types
    ADD CONSTRAINT case_types_name_key UNIQUE (name);


--
-- Name: case_types case_types_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY case_types
    ADD CONSTRAINT case_types_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: counter_party_types counter_party_types_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY counter_party_types
    ADD CONSTRAINT counter_party_types_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: cpi_file_snapshot cpi_file_snapshot_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY cpi_file_snapshot
    ADD CONSTRAINT cpi_file_snapshot_pkey PRIMARY KEY (id);


--
-- Name: cpi_tracking_status cpi_tracking_status_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY cpi_tracking_status
    ADD CONSTRAINT cpi_tracking_status_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: divestiture_patents divestiture_id_acq_patent_id_uniq; Type: CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY divestiture_patents
    ADD CONSTRAINT divestiture_id_acq_patent_id_uniq UNIQUE (divestiture_id, acquisition_patents_dcl_id);


--
-- Name: divestiture_patents divestiture_patents_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY divestiture_patents
    ADD CONSTRAINT divestiture_patents_pkey PRIMARY KEY (id);


--
-- Name: divestitures divestitures_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY divestitures
    ADD CONSTRAINT divestitures_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: encumbrance_types encumbrance_type_pk; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY encumbrance_types
    ADD CONSTRAINT encumbrance_type_pk PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: exercised_batch_options exercised_batch_options_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY exercised_batch_options
    ADD CONSTRAINT exercised_batch_options_pkey PRIMARY KEY (id);


--
-- Name: manual_assets manual_assets_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY manual_assets
    ADD CONSTRAINT manual_assets_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: option_types option_type_pk; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY option_types
    ADD CONSTRAINT option_type_pk PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: options_report_download_requests options_report_download_requests_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY options_report_download_requests
    ADD CONSTRAINT options_report_download_requests_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: portfolios portfolio_pk; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY portfolios
    ADD CONSTRAINT portfolio_pk PRIMARY KEY (id);


--
-- Name: restriction_types restriction_type_pk; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY restriction_types
    ADD CONSTRAINT restriction_type_pk PRIMARY KEY (id);


--
-- Name: rpx_cpi_asset_tracking_log rpx_cpi_asset_tracking_log_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY rpx_cpi_asset_tracking_log
    ADD CONSTRAINT rpx_cpi_asset_tracking_log_pkey PRIMARY KEY (id);


--
-- Name: rpx_ownership_rights rpx_ownership_right_pk; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY rpx_ownership_rights
    ADD CONSTRAINT rpx_ownership_right_pk PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: selected_batch_generated_option_types selected_batch_generated_option_types_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY selected_batch_generated_option_types
    ADD CONSTRAINT selected_batch_generated_option_types_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: stage_cpi_weekly_master stage_cpi_weekly_master_pkey; Type: CONSTRAINT; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY stage_cpi_weekly_master
    ADD CONSTRAINT stage_cpi_weekly_master_pkey PRIMARY KEY (id);


SET search_path = core, pg_catalog;

SET default_tablespace = '';

--
-- Name: alias_contacts alias_contact_bk_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY alias_contacts
    ADD CONSTRAINT alias_contact_bk_pk PRIMARY KEY (id);


--
-- Name: alias_ent_details alias_ent_details_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY alias_ent_details
    ADD CONSTRAINT alias_ent_details_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: alias_roles alias_roles_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY alias_roles
    ADD CONSTRAINT alias_roles_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: aliases aliases_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY aliases
    ADD CONSTRAINT aliases_pk PRIMARY KEY (id);


--
-- Name: assignees_aliases_map assignees_aliases_map_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY assignees_aliases_map
    ADD CONSTRAINT assignees_aliases_map_pkey PRIMARY KEY (id);


--
-- Name: assignors_aliases_map assignors_aliases_map_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY assignors_aliases_map
    ADD CONSTRAINT assignors_aliases_map_pkey PRIMARY KEY (id);


--
-- Name: court_abbreviations court_abbreviations_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY court_abbreviations
    ADD CONSTRAINT court_abbreviations_pkey PRIMARY KEY (id);


--
-- Name: court_details court_details_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY court_details
    ADD CONSTRAINT court_details_pk PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: cpc_descriptions cpc_descriptions_code_key; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY cpc_descriptions
    ADD CONSTRAINT cpc_descriptions_code_key UNIQUE (code);


--
-- Name: cpc_descriptions cpc_descriptions_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY cpc_descriptions
    ADD CONSTRAINT cpc_descriptions_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: dma_lit_annotations dma_lit_annotations_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY dma_lit_annotations
    ADD CONSTRAINT dma_lit_annotations_pkey PRIMARY KEY (id);


--
-- Name: dma_lits_pats_map dma_lits_pats_map_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY dma_lits_pats_map
    ADD CONSTRAINT dma_lits_pats_map_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: docket_entries docket_entries_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY docket_entries
    ADD CONSTRAINT docket_entries_pkey PRIMARY KEY (id);


--
-- Name: docket_entry_documents_map docket_entry_documents_map__ids_is_main_unique; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY docket_entry_documents_map
    ADD CONSTRAINT docket_entry_documents_map__ids_is_main_unique UNIQUE (lit_document_id, docket_entry_id, is_main);


--
-- Name: docket_entry_documents_map docket_entry_documents_map_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY docket_entry_documents_map
    ADD CONSTRAINT docket_entry_documents_map_pkey PRIMARY KEY (id);


--
-- Name: ent_advanced_relationship_types ent_advanced_relationship_types_pk; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY ent_advanced_relationship_types
    ADD CONSTRAINT ent_advanced_relationship_types_pk PRIMARY KEY (id);


--
-- Name: ent_advanced_relationships ent_advanced_relationships_pk; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY ent_advanced_relationships
    ADD CONSTRAINT ent_advanced_relationships_pk PRIMARY KEY (id);


--
-- Name: ent_advanced_relationships_temporal ent_advanced_relationships_temporal_pk; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY ent_advanced_relationships_temporal
    ADD CONSTRAINT ent_advanced_relationships_temporal_pk PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: ent_relationships ent_relationships_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ent_relationships
    ADD CONSTRAINT ent_relationships_pk PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: ent_relationships_temporal ent_relationships_temporal_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY ent_relationships_temporal
    ADD CONSTRAINT ent_relationships_temporal_pkey PRIMARY KEY (id);


--
-- Name: ent_subtypes_map ent_subtypes_map_pk; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY ent_subtypes_map
    ADD CONSTRAINT ent_subtypes_map_pk PRIMARY KEY (id);


--
-- Name: ent_subtypes ent_subtypes_pk; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY ent_subtypes
    ADD CONSTRAINT ent_subtypes_pk PRIMARY KEY (id);


--
-- Name: entity_contacts entity_contacts_pk; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY entity_contacts
    ADD CONSTRAINT entity_contacts_pk PRIMARY KEY (id);


--
-- Name: ents_market_sector_types ents_market_sector_types_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY ents_market_sector_types
    ADD CONSTRAINT ents_market_sector_types_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: ents ents_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ents
    ADD CONSTRAINT ents_pk PRIMARY KEY (id);


--
-- Name: file_types file_types_description_key; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY file_types
    ADD CONSTRAINT file_types_description_key UNIQUE (description);


SET default_tablespace = rpx_user_default;

--
-- Name: foreign_application_priority_docs foreign_application_priority_docs_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY foreign_application_priority_docs
    ADD CONSTRAINT foreign_application_priority_docs_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: invention_owners invention_owners_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY invention_owners
    ADD CONSTRAINT invention_owners_pkey PRIMARY KEY (id);


--
-- Name: ipc_classes_hist ipc_classes_hist_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_classes_hist
    ADD CONSTRAINT ipc_classes_hist_pkey PRIMARY KEY (id);


--
-- Name: ipc_classes ipc_classes_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_classes
    ADD CONSTRAINT ipc_classes_pkey PRIMARY KEY (id);


--
-- Name: ipc_groups_hist ipc_groups_hist_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_groups_hist
    ADD CONSTRAINT ipc_groups_hist_pkey PRIMARY KEY (id);


--
-- Name: ipc_groups ipc_groups_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_groups
    ADD CONSTRAINT ipc_groups_pkey PRIMARY KEY (id);


--
-- Name: ipc_sections_hist ipc_sections_hist_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_sections_hist
    ADD CONSTRAINT ipc_sections_hist_pkey PRIMARY KEY (id);


--
-- Name: ipc_sections ipc_sections_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_sections
    ADD CONSTRAINT ipc_sections_pkey PRIMARY KEY (id);


--
-- Name: ipc_subclasses_hist ipc_subclasses_hist_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_subclasses_hist
    ADD CONSTRAINT ipc_subclasses_hist_pkey PRIMARY KEY (id);


--
-- Name: ipc_subclasses ipc_subclasses_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_subclasses
    ADD CONSTRAINT ipc_subclasses_pkey PRIMARY KEY (id);


--
-- Name: ipc_subgroups_hist ipc_subgroups_hist_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_subgroups_hist
    ADD CONSTRAINT ipc_subgroups_hist_pkey PRIMARY KEY (id);


--
-- Name: ipc_subgroups ipc_subgroups_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_subgroups
    ADD CONSTRAINT ipc_subgroups_pkey PRIMARY KEY (id);


--
-- Name: ipc_transfer ipc_transfer_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_transfer
    ADD CONSTRAINT ipc_transfer_pk PRIMARY KEY (id);


--
-- Name: judge_assignment_types judge_assignment_types_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY judge_assignment_types
    ADD CONSTRAINT judge_assignment_types_pk PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: lit_annotations lit_annotations_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY lit_annotations
    ADD CONSTRAINT lit_annotations_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: lit_case_aliases lit_case_aliases_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_case_aliases
    ADD CONSTRAINT lit_case_aliases_pk PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: lit_case_stages lit_case_stages_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY lit_case_stages
    ADD CONSTRAINT lit_case_stages_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: lit_cause_types lit_cause_types_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_cause_types
    ADD CONSTRAINT lit_cause_types_pk PRIMARY KEY (id);


--
-- Name: lit_classification_types lit_classification_types_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_classification_types
    ADD CONSTRAINT lit_classification_types_pk PRIMARY KEY (id);


--
-- Name: lit_courts lit_courts_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_courts
    ADD CONSTRAINT lit_courts_pkey PRIMARY KEY (id);


--
-- Name: lit_curated_cause_types lit_curated_cause_types_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_curated_cause_types
    ADD CONSTRAINT lit_curated_cause_types_pk PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: lit_document_orphans lit_document_orphans__lit_document_id_uniq_key; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY lit_document_orphans
    ADD CONSTRAINT lit_document_orphans__lit_document_id_uniq_key UNIQUE (lit_document_id);


--
-- Name: lit_document_orphans lit_document_orphans_pk; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY lit_document_orphans
    ADD CONSTRAINT lit_document_orphans_pk PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: lit_document_statuses lit_document_statuses_description_key; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_document_statuses
    ADD CONSTRAINT lit_document_statuses_description_key UNIQUE (description);


--
-- Name: lit_document_statuses lit_document_statuses_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_document_statuses
    ADD CONSTRAINT lit_document_statuses_pk PRIMARY KEY (id);


--
-- Name: lit_document_types lit_document_types_description_key; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_document_types
    ADD CONSTRAINT lit_document_types_description_key UNIQUE (description);


--
-- Name: lit_document_types lit_document_types_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_document_types
    ADD CONSTRAINT lit_document_types_pk PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: lit_documents lit_documents_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY lit_documents
    ADD CONSTRAINT lit_documents_pkey PRIMARY KEY (id);


--
-- Name: lit_families lit_families_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY lit_families
    ADD CONSTRAINT lit_families_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: file_types lit_file_types_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY file_types
    ADD CONSTRAINT lit_file_types_pk PRIMARY KEY (id);


--
-- Name: lit_judges_map lit_judges_map_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_judges_map
    ADD CONSTRAINT lit_judges_map_pkey PRIMARY KEY (id);


--
-- Name: lit_parties lit_parties_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_parties
    ADD CONSTRAINT lit_parties_pk PRIMARY KEY (id);


--
-- Name: lit_parties_representations lit_parties_representations_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_parties_representations
    ADD CONSTRAINT lit_parties_representations_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: lit_party_normalized_types lit_party_normalized_types_name_key; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY lit_party_normalized_types
    ADD CONSTRAINT lit_party_normalized_types_name_key UNIQUE (name);


--
-- Name: lit_party_normalized_types lit_party_normalized_types_pk; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY lit_party_normalized_types
    ADD CONSTRAINT lit_party_normalized_types_pk PRIMARY KEY (id);


--
-- Name: lit_party_outcome_subtypes lit_party_outcome_subtypes_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY lit_party_outcome_subtypes
    ADD CONSTRAINT lit_party_outcome_subtypes_pkey PRIMARY KEY (id);


--
-- Name: lit_party_outcome_type_subtype_map lit_party_outcome_type_subtype_map_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY lit_party_outcome_type_subtype_map
    ADD CONSTRAINT lit_party_outcome_type_subtype_map_pkey PRIMARY KEY (id);


--
-- Name: lit_party_outcome_types lit_party_outcome_types_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY lit_party_outcome_types
    ADD CONSTRAINT lit_party_outcome_types_pkey PRIMARY KEY (id);


--
-- Name: lit_party_outcomes lit_party_outcomes_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY lit_party_outcomes
    ADD CONSTRAINT lit_party_outcomes_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: lit_party_types lit_party_types_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_party_types
    ADD CONSTRAINT lit_party_types_pk PRIMARY KEY (id);


--
-- Name: lit_relationship_types lit_relationship_types_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_relationship_types
    ADD CONSTRAINT lit_relationship_types_pk PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: lit_relationships lit_relationships_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY lit_relationships
    ADD CONSTRAINT lit_relationships_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: lit_stages lit_stages_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_stages
    ADD CONSTRAINT lit_stages_pk PRIMARY KEY (id);


--
-- Name: lit_types lit_types_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_types
    ADD CONSTRAINT lit_types_pk PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: lits_pats_map lits_pats_map_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY lits_pats_map
    ADD CONSTRAINT lits_pats_map_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: lits_pats_other lits_pats_other_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lits_pats_other
    ADD CONSTRAINT lits_pats_other_pkey PRIMARY KEY (id);


--
-- Name: lits lits_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lits
    ADD CONSTRAINT lits_pk PRIMARY KEY (id);


--
-- Name: market_sector_types market_sector_types_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY market_sector_types
    ADD CONSTRAINT market_sector_types_pk PRIMARY KEY (id);


--
-- Name: msg_queue msg_queue_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY msg_queue
    ADD CONSTRAINT msg_queue_pkey PRIMARY KEY (msg_id);


--
-- Name: pat_other_references orfs_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_other_references
    ADD CONSTRAINT orfs_pkey PRIMARY KEY (id);


--
-- Name: pat_abstracts pat_abstracts_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_abstracts
    ADD CONSTRAINT pat_abstracts_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: pat_assignments_assoc_r_f pat_assignments_assoc_r_f_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_assignments_assoc_r_f
    ADD CONSTRAINT pat_assignments_assoc_r_f_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: pat_assignments pat_assignments_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_assignments
    ADD CONSTRAINT pat_assignments_pk PRIMARY KEY (id);


--
-- Name: pat_claim_relationships pat_claim_relationships_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_claim_relationships
    ADD CONSTRAINT pat_claim_relationships_pk PRIMARY KEY (id);


--
-- Name: pat_claims pat_claims_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_claims
    ADD CONSTRAINT pat_claims_pk PRIMARY KEY (id);

ALTER TABLE pat_claims CLUSTER ON pat_claims_pk;


--
-- Name: pat_claims_s3 pat_claims_s3_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_claims_s3
    ADD CONSTRAINT pat_claims_s3_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: pat_cross_ref_classes pat_cross_ref_classes_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_cross_ref_classes
    ADD CONSTRAINT pat_cross_ref_classes_pkey PRIMARY KEY (id);


--
-- Name: pat_current pat_current_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_current
    ADD CONSTRAINT pat_current_pkey PRIMARY KEY (app_num_country);


SET default_tablespace = '';

--
-- Name: pat_descriptions pat_descriptions_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_descriptions
    ADD CONSTRAINT pat_descriptions_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: pat_document_types pat_document_types_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_document_types
    ADD CONSTRAINT pat_document_types_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: pat_documents pat_documents_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_documents
    ADD CONSTRAINT pat_documents_pk PRIMARY KEY (id);


--
-- Name: pat_drawings pat_drawings_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_drawings
    ADD CONSTRAINT pat_drawings_pk PRIMARY KEY (id);


--
-- Name: pat_ent_relationships_tmp pat_ent_relationships_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_ent_relationships_tmp
    ADD CONSTRAINT pat_ent_relationships_pkey PRIMARY KEY (id);


--
-- Name: pat_ent_relationships pat_ent_relationships_temp_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_ent_relationships
    ADD CONSTRAINT pat_ent_relationships_temp_pkey PRIMARY KEY (id);


--
-- Name: pat_family_pats_details pat_family_pats_details_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_family_pats_details
    ADD CONSTRAINT pat_family_pats_details_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: pat_ipc_classes pat_ipc_classes_pk; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_ipc_classes
    ADD CONSTRAINT pat_ipc_classes_pk PRIMARY KEY (id);


--
-- Name: pat_maintenance_code pat_maintenance_code_pk; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_maintenance_code
    ADD CONSTRAINT pat_maintenance_code_pk PRIMARY KEY (id);


--
-- Name: pat_maintenance_fee_entity_types pat_maintenance_fee_entity_types_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_maintenance_fee_entity_types
    ADD CONSTRAINT pat_maintenance_fee_entity_types_pkey PRIMARY KEY (id);


--
-- Name: pat_maintenance_fee_event_types pat_maintenance_fee_event_types_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_maintenance_fee_event_types
    ADD CONSTRAINT pat_maintenance_fee_event_types_pkey PRIMARY KEY (id);


--
-- Name: pat_maintenance_fee_events pat_maintenance_fee_events_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_maintenance_fee_events
    ADD CONSTRAINT pat_maintenance_fee_events_pkey PRIMARY KEY (id);


--
-- Name: pat_orig_app_num_country pat_orig_app_num_country_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_orig_app_num_country
    ADD CONSTRAINT pat_orig_app_num_country_pkey PRIMARY KEY (id);


--
-- Name: pat_primary_conveyance_types pat_primary_conveyance_types_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_primary_conveyance_types
    ADD CONSTRAINT pat_primary_conveyance_types_pkey PRIMARY KEY (id);


--
-- Name: pat_priority_claims pat_priority_claims_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_priority_claims
    ADD CONSTRAINT pat_priority_claims_pkey PRIMARY KEY (id);


--
-- Name: pat_references pat_references_pat_ref_uniq; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_references
    ADD CONSTRAINT pat_references_pat_ref_uniq UNIQUE (pat_id, ref_pat_id);


SET default_tablespace = '';

--
-- Name: pat_references pat_references_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_references
    ADD CONSTRAINT pat_references_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: pat_reissue_number pat_reissue_number_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_reissue_number
    ADD CONSTRAINT pat_reissue_number_pkey PRIMARY KEY (pat_id);


SET default_tablespace = '';

--
-- Name: pat_related_documents pat_related_documents_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_related_documents
    ADD CONSTRAINT pat_related_documents_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: pat_secondary_conveyance pat_secondary_conveyance_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_secondary_conveyance
    ADD CONSTRAINT pat_secondary_conveyance_pkey PRIMARY KEY (id);


--
-- Name: pat_secondary_conveyance_types pat_secondary_conveyance_types_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_secondary_conveyance_types
    ADD CONSTRAINT pat_secondary_conveyance_types_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: pat_stats_all_assignees pat_stats_all_assignees_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_stats_all_assignees
    ADD CONSTRAINT pat_stats_all_assignees_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: pat_stats_continuances pat_stats_continuances_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_stats_continuances
    ADD CONSTRAINT pat_stats_continuances_pkey PRIMARY KEY (id);


--
-- Name: pat_stats_current_assignees pat_stats_current_assignees_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_stats_current_assignees
    ADD CONSTRAINT pat_stats_current_assignees_pkey PRIMARY KEY (id);


--
-- Name: pat_stats_current_assignors pat_stats_current_assignors_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_stats_current_assignors
    ADD CONSTRAINT pat_stats_current_assignors_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: pat_stats_inventors pat_stats_inventors_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_stats_inventors
    ADD CONSTRAINT pat_stats_inventors_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: pat_stats pat_stats_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_stats
    ADD CONSTRAINT pat_stats_pkey PRIMARY KEY (id);

ALTER TABLE pat_stats CLUSTER ON pat_stats_pkey;


--
-- Name: pat_stats_sponsoring_parties pat_stats_sponsoring_parties_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_stats_sponsoring_parties
    ADD CONSTRAINT pat_stats_sponsoring_parties_pkey PRIMARY KEY (id);


--
-- Name: patent_owners patent_owners_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY patent_owners
    ADD CONSTRAINT patent_owners_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: pats_aliases_map pats_aliases_map_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pats_aliases_map
    ADD CONSTRAINT pats_aliases_map_pkey PRIMARY KEY (id);


--
-- Name: pats_aliases_relationship_types pats_aliases_relationship_types_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pats_aliases_relationship_types
    ADD CONSTRAINT pats_aliases_relationship_types_pk PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: pats_assignments_map pats_assignments_map_pkey; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pats_assignments_map
    ADD CONSTRAINT pats_assignments_map_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: pats_field_of_search pats_field_of_search_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pats_field_of_search
    ADD CONSTRAINT pats_field_of_search_pk PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: pats_invention_link pats_invention_link_pk; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pats_invention_link
    ADD CONSTRAINT pats_invention_link_pk PRIMARY KEY (id);


--
-- Name: pats_invention pats_invention_pk; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pats_invention
    ADD CONSTRAINT pats_invention_pk PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: pats pats_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pats
    ADD CONSTRAINT pats_pk PRIMARY KEY (id);


--
-- Name: pats_withdrawn pats_withdrawn_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pats_withdrawn
    ADD CONSTRAINT pats_withdrawn_pkey PRIMARY KEY (id);


--
-- Name: ent_relationship_types pk_ent_relationship_types; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ent_relationship_types
    ADD CONSTRAINT pk_ent_relationship_types PRIMARY KEY (id);


--
-- Name: ent_types pk_ent_types; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ent_types
    ADD CONSTRAINT pk_ent_types PRIMARY KEY (id);


--
-- Name: queue_app_types queue_app_types_app_desc_unq; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY queue_app_types
    ADD CONSTRAINT queue_app_types_app_desc_unq UNIQUE (app_desc);


--
-- Name: queue_app_types queue_app_types_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY queue_app_types
    ADD CONSTRAINT queue_app_types_pk PRIMARY KEY (app_id);


--
-- Name: queue_msg_types queue_msg_types_id_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY queue_msg_types
    ADD CONSTRAINT queue_msg_types_id_pk PRIMARY KEY (msg_type_id);


--
-- Name: rails_admin_histories rails_admin_histories_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY rails_admin_histories
    ADD CONSTRAINT rails_admin_histories_pkey PRIMARY KEY (id);


--
-- Name: ravel_judges ravel_judges_pk; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ravel_judges
    ADD CONSTRAINT ravel_judges_pk PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: lit_party_outcome_type_subtype_map uniq_lit_party_outcome_type_subtype_map; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY lit_party_outcome_type_subtype_map
    ADD CONSTRAINT uniq_lit_party_outcome_type_subtype_map UNIQUE (lit_party_outcome_type_id, lit_party_outcome_subtype_id);


--
-- Name: pat_primary_conveyance_types unq_primary_conveyance_text; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_primary_conveyance_types
    ADD CONSTRAINT unq_primary_conveyance_text UNIQUE (primary_conveyance_text);


--
-- Name: pat_secondary_conveyance_types unq_secondary_conveyance_text; Type: CONSTRAINT; Schema: core; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_secondary_conveyance_types
    ADD CONSTRAINT unq_secondary_conveyance_text UNIQUE (secondary_conveyance_text);


SET default_tablespace = '';

--
-- Name: users users_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


--
-- Name: uspcs_classes uspcs_classes_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY uspcs_classes
    ADD CONSTRAINT uspcs_classes_pkey PRIMARY KEY (id);


--
-- Name: uspcs_subclasses uspcs_subclasses_pkey; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY uspcs_subclasses
    ADD CONSTRAINT uspcs_subclasses_pkey PRIMARY KEY (id);


--
-- Name: uspcs_to_ipc_mapping uspcs_to_ipc_mapping_pkey1; Type: CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY uspcs_to_ipc_mapping
    ADD CONSTRAINT uspcs_to_ipc_mapping_pkey1 PRIMARY KEY (id);


SET search_path = docdb, pg_catalog;

SET default_tablespace = rpx_user_default;

--
-- Name: docdb_abstracts docdb_abstracts_pkey; Type: CONSTRAINT; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY docdb_abstracts
    ADD CONSTRAINT docdb_abstracts_pkey PRIMARY KEY (id);


--
-- Name: docdb_applicants docdb_applicants_pkey; Type: CONSTRAINT; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY docdb_applicants
    ADD CONSTRAINT docdb_applicants_pkey PRIMARY KEY (id);


--
-- Name: docdb_batch docdb_batch_pk; Type: CONSTRAINT; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY docdb_batch
    ADD CONSTRAINT docdb_batch_pk PRIMARY KEY (id);


--
-- Name: docdb_citations docdb_citations_pkey; Type: CONSTRAINT; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY docdb_citations
    ADD CONSTRAINT docdb_citations_pkey PRIMARY KEY (id);


--
-- Name: docdb_classifications docdb_classifications_pkey; Type: CONSTRAINT; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY docdb_classifications
    ADD CONSTRAINT docdb_classifications_pkey PRIMARY KEY (id);


--
-- Name: docdb_inventors docdb_inventors_pkey; Type: CONSTRAINT; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY docdb_inventors
    ADD CONSTRAINT docdb_inventors_pkey PRIMARY KEY (id);


--
-- Name: docdb_ipcs docdb_ipcs_pkey; Type: CONSTRAINT; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY docdb_ipcs
    ADD CONSTRAINT docdb_ipcs_pkey PRIMARY KEY (id);


--
-- Name: docdb_national_classifications docdb_national_classifications_pkey; Type: CONSTRAINT; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY docdb_national_classifications
    ADD CONSTRAINT docdb_national_classifications_pkey PRIMARY KEY (id);


--
-- Name: docdb_pats docdb_pats_pkey; Type: CONSTRAINT; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY docdb_pats
    ADD CONSTRAINT docdb_pats_pkey PRIMARY KEY (id);


--
-- Name: docdb_titles docdb_titles_pkey; Type: CONSTRAINT; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY docdb_titles
    ADD CONSTRAINT docdb_titles_pkey PRIMARY KEY (id);


--
-- Name: inpadoc_ipr_events inpadoc_ipr_events_pkey; Type: CONSTRAINT; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY inpadoc_ipr_events
    ADD CONSTRAINT inpadoc_ipr_events_pkey PRIMARY KEY (id);


--
-- Name: inpadoc_legal_status_codes inpadoc_legal_status_codes_pkey; Type: CONSTRAINT; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY inpadoc_legal_status_codes
    ADD CONSTRAINT inpadoc_legal_status_codes_pkey PRIMARY KEY (id);


--
-- Name: log_data log_data_pk; Type: CONSTRAINT; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY log_data
    ADD CONSTRAINT log_data_pk PRIMARY KEY (id);


--
-- Name: pat_normalized_family_relationships pat_normalized_family_relationships_pkey; Type: CONSTRAINT; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY pat_normalized_family_relationships
    ADD CONSTRAINT pat_normalized_family_relationships_pkey PRIMARY KEY (id);


SET search_path = ptab, pg_catalog;

SET default_tablespace = '';

--
-- Name: ptab_case_details attachment_handle_unique_idx; Type: CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_case_details
    ADD CONSTRAINT attachment_handle_unique_idx UNIQUE (attachment_handle);


--
-- Name: ptab_party_types name_unique_idx; Type: CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_party_types
    ADD CONSTRAINT name_unique_idx UNIQUE (name);


--
-- Name: ptab_annotations ptab_annotations_pk; Type: CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_annotations
    ADD CONSTRAINT ptab_annotations_pk PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: ptab_attorney ptab_attorney_pkey; Type: CONSTRAINT; Schema: ptab; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY ptab_attorney
    ADD CONSTRAINT ptab_attorney_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: ptab_case_detail_party_types ptab_case_detail_type_unique_name; Type: CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_case_detail_party_types
    ADD CONSTRAINT ptab_case_detail_type_unique_name UNIQUE (name);


--
-- Name: ptab_case_details ptab_case_details_pk; Type: CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_case_details
    ADD CONSTRAINT ptab_case_details_pk PRIMARY KEY (id);


--
-- Name: ptab_case_relationships ptab_case_relationships_pkey; Type: CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_case_relationships
    ADD CONSTRAINT ptab_case_relationships_pkey PRIMARY KEY (id);


--
-- Name: ptab_case_status_changes ptab_case_status_changes_pk; Type: CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_case_status_changes
    ADD CONSTRAINT ptab_case_status_changes_pk PRIMARY KEY (id);


--
-- Name: ptab_case_types ptab_case_types_pk; Type: CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_case_types
    ADD CONSTRAINT ptab_case_types_pk PRIMARY KEY (id);


--
-- Name: ptab_cases_api ptab_cases_api_case_key_key; Type: CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_cases_api
    ADD CONSTRAINT ptab_cases_api_case_key_key UNIQUE (case_num);


--
-- Name: ptab_cases ptab_cases_pk; Type: CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_cases
    ADD CONSTRAINT ptab_cases_pk PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: ptab_doc_types ptab_doc_types_pkey; Type: CONSTRAINT; Schema: ptab; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY ptab_doc_types
    ADD CONSTRAINT ptab_doc_types_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: ptab_etl_properties ptab_etl_properties_pkey; Type: CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_etl_properties
    ADD CONSTRAINT ptab_etl_properties_pkey PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: ptab_expert_info ptab_expert_info_pkey; Type: CONSTRAINT; Schema: ptab; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY ptab_expert_info
    ADD CONSTRAINT ptab_expert_info_pkey PRIMARY KEY (src_id);


SET default_tablespace = '';

--
-- Name: ptab_case_detail_party_types ptab_filing_party_types_pk; Type: CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_case_detail_party_types
    ADD CONSTRAINT ptab_filing_party_types_pk PRIMARY KEY (id);


--
-- Name: ptab_judges_map ptab_judges_map_pkey; Type: CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_judges_map
    ADD CONSTRAINT ptab_judges_map_pkey PRIMARY KEY (id);


--
-- Name: ptab_judges_map ptab_judges_map_unique_idx; Type: CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_judges_map
    ADD CONSTRAINT ptab_judges_map_unique_idx UNIQUE (ptab_case_id, judge_alias_id);


SET default_tablespace = rpx_user_default;

--
-- Name: ptab_parties ptab_parties_pkey; Type: CONSTRAINT; Schema: ptab; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY ptab_parties
    ADD CONSTRAINT ptab_parties_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: ptab_parties_representations ptab_parties_representations_pkey; Type: CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_parties_representations
    ADD CONSTRAINT ptab_parties_representations_pkey PRIMARY KEY (id);


--
-- Name: ptab_party_types ptab_party_types_pk; Type: CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_party_types
    ADD CONSTRAINT ptab_party_types_pk PRIMARY KEY (id);


SET default_tablespace = rpx_user_default;

--
-- Name: technology_centers technology_centers_pkey; Type: CONSTRAINT; Schema: ptab; Owner: -; Tablespace: rpx_user_default
--

ALTER TABLE ONLY technology_centers
    ADD CONSTRAINT technology_centers_pkey PRIMARY KEY (id);


SET default_tablespace = '';

--
-- Name: technology_centers technology_centers_tech_center_number_unique_key; Type: CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY technology_centers
    ADD CONSTRAINT technology_centers_tech_center_number_unique_key UNIQUE (tech_center_number);


--
-- Name: ptab_case_relationships uptab_case_relationships_key; Type: CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_case_relationships
    ADD CONSTRAINT uptab_case_relationships_key UNIQUE (lead_case_id, joined_case_id);


SET search_path = public, pg_catalog;

--
-- Name: ar_internal_metadata ar_internal_metadata_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY ar_internal_metadata
    ADD CONSTRAINT ar_internal_metadata_pkey PRIMARY KEY (key);


--
-- Name: documents documents_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY documents
    ADD CONSTRAINT documents_pkey PRIMARY KEY (id);


--
-- Name: patents patents_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY patents
    ADD CONSTRAINT patents_pkey PRIMARY KEY (id);


SET search_path = acquiflow, pg_catalog;

--
-- Name: acquisition_agreements_agreem_acquisition_agreement_id_agre_idx; Type: INDEX; Schema: acquiflow; Owner: -
--

CREATE UNIQUE INDEX acquisition_agreements_agreem_acquisition_agreement_id_agre_idx ON acquisition_agreements_agreement_types USING btree (acquisition_agreement_id, agreement_type_id);


--
-- Name: acquisition_patents_acquisition_id_asset_source_asset_sourc_idx; Type: INDEX; Schema: acquiflow; Owner: -
--

CREATE UNIQUE INDEX acquisition_patents_acquisition_id_asset_source_asset_sourc_idx ON acquisition_patents USING btree (acquisition_id, asset_source, asset_source_id);


--
-- Name: acquisition_patents_attr_dcl_idx1; Type: INDEX; Schema: acquiflow; Owner: -
--

CREATE INDEX acquisition_patents_attr_dcl_idx1 ON acquisition_patent_attributes_dcl USING btree (acquisition_patent_id);


--
-- Name: acquisition_patents_dcl_acquisition_id_asset_source_asset_s_idx; Type: INDEX; Schema: acquiflow; Owner: -
--

CREATE UNIQUE INDEX acquisition_patents_dcl_acquisition_id_asset_source_asset_s_idx ON acquisition_patents_dcl USING btree (acquisition_id, asset_source, asset_source_id);


--
-- Name: acquisition_patents_dcl_idx1; Type: INDEX; Schema: acquiflow; Owner: -
--

CREATE INDEX acquisition_patents_dcl_idx1 ON acquisition_patents_dcl USING btree (stripped_patnum, country_code);


--
-- Name: acquisition_patents_dcl_idx2; Type: INDEX; Schema: acquiflow; Owner: -
--

CREATE INDEX acquisition_patents_dcl_idx2 ON acquisition_patents_dcl USING btree (acquisition_id, portfolio_id);


--
-- Name: acquisition_syndications_acquisition_id_entity_sf_account_i_idx; Type: INDEX; Schema: acquiflow; Owner: -
--

CREATE UNIQUE INDEX acquisition_syndications_acquisition_id_entity_sf_account_i_idx ON acquisition_syndications USING btree (acquisition_id, entity_sf_account_id);


--
-- Name: acquisitions_acquisition_name_idx; Type: INDEX; Schema: acquiflow; Owner: -
--

CREATE INDEX acquisitions_acquisition_name_idx ON acquisitions USING btree (acquisition_name);


--
-- Name: batch_generated_option_ents_option_id_account_id_idx; Type: INDEX; Schema: acquiflow; Owner: -
--

CREATE UNIQUE INDEX batch_generated_option_ents_option_id_account_id_idx ON batch_generated_option_ents USING btree (option_id, account_id);


--
-- Name: cpi_only_assets_patnum_country_idx; Type: INDEX; Schema: acquiflow; Owner: -
--

CREATE INDEX cpi_only_assets_patnum_country_idx ON cpi_only_assets USING btree (patent_number, country);


--
-- Name: divestitures_lower_idx; Type: INDEX; Schema: acquiflow; Owner: -
--

CREATE INDEX divestitures_lower_idx ON divestitures USING btree (lower((name)::text));


--
-- Name: exercised_batch_options_account_id_idx; Type: INDEX; Schema: acquiflow; Owner: -
--

CREATE INDEX exercised_batch_options_account_id_idx ON exercised_batch_options USING btree (entity_sf_account_id);


--
-- Name: exercised_batch_options_option_id_idx; Type: INDEX; Schema: acquiflow; Owner: -
--

CREATE INDEX exercised_batch_options_option_id_idx ON exercised_batch_options USING btree (option_id);


--
-- Name: idx1_acq_pats_str_pat_ctry; Type: INDEX; Schema: acquiflow; Owner: -
--

CREATE INDEX idx1_acq_pats_str_pat_ctry ON acquisition_patents USING btree (stripped_patnum, country_code);


--
-- Name: idx_acquisition_patents_asset_source_id; Type: INDEX; Schema: acquiflow; Owner: -
--

CREATE INDEX idx_acquisition_patents_asset_source_id ON acquisition_patents USING btree (asset_source_id, asset_source);


--
-- Name: idx_acquisition_pats_attribs_aqp_id; Type: INDEX; Schema: acquiflow; Owner: -
--

CREATE INDEX idx_acquisition_pats_attribs_aqp_id ON acquisition_patent_attributes USING btree (acquisition_patent_id);


--
-- Name: idx_cpi_only_assets_patnum_wipo; Type: INDEX; Schema: acquiflow; Owner: -
--

CREATE INDEX idx_cpi_only_assets_patnum_wipo ON asset_inventory_cpi USING btree (patent_number, wipo);


--
-- Name: manual_assets_patnum_country_idx; Type: INDEX; Schema: acquiflow; Owner: -
--

CREATE INDEX manual_assets_patnum_country_idx ON manual_assets USING btree (patent_number, country);


--
-- Name: portfolios_portfolio_name_idx; Type: INDEX; Schema: acquiflow; Owner: -
--

CREATE INDEX portfolios_portfolio_name_idx ON portfolios USING btree (portfolio_name);


SET default_tablespace = rpx_user_default;

--
-- Name: rpx_cpi_asset_tracking_log__app_id__run_id_idx; Type: INDEX; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX rpx_cpi_asset_tracking_log__app_id__run_id_idx ON rpx_cpi_asset_tracking_log USING btree (app_id, run_id);


--
-- Name: rpx_cpi_asset_tracking_log__app_name_idx; Type: INDEX; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX rpx_cpi_asset_tracking_log__app_name_idx ON rpx_cpi_asset_tracking_log USING btree (app_name);


--
-- Name: rpx_cpi_asset_tracking_log__log_level_id__created_at_idx; Type: INDEX; Schema: acquiflow; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX rpx_cpi_asset_tracking_log__log_level_id__created_at_idx ON rpx_cpi_asset_tracking_log USING btree (log_level_id, created_at);


SET search_path = core, pg_catalog;

SET default_tablespace = '';

--
-- Name: alias_contacts_bk_fkey_alias_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX alias_contacts_bk_fkey_alias_id ON alias_contacts USING btree (alias_id);


--
-- Name: alias_contacts_bk_indx_email; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX alias_contacts_bk_indx_email ON alias_contacts USING btree (email);


--
-- Name: alias_contacts_bk_indx_fax; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX alias_contacts_bk_indx_fax ON alias_contacts USING btree (fax);


--
-- Name: alias_contacts_bk_indx_full_address; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX alias_contacts_bk_indx_full_address ON alias_contacts USING btree (line1, line2, line3, city, state_or_province, postal_code, country);


--
-- Name: alias_contacts_bk_indx_phone; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX alias_contacts_bk_indx_phone ON alias_contacts USING btree (phone);


SET default_tablespace = rpx_user_default;

--
-- Name: aliases__clean_name__is_verified_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX aliases__clean_name__is_verified_idx ON aliases USING btree (clean_name, is_verified);


--
-- Name: aliases__core_name_funct_short_name_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX aliases__core_name_funct_short_name_idx ON aliases USING btree (code_nerd.short_name(core_name, 2));


--
-- Name: aliases__core_name_trgm_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX aliases__core_name_trgm_idx ON aliases USING gist (core_name);


--
-- Name: aliases__created_at_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX aliases__created_at_idx ON aliases USING btree (created_at);


--
-- Name: aliases__fingerprint_trgm_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX aliases__fingerprint_trgm_idx ON aliases USING gist (fingerprint);


--
-- Name: aliases__updated_at_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX aliases__updated_at_idx ON aliases USING btree (updated_at);


SET default_tablespace = '';

--
-- Name: aliases_clean_name_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX aliases_clean_name_idx ON aliases USING gist (clean_name);


--
-- Name: aliases_fkey_ent_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX aliases_fkey_ent_id ON aliases USING btree (ent_id);


--
-- Name: any_assignee_alias_id_gin_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX any_assignee_alias_id_gin_idx ON pat_ent_relationships USING gin (any_assignee_alias_ids public.gin__int_ops);


--
-- Name: any_assignee_alias_ids_gin_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX any_assignee_alias_ids_gin_idx ON pat_ent_relationships_tmp USING gin (any_assignee_alias_ids);


--
-- Name: any_assignee_ent_id_gin_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX any_assignee_ent_id_gin_idx ON pat_ent_relationships USING gin (any_assignee_ent_ids public.gin__int_ops);


--
-- Name: any_assignee_ent_ids_gin_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX any_assignee_ent_ids_gin_idx ON pat_ent_relationships_tmp USING gin (any_assignee_ent_ids);


SET default_tablespace = rpx_user_default;

--
-- Name: assignees_aliases_map__alias_contact_id_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX assignees_aliases_map__alias_contact_id_idx ON assignees_aliases_map USING btree (alias_contact_id);


SET default_tablespace = '';

--
-- Name: assignees_aliases_map__assignment_id_alias_id_uniq_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX assignees_aliases_map__assignment_id_alias_id_uniq_idx ON assignees_aliases_map USING btree (assignment_id, alias_id);


--
-- Name: assignees_aliases_map_fkey_alias_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX assignees_aliases_map_fkey_alias_id ON assignees_aliases_map USING btree (alias_id);


--
-- Name: assignees_aliases_map_fkey_assignment_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX assignees_aliases_map_fkey_assignment_id ON assignees_aliases_map USING btree (assignment_id);


--
-- Name: assignors_aliases_map__assignment_id_alias_id_execution_date; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX assignors_aliases_map__assignment_id_alias_id_execution_date ON assignors_aliases_map USING btree (assignment_id, alias_id, execution_date);


--
-- Name: assignors_aliases_map_fkey_alias_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX assignors_aliases_map_fkey_alias_id ON assignors_aliases_map USING btree (alias_id);


--
-- Name: assignors_aliases_map_fkey_assignment_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX assignors_aliases_map_fkey_assignment_id ON assignors_aliases_map USING btree (assignment_id);


--
-- Name: court_details_fkey_ent_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX court_details_fkey_ent_id ON court_details USING btree (ent_id);


--
-- Name: current_assignee_alias_id_gin_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX current_assignee_alias_id_gin_idx ON pat_ent_relationships USING gin (current_assignee_alias_ids public.gin__int_ops);


--
-- Name: current_assignee_alias_ids_gin_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX current_assignee_alias_ids_gin_idx ON pat_ent_relationships_tmp USING gin (current_assignee_alias_ids);


--
-- Name: current_assignee_ent_id_gin_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX current_assignee_ent_id_gin_idx ON pat_ent_relationships USING gin (current_assignee_ent_ids public.gin__int_ops);


--
-- Name: current_assignee_ent_ids_gin_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX current_assignee_ent_ids_gin_idx ON pat_ent_relationships_tmp USING gin (current_assignee_ent_ids);


--
-- Name: dma_lit_annotations_lit_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX dma_lit_annotations_lit_id_idx ON dma_lit_annotations USING btree (lit_id);


--
-- Name: dma_lit_annotations_lit_type_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX dma_lit_annotations_lit_type_id_idx ON dma_lit_annotations USING btree (lit_type_id);


--
-- Name: dma_lit_annotations_market_sector_type_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX dma_lit_annotations_market_sector_type_id_idx ON dma_lit_annotations USING btree (market_sector_type_id);


--
-- Name: dma_lits_pats_map_lit_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX dma_lits_pats_map_lit_id_idx ON dma_lits_pats_map USING btree (lit_id);


--
-- Name: dma_lits_pats_map_lit_id_patnum_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX dma_lits_pats_map_lit_id_patnum_idx ON dma_lits_pats_map USING btree (lit_id, patnum);


--
-- Name: dma_lits_pats_map_patnum_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX dma_lits_pats_map_patnum_idx ON dma_lits_pats_map USING btree (patnum);


--
-- Name: docket_entries_created_at_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX docket_entries_created_at_idx ON docket_entries USING btree (created_at);


SET default_tablespace = rpx_user_default;

--
-- Name: docket_entries_docket_text_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX docket_entries_docket_text_idx ON docket_entries USING gist (docket_text public.gist_trgm_ops);


--
-- Name: docket_entries_fkey_lit_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX docket_entries_fkey_lit_id ON docket_entries USING btree (lit_id);


--
-- Name: docket_entry_documents_map_fkey_docket_entry_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX docket_entry_documents_map_fkey_docket_entry_id ON docket_entry_documents_map USING btree (docket_entry_id);


--
-- Name: docket_entry_documents_map_fkey_lit_document_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX docket_entry_documents_map_fkey_lit_document_id ON docket_entry_documents_map USING btree (lit_document_id);


SET default_tablespace = '';

--
-- Name: docket_entry_documents_map_is_main_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX docket_entry_documents_map_is_main_idx ON docket_entry_documents_map USING btree (is_main);


SET default_tablespace = rpx_user_default;

--
-- Name: ent_advanced_relationship_types_name_unique_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX ent_advanced_relationship_types_name_unique_idx ON ent_advanced_relationship_types USING btree (name);


--
-- Name: ent_advanced_relationships_temporal_ent_advanced_relationship_t; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX ent_advanced_relationships_temporal_ent_advanced_relationship_t ON ent_advanced_relationships_temporal USING btree (ent_advanced_relationship_type_id);


SET default_tablespace = '';

--
-- Name: ent_relationship_types_name_unique_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX ent_relationship_types_name_unique_idx ON ent_relationship_types USING btree (name);


--
-- Name: ent_relationships_ent_id_related_ent_id_ent_relationship_ty_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX ent_relationships_ent_id_related_ent_id_ent_relationship_ty_idx ON ent_relationships USING btree (ent_id, related_ent_id, ent_relationship_type_id);


--
-- Name: ent_relationships_fkey_ent_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX ent_relationships_fkey_ent_id ON ent_relationships USING btree (ent_id);


--
-- Name: ent_relationships_fkey_ent_relationship_type_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX ent_relationships_fkey_ent_relationship_type_id ON ent_relationships USING btree (ent_relationship_type_id);


--
-- Name: ent_relationships_fkey_related_ent_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX ent_relationships_fkey_related_ent_id ON ent_relationships USING btree (related_ent_id);


SET default_tablespace = rpx_user_default;

--
-- Name: ent_subtypes_name_unique_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX ent_subtypes_name_unique_idx ON ent_subtypes USING btree (name);


SET default_tablespace = '';

--
-- Name: ent_types_name_unique_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX ent_types_name_unique_idx ON ent_types USING btree (name);


SET default_tablespace = rpx_user_default;

--
-- Name: entity_contacts_email_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX entity_contacts_email_idx ON entity_contacts USING btree (email);


--
-- Name: entity_contacts_ent_id_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX entity_contacts_ent_id_idx ON entity_contacts USING btree (ent_id);


--
-- Name: entity_contacts_fax_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX entity_contacts_fax_idx ON entity_contacts USING btree (fax);


--
-- Name: entity_contacts_full_address_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX entity_contacts_full_address_idx ON entity_contacts USING btree (line1, line2, line3, city, state_or_province, postal_code, country);


--
-- Name: entity_contacts_phone_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX entity_contacts_phone_idx ON entity_contacts USING btree (phone);


SET default_tablespace = '';

--
-- Name: ents__core_name_trgm_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX ents__core_name_trgm_idx ON ents USING gist (core_name public.gist_trgm_ops);


SET default_tablespace = rpx_user_default;

--
-- Name: ents__created_at_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX ents__created_at_idx ON ents USING btree (created_at);


SET default_tablespace = '';

--
-- Name: ents__fingerprint_trgm_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX ents__fingerprint_trgm_idx ON ents USING gist (fingerprint public.gist_trgm_ops);


--
-- Name: ents__name_trgm_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX ents__name_trgm_idx ON ents USING gist (name public.gist_trgm_ops);


--
-- Name: ents__name_unique_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX ents__name_unique_idx ON ents USING btree (name);


SET default_tablespace = rpx_user_default;

--
-- Name: ents__ultimate_parent_id_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX ents__ultimate_parent_id_idx ON ents USING btree (ultimate_parent_id);


--
-- Name: ents__updated_at_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX ents__updated_at_idx ON ents USING btree (updated_at);


SET default_tablespace = '';

--
-- Name: ents_ent_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX ents_ent_id_idx ON similar_ents_tmp USING btree (ent_id);


--
-- Name: ents_ent_id_to_delete_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX ents_ent_id_to_delete_idx ON similar_ents_tmp USING btree (ent_id_to_delete);


--
-- Name: ents_ent_name_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX ents_ent_name_idx ON similar_ents_tmp USING btree (ent_name);


--
-- Name: ents_ent_name_to_delete_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX ents_ent_name_to_delete_idx ON similar_ents_tmp USING btree (ent_name_to_delete);


--
-- Name: ents_fkey_ent_type_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX ents_fkey_ent_type_id ON ents USING btree (ent_type_id);


SET default_tablespace = rpx_user_default;

--
-- Name: ents_market_sector_types__ent_id_market_sector_type_id_uniq_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX ents_market_sector_types__ent_id_market_sector_type_id_uniq_idx ON ents_market_sector_types USING btree (ent_id, market_sector_type_id);


SET default_tablespace = '';

--
-- Name: ents_market_sector_types_fkey_ent_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX ents_market_sector_types_fkey_ent_id ON ents_market_sector_types USING btree (ent_id);


--
-- Name: ents_salesforce_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX ents_salesforce_id_idx ON ents USING btree (salesforce_id);


--
-- Name: ents_score_tmp; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX ents_score_tmp ON similar_ents_tmp USING btree (score);


SET default_tablespace = rpx_user_default;

--
-- Name: fki_pats_rupd_fk; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX fki_pats_rupd_fk ON pat_related_documents USING btree (pat_id);


--
-- Name: foreign_application_priority_docs__pat_id_document_id_uniq_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX foreign_application_priority_docs__pat_id_document_id_uniq_idx ON foreign_application_priority_docs USING btree (pat_id, document_id);


--
-- Name: idx_alias_contacts_alias_md5; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_alias_contacts_alias_md5 ON alias_contacts USING btree (alias_id, address_md5);


--
-- Name: idx_alias_contacts_lower_address; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_alias_contacts_lower_address ON alias_contacts USING btree (lower((((line1)::text || ' '::text) || (state_or_province)::text)));


--
-- Name: idx_alias_ent_detail_soft_ultimate_parent_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_alias_ent_detail_soft_ultimate_parent_id ON alias_ent_details USING btree (soft_ultimate_parent_id);


--
-- Name: idx_alias_ent_details_alias_created_at; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_alias_ent_details_alias_created_at ON alias_ent_details USING btree (alias_created_at);


--
-- Name: idx_alias_ent_details_alias_ent; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_alias_ent_details_alias_ent ON alias_ent_details USING btree (alias_id, ent_id);


SET default_tablespace = '';

--
-- Name: idx_alias_ent_details_alias_name; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX idx_alias_ent_details_alias_name ON alias_ent_details USING gin (alias_name public.gin_trgm_ops);


SET default_tablespace = rpx_user_default;

--
-- Name: idx_alias_ent_details_alias_roles; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_alias_ent_details_alias_roles ON alias_ent_details USING gin (alias_roles);


--
-- Name: idx_alias_ent_details_clean_anme; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_alias_ent_details_clean_anme ON alias_ent_details USING btree (clean_name);


--
-- Name: idx_alias_ent_details_ent_created_at; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_alias_ent_details_ent_created_at ON alias_ent_details USING btree (ent_created_at);


SET default_tablespace = '';

--
-- Name: idx_alias_ent_details_ent_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX idx_alias_ent_details_ent_id ON alias_ent_details USING btree (ent_id);


--
-- Name: idx_alias_ent_details_ent_name; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX idx_alias_ent_details_ent_name ON alias_ent_details USING gin (ent_name public.gin_trgm_ops);


SET default_tablespace = rpx_user_default;

--
-- Name: idx_alias_ent_details_ent_type_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_alias_ent_details_ent_type_id ON alias_ent_details USING btree (ent_type_id);


--
-- Name: idx_alias_ent_details_soft_ent_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_alias_ent_details_soft_ent_id ON alias_ent_details USING btree (soft_ent_id);


--
-- Name: idx_alias_ent_details_soft_ultimate_parent_name; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_alias_ent_details_soft_ultimate_parent_name ON alias_ent_details USING btree (soft_ultimate_parent_name);


--
-- Name: idx_alias_ent_details_true_is_patent_licensing_co; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_alias_ent_details_true_is_patent_licensing_co ON alias_ent_details USING btree (is_patent_licensing_co) WHERE is_patent_licensing_co;


--
-- Name: idx_alias_ent_details_true_npe; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_alias_ent_details_true_npe ON alias_ent_details USING btree (is_npe) WHERE is_npe;


SET default_tablespace = '';

--
-- Name: idx_alias_ent_details_ultimate_parent_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX idx_alias_ent_details_ultimate_parent_id ON alias_ent_details USING btree (ultimate_parent_id);


--
-- Name: idx_alias_ent_details_ultimate_parent_name; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX idx_alias_ent_details_ultimate_parent_name ON alias_ent_details USING gin (ultimate_parent_name public.gin_trgm_ops);


SET default_tablespace = rpx_user_default;

--
-- Name: idx_alias_ent_details_updated_at; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_alias_ent_details_updated_at ON alias_ent_details USING btree (updated_at);


--
-- Name: idx_alias_roles_name; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX idx_alias_roles_name ON alias_roles USING btree (name);


--
-- Name: idx_aliases_is_non_human; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_aliases_is_non_human ON aliases USING btree (code_nerd.is_non_human(name));


--
-- Name: idx_aliases_name_gin1; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_aliases_name_gin1 ON aliases USING gin (name public.gin_trgm_ops);


SET default_tablespace = '';

--
-- Name: idx_assignors_aliases_map_contact_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX idx_assignors_aliases_map_contact_id ON assignors_aliases_map USING btree (alias_contact_id);


--
-- Name: idx_core_aliases_lower_name; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX idx_core_aliases_lower_name ON aliases USING btree (lower((name)::text));


SET default_tablespace = rpx_user_default;

--
-- Name: idx_core_aliases_name; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_core_aliases_name ON aliases USING btree (name);


--
-- Name: idx_docket_entries_date_filed; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_docket_entries_date_filed ON docket_entries USING btree (date_filed);


--
-- Name: idx_ent_advanced_relationships_ent_advanced_relationship_type_i; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_ent_advanced_relationships_ent_advanced_relationship_type_i ON ent_advanced_relationships USING btree (ent_advanced_relationship_type_id);


--
-- Name: idx_ent_advanced_relationships_ent_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_ent_advanced_relationships_ent_id ON ent_advanced_relationships USING btree (ent_id);


--
-- Name: idx_ent_advanced_relationships_related_ent_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_ent_advanced_relationships_related_ent_id ON ent_advanced_relationships USING btree (related_ent_id);


--
-- Name: idx_ent_advanced_relationships_temporal_ent_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_ent_advanced_relationships_temporal_ent_id ON ent_advanced_relationships_temporal USING btree (ent_id);


--
-- Name: idx_ent_advanced_relationships_temporal_related_ent_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_ent_advanced_relationships_temporal_related_ent_id ON ent_advanced_relationships_temporal USING btree (related_ent_id);


--
-- Name: idx_ent_subtypes_map_ent_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_ent_subtypes_map_ent_id ON ent_subtypes_map USING btree (ent_id);


SET default_tablespace = '';

--
-- Name: idx_lit_case_stages_lit_stage; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX idx_lit_case_stages_lit_stage ON lit_case_stages USING btree (lit_id, lit_stage_id);


SET default_tablespace = rpx_user_default;

--
-- Name: idx_lit_documents_normalized_file_name; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_lit_documents_normalized_file_name ON lit_documents USING btree (regexp_replace((rpx_file_name)::text, '.*\/.*\/.*\/'::text, ''::text));


SET default_tablespace = '';

--
-- Name: idx_lit_parties_contact_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX idx_lit_parties_contact_id ON lit_parties USING btree (alias_contact_id);


SET default_tablespace = rpx_user_default;

--
-- Name: idx_lit_parties_representations_deleted_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_lit_parties_representations_deleted_id ON lit_parties_representations_deleted USING btree (id);


--
-- Name: idx_pat_assignments_conveyance; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_pat_assignments_conveyance ON pat_assignments USING btree (conveyance);


--
-- Name: idx_pat_claims_pat_claim_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_pat_claims_pat_claim_id ON pat_claims USING btree (id, pat_id);


--
-- Name: idx_pat_cpc_grant_pub_number_md5; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_pat_cpc_grant_pub_number_md5 ON pat_cpc USING btree (((grant_pub_number)::bigint), application_type, md5_pat_cpc);


--
-- Name: idx_pat_cpc_pat_section; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_pat_cpc_pat_section ON pat_cpc USING btree (pat_id, cpc_section);


--
-- Name: idx_pat_current_maint_code_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_pat_current_maint_code_id ON pat_current USING btree (maintenance_code_id);


--
-- Name: idx_pat_current_stripped_patnum; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_pat_current_stripped_patnum ON pat_current USING btree (stripped_patnum);


--
-- Name: idx_pat_family_pats_details_pat_family_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_pat_family_pats_details_pat_family_id ON pat_family_pats_details USING btree (pat_family_id);


--
-- Name: idx_pat_maintenance_code_code; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX idx_pat_maintenance_code_code ON pat_maintenance_code USING btree (code);


--
-- Name: idx_pat_orig_app_num_country_pat_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_pat_orig_app_num_country_pat_id ON pat_orig_app_num_country USING btree (pat_id);


--
-- Name: idx_pat_priority_claims_pat_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_pat_priority_claims_pat_id ON pat_priority_claims USING btree (pat_id);


--
-- Name: idx_pat_references__ref_patnum_pat; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_pat_references__ref_patnum_pat ON pat_references USING btree (ref_patnum, pat_id);


--
-- Name: idx_pat_references_ref_pat_uniq; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX idx_pat_references_ref_pat_uniq ON pat_references USING btree (ref_pat_id, pat_id);


SET default_tablespace = '';

--
-- Name: idx_pat_stats_all_assignees_alias_pat; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX idx_pat_stats_all_assignees_alias_pat ON pat_stats_all_assignees USING btree (alias_id, pat_id);


--
-- Name: idx_pat_stats_current_assignees_alias_pat; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX idx_pat_stats_current_assignees_alias_pat ON pat_stats_current_assignees USING btree (alias_id, pat_id);


SET default_tablespace = rpx_user_default;

--
-- Name: idx_pat_stats_current_assignors_pat_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_pat_stats_current_assignors_pat_id ON pat_stats_current_assignors USING btree (pat_id);


--
-- Name: idx_pat_stats_current_assignors_pat_stats_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_pat_stats_current_assignors_pat_stats_id ON pat_stats_current_assignors USING btree (pat_stats_id);


--
-- Name: idx_patent_owners_stripped_patnum; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_patent_owners_stripped_patnum ON patent_owners USING btree (stripped_patnum);


--
-- Name: idx_patnum; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_patnum ON pat_current USING btree (patnum);


SET default_tablespace = '';

--
-- Name: idx_pats_aliases_map_contact_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX idx_pats_aliases_map_contact_id ON pats_aliases_map USING btree (alias_contact_id);


SET default_tablespace = rpx_user_default;

--
-- Name: idx_pats_assignments_map_assingment_pat_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_pats_assignments_map_assingment_pat_id ON pats_assignments_map USING btree (pat_assignment_id, pat_id);


SET default_tablespace = '';

--
-- Name: idx_pats_intl_class; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX idx_pats_intl_class ON pats USING btree (intl_class);


SET default_tablespace = rpx_user_default;

--
-- Name: idx_pats_invention_app_num_country; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX idx_pats_invention_app_num_country ON pats_invention USING btree (app_num_country);


--
-- Name: idx_pats_invention_link_invention_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_pats_invention_link_invention_id ON pats_invention_link USING btree (invention_id);


--
-- Name: idx_pats_invention_link_pat_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX idx_pats_invention_link_pat_id ON pats_invention_link USING btree (pat_id);


--
-- Name: idx_pats_invention_link_pat_inv_current; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_pats_invention_link_pat_inv_current ON pats_invention_link USING btree (invention_id) WHERE (is_current = true);


--
-- Name: idx_pats_last_submission_pat_id1; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_pats_last_submission_pat_id1 ON pats USING btree (last_submission_pat_id);


--
-- Name: idx_pats_next_submission_pat_id1; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_pats_next_submission_pat_id1 ON pats USING btree (next_submission_pat_id);


--
-- Name: idx_pats_orig_app_num_country; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_pats_orig_app_num_country ON pats USING btree (orig_app_num_country);


SET default_tablespace = '';

--
-- Name: idx_pats_title_gin; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX idx_pats_title_gin ON pats USING gin (title public.gin_trgm_ops);


--
-- Name: idx_pats_withdrawn_stripped_patnum; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX idx_pats_withdrawn_stripped_patnum ON pats_withdrawn USING btree (stripped_patnum);


--
-- Name: idx_pssp_alias_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX idx_pssp_alias_id ON pat_stats_sponsoring_parties USING btree (alias_id);


SET default_tablespace = rpx_user_default;

--
-- Name: idx_uniq_current_assignees; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX idx_uniq_current_assignees ON pat_stats_current_assignees USING btree (pat_stats_id, alias_id);


--
-- Name: idx_uniq_sponsoring_parties; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX idx_uniq_sponsoring_parties ON pat_stats_sponsoring_parties USING btree (pat_stats_id, alias_id);


SET default_tablespace = '';

--
-- Name: idx_uspcs_subclasses_orig_code; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX idx_uspcs_subclasses_orig_code ON uspcs_subclasses USING btree (orig_code);


--
-- Name: idx_uspcs_subclasses_uspcs_class_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX idx_uspcs_subclasses_uspcs_class_id ON uspcs_subclasses USING btree (uspcs_class_id);


--
-- Name: index_lit_party_outcomes_on_docket_entry_reference; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX index_lit_party_outcomes_on_docket_entry_reference ON lit_party_outcomes USING btree (docket_entry_reference);


--
-- Name: index_users_on_email; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX index_users_on_email ON users USING btree (email);


--
-- Name: index_users_on_reset_password_token; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX index_users_on_reset_password_token ON users USING btree (reset_password_token);


--
-- Name: invention_owner_uniq_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX invention_owner_uniq_idx ON invention_owners USING btree (invention_id, owner);


--
-- Name: invention_owners_alias_ids_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX invention_owners_alias_ids_idx ON invention_owners USING gin (alias_ids public.gin__int_ops);


--
-- Name: invention_owners_invention_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX invention_owners_invention_id_idx ON invention_owners USING btree (invention_id);


SET default_tablespace = rpx_user_default;

--
-- Name: ipc_subgroups__created_at_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX ipc_subgroups__created_at_idx ON ipc_subgroups USING btree (created_at);


--
-- Name: ipc_subgroups__updated_at_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX ipc_subgroups__updated_at_idx ON ipc_subgroups USING btree (updated_at);


SET default_tablespace = '';

--
-- Name: judge_assignment_types_name_unique_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX judge_assignment_types_name_unique_idx ON judge_assignment_types USING btree (name);


--
-- Name: lawfirm_aliases_to_map_tmp_cluster_lawfirm_alias_ids_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lawfirm_aliases_to_map_tmp_cluster_lawfirm_alias_ids_idx ON lawfirm_aliases_to_map_tmp USING gin (cluster_lawfirm_alias_ids);


--
-- Name: lawfirm_maps_sim_score_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lawfirm_maps_sim_score_idx ON lawfirm_maps USING btree (sim_score);


SET default_tablespace = rpx_user_default;

--
-- Name: lit_annotations__lit_id_uniq_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX lit_annotations__lit_id_uniq_idx ON lit_annotations USING btree (lit_id);


SET default_tablespace = '';

--
-- Name: lit_annotations_fkey_lit_type_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lit_annotations_fkey_lit_type_id ON lit_annotations USING btree (lit_type_id);


--
-- Name: lit_annotations_fkey_market_sector_type_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lit_annotations_fkey_market_sector_type_id ON lit_annotations USING btree (market_sector_type_id);


--
-- Name: lit_case_key_unique_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX lit_case_key_unique_idx ON lits USING btree (case_key);


--
-- Name: lit_cause_types_name_unique_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX lit_cause_types_name_unique_idx ON lit_cause_types USING btree (name);


--
-- Name: lit_classification_types_name_unique_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX lit_classification_types_name_unique_idx ON lit_classification_types USING btree (name);


--
-- Name: lit_courts_fkey_alias_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lit_courts_fkey_alias_id ON lit_courts USING btree (alias_id);


--
-- Name: lit_courts_fkey_lit_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lit_courts_fkey_lit_id ON lit_courts USING btree (lit_id);


--
-- Name: lit_courts_skey; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX lit_courts_skey ON lit_courts USING btree (lit_id, alias_id);


--
-- Name: lit_curated_cause_types_name_unique_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX lit_curated_cause_types_name_unique_idx ON lit_curated_cause_types USING btree (name);


SET default_tablespace = rpx_user_default;

--
-- Name: lit_documents__url_uniq_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX lit_documents__url_uniq_idx ON lit_documents USING btree (url);


SET default_tablespace = '';

--
-- Name: lit_documents_created_at_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lit_documents_created_at_idx ON lit_documents USING btree (created_at);


--
-- Name: lit_documents_updated_at_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lit_documents_updated_at_idx ON lit_documents USING btree (updated_at);


--
-- Name: lit_judges_map_fkey_alias_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lit_judges_map_fkey_alias_id ON lit_judges_map USING btree (alias_id);


--
-- Name: lit_judges_map_fkey_lit_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lit_judges_map_fkey_lit_id ON lit_judges_map USING btree (lit_id);


--
-- Name: lit_judges_map_skey; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX lit_judges_map_skey ON lit_judges_map USING btree (alias_id, lit_id, assignment_type_id, start_date, assignment_role_as_filed);


SET default_tablespace = rpx_user_default;

--
-- Name: lit_parties__updated_at_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX lit_parties__updated_at_idx ON lit_parties USING btree (updated_at);


SET default_tablespace = '';

--
-- Name: lit_parties_fkey_alias_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lit_parties_fkey_alias_id ON lit_parties USING btree (alias_id);


--
-- Name: lit_parties_fkey_lit_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lit_parties_fkey_lit_id ON lit_parties USING btree (lit_id);


--
-- Name: lit_parties_fkey_lit_party_type_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lit_parties_fkey_lit_party_type_id ON lit_parties USING btree (lit_party_type_id);


--
-- Name: lit_parties_representations_fkey_lawfirm_alias_contact_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lit_parties_representations_fkey_lawfirm_alias_contact_id ON lit_parties_representations USING btree (lawfirm_alias_contact_id);


--
-- Name: lit_parties_representations_fkey_lawfirm_alias_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lit_parties_representations_fkey_lawfirm_alias_id ON lit_parties_representations USING btree (lawfirm_alias_id);


--
-- Name: lit_parties_representations_fkey_lawyer_alias_contact_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lit_parties_representations_fkey_lawyer_alias_contact_id ON lit_parties_representations USING btree (lawyer_alias_contact_id);


--
-- Name: lit_parties_representations_fkey_lawyer_alias_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lit_parties_representations_fkey_lawyer_alias_id ON lit_parties_representations USING btree (lawyer_alias_id);


--
-- Name: lit_parties_representations_skey; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lit_parties_representations_skey ON lit_parties_representations USING btree (lit_parties_id, lawyer_alias_id, lawfirm_alias_id);


--
-- Name: lit_party_types_name_unique_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX lit_party_types_name_unique_idx ON lit_party_types USING btree (name);


--
-- Name: lit_relationship_types_name_unique_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX lit_relationship_types_name_unique_idx ON lit_relationship_types USING btree (name);


SET default_tablespace = rpx_user_default;

--
-- Name: lit_relationships__from_lit_id_to_lit_id_uniq_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX lit_relationships__from_lit_id_to_lit_id_uniq_idx ON lit_relationships USING btree (from_lit_id, to_lit_id);


SET default_tablespace = '';

--
-- Name: lit_relationships_fkey_from_lit_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lit_relationships_fkey_from_lit_id ON lit_relationships USING btree (from_lit_id);


--
-- Name: lit_relationships_fkey_lit_relationship_type_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lit_relationships_fkey_lit_relationship_type_id ON lit_relationships USING btree (lit_relationship_type_id);


--
-- Name: lit_relationships_fkey_to_lit_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lit_relationships_fkey_to_lit_id ON lit_relationships USING btree (to_lit_id);


SET default_tablespace = rpx_user_default;

--
-- Name: lit_relationships_lit_family_id_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX lit_relationships_lit_family_id_idx ON lit_relationships USING btree (lit_family_id);


SET default_tablespace = '';

--
-- Name: lit_stages_name_unique_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX lit_stages_name_unique_idx ON lit_stages USING btree (name);


--
-- Name: lit_types_name_unique_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX lit_types_name_unique_idx ON lit_types USING btree (name);


--
-- Name: litigated_against_district_court_alias_id_gin_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX litigated_against_district_court_alias_id_gin_idx ON pat_ent_relationships USING gin (litigated_against_district_court_alias_ids public.gin__int_ops);


--
-- Name: litigated_against_district_court_alias_ids_gin_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX litigated_against_district_court_alias_ids_gin_idx ON pat_ent_relationships_tmp USING gin (litigated_against_district_court_alias_ids);


--
-- Name: litigated_against_district_court_ent_id_gin_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX litigated_against_district_court_ent_id_gin_idx ON pat_ent_relationships USING gin (litigated_against_district_court_ent_ids public.gin__int_ops);


--
-- Name: litigated_against_district_court_ent_ids_gin_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX litigated_against_district_court_ent_ids_gin_idx ON pat_ent_relationships_tmp USING gin (litigated_against_district_court_ent_ids);


--
-- Name: litigated_by_district_court_alias_id_gin_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX litigated_by_district_court_alias_id_gin_idx ON pat_ent_relationships USING gin (litigated_by_district_court_alias_ids public.gin__int_ops);


--
-- Name: litigated_by_district_court_alias_ids_gin_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX litigated_by_district_court_alias_ids_gin_idx ON pat_ent_relationships_tmp USING gin (litigated_by_district_court_alias_ids);


--
-- Name: litigated_by_district_court_ent_id_gin_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX litigated_by_district_court_ent_id_gin_idx ON pat_ent_relationships USING gin (litigated_by_district_court_ent_ids public.gin__int_ops);


--
-- Name: litigated_by_district_court_ent_ids_gin_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX litigated_by_district_court_ent_ids_gin_idx ON pat_ent_relationships_tmp USING gin (litigated_by_district_court_ent_ids);


SET default_tablespace = rpx_user_default;

--
-- Name: lits__created_at_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX lits__created_at_idx ON lits USING btree (created_at);


--
-- Name: lits__updated_at_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX lits__updated_at_idx ON lits USING btree (updated_at);


SET default_tablespace = '';

--
-- Name: lits_lower_title_gin_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lits_lower_title_gin_idx ON lits USING gin (title public.gin_trgm_ops);


SET default_tablespace = rpx_user_default;

--
-- Name: lits_pats_map__lit_id_patnum_uniq_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX lits_pats_map__lit_id_patnum_uniq_idx ON lits_pats_map USING btree (lit_id, patnum);


--
-- Name: lits_pats_map__patnum_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX lits_pats_map__patnum_idx ON lits_pats_map USING btree (patnum);


SET default_tablespace = '';

--
-- Name: lits_pats_map_fkey_lit_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lits_pats_map_fkey_lit_id ON lits_pats_map USING btree (lit_id);


--
-- Name: lits_pats_other_lit_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lits_pats_other_lit_id_idx ON lits_pats_other USING btree (lit_id);


--
-- Name: lits_pats_other_lit_id_pat_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX lits_pats_other_lit_id_pat_id_idx ON lits_pats_other USING btree (lit_id, pat_id);


--
-- Name: lits_pats_other_pat_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lits_pats_other_pat_id_idx ON lits_pats_other USING btree (pat_id);


--
-- Name: lits_pats_other_stripped_patnum_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX lits_pats_other_stripped_patnum_idx ON lits_pats_other USING btree (stripped_patnum);


--
-- Name: market_sector_types_name_unique_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX market_sector_types_name_unique_idx ON market_sector_types USING btree (name);


--
-- Name: msg_queue_type_id_pri_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX msg_queue_type_id_pri_idx ON msg_queue USING btree (msg_type, msg_id, priority);


--
-- Name: original_assignee_alias_id_gin_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX original_assignee_alias_id_gin_idx ON pat_ent_relationships USING gin (original_assignee_alias_ids public.gin__int_ops);


--
-- Name: original_assignee_alias_ids_gin_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX original_assignee_alias_ids_gin_idx ON pat_ent_relationships_tmp USING gin (original_assignee_alias_ids);


--
-- Name: original_assignee_ent_id_gin_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX original_assignee_ent_id_gin_idx ON pat_ent_relationships USING gin (original_assignee_ent_ids public.gin__int_ops);


--
-- Name: original_assignee_ent_ids_gin_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX original_assignee_ent_ids_gin_idx ON pat_ent_relationships_tmp USING gin (original_assignee_ent_ids);


--
-- Name: pat_abstracts_pat_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX pat_abstracts_pat_id_idx ON pat_abstracts USING btree (pat_id);


SET default_tablespace = rpx_user_default;

--
-- Name: pat_assignments__created_at_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX pat_assignments__created_at_idx ON pat_assignments USING btree (created_at);


--
-- Name: pat_assignments__reel_number_frame_number_id_uniq_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX pat_assignments__reel_number_frame_number_id_uniq_idx ON pat_assignments USING btree (reel_number, frame_number, id);


--
-- Name: pat_assignments__updated_at_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX pat_assignments__updated_at_idx ON pat_assignments USING btree (updated_at);


SET default_tablespace = '';

--
-- Name: pat_assignments_fkey_correspondent_alias_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pat_assignments_fkey_correspondent_alias_id ON pat_assignments USING btree (correspondent_alias_id);


--
-- Name: pat_assignments_pr_logic_version; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pat_assignments_pr_logic_version ON pat_assignments USING btree (primary_conveyance_logic_version);


--
-- Name: pat_assignments_sec_logic_version; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pat_assignments_sec_logic_version ON pat_assignments USING btree (secondary_conveyance_logic_version);


--
-- Name: pat_claim_relationships_fkey_pat_claims_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pat_claim_relationships_fkey_pat_claims_id ON pat_claim_relationships USING btree (pat_claims_id);


--
-- Name: pat_claims_fkey_pat_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pat_claims_fkey_pat_id ON pat_claims USING btree (pat_id);


--
-- Name: pat_claims_pat_id_claim_num_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pat_claims_pat_id_claim_num_idx ON pat_claims USING btree (pat_id, claim_num);


--
-- Name: pat_claims_s3_loaded_to_s3_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pat_claims_s3_loaded_to_s3_idx ON pat_claims_s3 USING btree (loaded_to_s3);


--
-- Name: pat_claims_s3_pat_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX pat_claims_s3_pat_id_idx ON pat_claims_s3 USING btree (pat_id);


SET default_tablespace = rpx_user_default;

--
-- Name: pat_cross_ref_classes__pat_id_cross_ref_element_uniq_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX pat_cross_ref_classes__pat_id_cross_ref_element_uniq_idx ON pat_cross_ref_classes USING btree (pat_id, cross_ref_element);


--
-- Name: pat_current_pat_id_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX pat_current_pat_id_idx ON pat_current USING btree (pat_id);


SET default_tablespace = '';

--
-- Name: pat_descriptions_pat_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX pat_descriptions_pat_id_idx ON pat_descriptions USING btree (pat_id);


--
-- Name: pat_ent_relationships_pat_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX pat_ent_relationships_pat_id_idx ON pat_ent_relationships_tmp USING btree (pat_id);


--
-- Name: pat_ent_relationships_pat_ids_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX pat_ent_relationships_pat_ids_idx ON pat_ent_relationships USING btree (pat_id);


--
-- Name: pat_family_pats_details_idx_tmp; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pat_family_pats_details_idx_tmp ON pat_family_pats_details USING btree (pat_id);


SET default_tablespace = rpx_user_default;

--
-- Name: pat_ipc_classes__pat_id__name_uniq_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX pat_ipc_classes__pat_id__name_uniq_idx ON pat_ipc_classes USING btree (pat_id, name);


--
-- Name: pat_maintenance_fee_events_fkey_pat_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX pat_maintenance_fee_events_fkey_pat_id ON pat_maintenance_fee_events USING btree (pat_id);


--
-- Name: pat_maintenance_fee_events_fkey_pat_maint_fee_event_type_id; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX pat_maintenance_fee_events_fkey_pat_maint_fee_event_type_id ON pat_maintenance_fee_events USING btree (pat_maintenance_fee_event_type_id);


SET default_tablespace = '';

--
-- Name: pat_other_references_fkey_pat_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pat_other_references_fkey_pat_id ON pat_other_references USING btree (pat_id);


--
-- Name: pat_secondary_conveyance_ix1; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pat_secondary_conveyance_ix1 ON pat_secondary_conveyance USING btree (pat_assignment_id);


SET default_tablespace = rpx_user_default;

--
-- Name: pat_stats__patnum_kind_country_uniq_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX pat_stats__patnum_kind_country_uniq_idx ON pat_stats USING btree (stripped_patnum, doc_kind_code, country_code);


SET default_tablespace = '';

--
-- Name: pat_stats_all_assignees_pat_id_alias_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX pat_stats_all_assignees_pat_id_alias_id_idx ON pat_stats_all_assignees USING btree (pat_id, alias_id);


--
-- Name: pat_stats_all_assignees_pat_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pat_stats_all_assignees_pat_id_idx ON pat_stats_all_assignees USING btree (pat_id);


SET default_tablespace = rpx_user_default;

--
-- Name: pat_stats_current_assignees__pat_stats_id_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX pat_stats_current_assignees__pat_stats_id_idx ON pat_stats_current_assignees USING btree (pat_stats_id);


SET default_tablespace = '';

--
-- Name: pat_stats_current_assignees_pat_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pat_stats_current_assignees_pat_id_idx ON pat_stats_current_assignees USING btree (pat_id);


--
-- Name: pat_stats_inventors_alias_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pat_stats_inventors_alias_id_idx ON pat_stats_inventors USING btree (alias_id);


--
-- Name: pat_stats_inventors_pat_id_alias_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX pat_stats_inventors_pat_id_alias_id_idx ON pat_stats_inventors USING btree (pat_id, alias_id);


--
-- Name: pat_stats_inventors_pat_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pat_stats_inventors_pat_id_idx ON pat_stats_inventors USING btree (pat_id);


--
-- Name: pat_stats_pat_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pat_stats_pat_id_idx ON pat_stats USING btree (pat_id);


SET default_tablespace = rpx_user_default;

--
-- Name: pat_stats_sponsoring_parties__pat_stats_id_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX pat_stats_sponsoring_parties__pat_stats_id_idx ON pat_stats_sponsoring_parties USING btree (pat_stats_id);


SET default_tablespace = '';

--
-- Name: pat_stats_sponsoring_parties_pat_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pat_stats_sponsoring_parties_pat_id_idx ON pat_stats_sponsoring_parties USING btree (pat_id);


--
-- Name: pat_stats_stripped_patnum_country_code_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX pat_stats_stripped_patnum_country_code_idx ON pat_stats USING btree (stripped_patnum, country_code);


SET default_tablespace = rpx_user_default;

--
-- Name: patent_owners_pat_id_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX patent_owners_pat_id_idx ON patent_owners USING btree (pat_id);


--
-- Name: patent_owners_pat_id_owner_alias_id_start_date_end_date_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX patent_owners_pat_id_owner_alias_id_start_date_end_date_idx ON patent_owners USING btree (pat_id, owner_alias_id, start_date, end_date);


SET default_tablespace = '';

--
-- Name: pats__app_num_country_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pats__app_num_country_idx ON pats USING btree (app_num_country);


SET default_tablespace = rpx_user_default;

--
-- Name: pats__created_at_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX pats__created_at_idx ON pats USING btree (created_at);


--
-- Name: pats__is_application_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX pats__is_application_idx ON pats USING btree (is_application);


SET default_tablespace = '';

--
-- Name: pats__patnum_unique_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX pats__patnum_unique_idx ON pats USING btree (patnum);


--
-- Name: pats__salesforce_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pats__salesforce_id_idx ON pats USING btree (salesforce_id);


SET default_tablespace = rpx_user_default;

--
-- Name: pats__stripped_patnum_doc_kind_code_unique_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX pats__stripped_patnum_doc_kind_code_unique_idx ON pats USING btree (stripped_patnum, doc_kind_code);


--
-- Name: pats__updated_at_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX pats__updated_at_idx ON pats USING btree (updated_at);


SET default_tablespace = '';

--
-- Name: pats_aliases_map__pat_id_alias_id_pats_aliases_relationship_typ; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX pats_aliases_map__pat_id_alias_id_pats_aliases_relationship_typ ON pats_aliases_map USING btree (pat_id, alias_id, pats_aliases_relationship_type_id);


--
-- Name: pats_aliases_map_fkey_alias_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pats_aliases_map_fkey_alias_id ON pats_aliases_map USING btree (alias_id);


--
-- Name: pats_aliases_map_fkey_pat_id; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pats_aliases_map_fkey_pat_id ON pats_aliases_map USING btree (pat_id);


--
-- Name: pats_assignments_map__invention_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pats_assignments_map__invention_id_idx ON pats_assignments_map USING btree (invention_id);


--
-- Name: pats_assignments_map__pat_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pats_assignments_map__pat_id_idx ON pats_assignments_map USING btree (pat_id);


--
-- Name: pats_assignments_map__patnum_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pats_assignments_map__patnum_idx ON pats_assignments_map USING btree (patnum);


--
-- Name: pats_assignments_map__stripped_patnum_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pats_assignments_map__stripped_patnum_idx ON pats_assignments_map USING btree (stripped_patnum);


--
-- Name: pats_field_of_search_created_at_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pats_field_of_search_created_at_idx ON pats_field_of_search USING btree (created_at);


--
-- Name: pats_field_of_search_updated_at_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pats_field_of_search_updated_at_idx ON pats_field_of_search USING btree (updated_at);


--
-- Name: pats_stripped_patnum_country_code_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pats_stripped_patnum_country_code_idx ON pats USING btree (stripped_patnum, country_code);


--
-- Name: pats_stripped_patnum_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX pats_stripped_patnum_idx ON pats USING gin (stripped_patnum public.gin_trgm_ops);


--
-- Name: primary_conveyance_type_id_idx; Type: INDEX; Schema: core; Owner: -
--

CREATE INDEX primary_conveyance_type_id_idx ON pat_assignments USING btree (primary_conveyance_type_id);


--
-- Name: uidx_ipc_classes_code; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX uidx_ipc_classes_code ON ipc_classes USING btree (code);


--
-- Name: uidx_ipc_groups_code; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX uidx_ipc_groups_code ON ipc_groups USING btree (code);


--
-- Name: uidx_ipc_sections_code; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX uidx_ipc_sections_code ON ipc_sections USING btree (code);


--
-- Name: uidx_ipc_subclasses_code; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX uidx_ipc_subclasses_code ON ipc_subclasses USING btree (code);


--
-- Name: uidx_ipc_subgroups_code; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX uidx_ipc_subgroups_code ON ipc_subgroups USING btree (code);


--
-- Name: uidx_uspcs_classes_code; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX uidx_uspcs_classes_code ON uspcs_classes USING btree (code);


--
-- Name: uidx_uspcs_subclasses_code; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX uidx_uspcs_subclasses_code ON uspcs_subclasses USING btree (code);


--
-- Name: unique_schema_migrations; Type: INDEX; Schema: core; Owner: -
--

CREATE UNIQUE INDEX unique_schema_migrations ON schema_migrations USING btree (version);


SET default_tablespace = rpx_user_default;

--
-- Name: uspcs_subclasses__created_at_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX uspcs_subclasses__created_at_idx ON uspcs_subclasses USING btree (created_at);


--
-- Name: uspcs_subclasses__updated_at_idx; Type: INDEX; Schema: core; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX uspcs_subclasses__updated_at_idx ON uspcs_subclasses USING btree (updated_at);


SET search_path = docdb, pg_catalog;

--
-- Name: docdb.docdb_priority_claims_doc_number_idx; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX "docdb.docdb_priority_claims_doc_number_idx" ON docdb_priority_claims USING btree (doc_number);


--
-- Name: docdb_abstracts_fkey_pat_id; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX docdb_abstracts_fkey_pat_id ON docdb_abstracts USING btree (pat_id);


--
-- Name: docdb_applicants_fkey_pat_id; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX docdb_applicants_fkey_pat_id ON docdb_applicants USING btree (pat_id);


--
-- Name: docdb_citations_fkey_pat_id; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX docdb_citations_fkey_pat_id ON docdb_citations USING btree (pat_id);


--
-- Name: docdb_classifications_fkey_pat_id; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX docdb_classifications_fkey_pat_id ON docdb_classifications USING btree (pat_id);


--
-- Name: docdb_inventors_fkey_pat_id; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX docdb_inventors_fkey_pat_id ON docdb_inventors USING btree (pat_id);


--
-- Name: docdb_national_classifications_fkey_pat_id; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX docdb_national_classifications_fkey_pat_id ON docdb_national_classifications USING btree (pat_id);


--
-- Name: docdb_pats__created_at_idx; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX docdb_pats__created_at_idx ON docdb_pats USING btree (created_at);


--
-- Name: docdb_pats__updated_at_idx; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX docdb_pats__updated_at_idx ON docdb_pats USING btree (updated_at);


--
-- Name: docdb_pats_app_num_country_idx; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX docdb_pats_app_num_country_idx ON docdb_pats USING btree (app_num_intl, app_num_country);


--
-- Name: docdb_pats_lower_idx; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX docdb_pats_lower_idx ON docdb_pats USING btree (lower((patnum)::text) varchar_pattern_ops);


--
-- Name: docdb_pats_pat_family_processed_idx; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX docdb_pats_pat_family_processed_idx ON docdb_pats USING btree (pat_family_processed);


--
-- Name: docdb_pats_patnum_idx; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX docdb_pats_patnum_idx ON docdb_pats USING btree (patnum);


SET default_tablespace = '';

--
-- Name: docdb_pats_patnum_idx1; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX docdb_pats_patnum_idx1 ON docdb_pats USING gin (patnum public.gin_trgm_ops);


SET default_tablespace = rpx_user_default;

--
-- Name: docdb_pats_stripped_patnum_country_idx; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX docdb_pats_stripped_patnum_country_idx ON docdb_pats USING btree (stripped_patnum, country_code);


--
-- Name: docdb_priority_claims_fkey_pat_id; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX docdb_priority_claims_fkey_pat_id ON docdb_priority_claims USING btree (pat_id);


--
-- Name: docdb_titles_fkey_pat_id; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX docdb_titles_fkey_pat_id ON docdb_titles USING btree (pat_id);


--
-- Name: idx_docdb_ipcs_pat_id; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_docdb_ipcs_pat_id ON docdb_ipcs USING btree (pat_id);


--
-- Name: idx_docdb_pats_family_id; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_docdb_pats_family_id ON docdb_pats USING btree (family_id);


--
-- Name: idx_docdb_pats_revision_history_pat_id; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_docdb_pats_revision_history_pat_id ON docdb_pats_revision_history USING btree (pat_id);


--
-- Name: idx_pat_normalized_family_relationships_core_pat_id; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_pat_normalized_family_relationships_core_pat_id ON pat_normalized_family_relationships USING btree (core_pat_id);


--
-- Name: idx_pat_normalized_family_relationships_family_id; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_pat_normalized_family_relationships_family_id ON pat_normalized_family_relationships USING btree (pat_family_id);


--
-- Name: idx_pat_normalized_family_relationships_invention_id; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_pat_normalized_family_relationships_invention_id ON pat_normalized_family_relationships USING btree (invention_id);


--
-- Name: idx_pat_normalized_family_relationships_related_core_pat_id; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_pat_normalized_family_relationships_related_core_pat_id ON pat_normalized_family_relationships USING btree (related_core_pat_id);


--
-- Name: idx_pat_normalized_family_relationships_uniq; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX idx_pat_normalized_family_relationships_uniq ON pat_normalized_family_relationships USING btree (docdb_pat_id, related_docdb_pat_id, relationship_type);


SET default_tablespace = '';

--
-- Name: log_data_201609_created_app_run_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201609_created_app_run_idx ON log_data_201609 USING btree (app_id, run_id);


--
-- Name: log_data_201609_created_at_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201609_created_at_idx ON log_data_201609 USING btree (created_at);


--
-- Name: log_data_201610_created_app_run_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201610_created_app_run_idx ON log_data_201610 USING btree (app_id, run_id);


--
-- Name: log_data_201610_created_at_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201610_created_at_idx ON log_data_201610 USING btree (created_at);


--
-- Name: log_data_201611_created_app_run_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201611_created_app_run_idx ON log_data_201611 USING btree (app_id, run_id);


--
-- Name: log_data_201611_created_at_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201611_created_at_idx ON log_data_201611 USING btree (created_at);


--
-- Name: log_data_201612_created_app_run_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201612_created_app_run_idx ON log_data_201612 USING btree (app_id, run_id);


--
-- Name: log_data_201612_created_at_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201612_created_at_idx ON log_data_201612 USING btree (created_at);


--
-- Name: log_data_201701_created_app_run_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201701_created_app_run_idx ON log_data_201701 USING btree (app_id, run_id);


--
-- Name: log_data_201701_created_at_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201701_created_at_idx ON log_data_201701 USING btree (created_at);


--
-- Name: log_data_201702_created_app_run_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201702_created_app_run_idx ON log_data_201702 USING btree (app_id, run_id);


--
-- Name: log_data_201702_created_at_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201702_created_at_idx ON log_data_201702 USING btree (created_at);


--
-- Name: log_data_201703_created_app_run_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201703_created_app_run_idx ON log_data_201703 USING btree (app_id, run_id);


--
-- Name: log_data_201703_created_at_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201703_created_at_idx ON log_data_201703 USING btree (created_at);


--
-- Name: log_data_201704_created_app_run_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201704_created_app_run_idx ON log_data_201704 USING btree (app_id, run_id);


--
-- Name: log_data_201704_created_at_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201704_created_at_idx ON log_data_201704 USING btree (created_at);


--
-- Name: log_data_201705_created_app_run_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201705_created_app_run_idx ON log_data_201705 USING btree (app_id, run_id);


--
-- Name: log_data_201705_created_at_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201705_created_at_idx ON log_data_201705 USING btree (created_at);


--
-- Name: log_data_201706_created_app_run_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201706_created_app_run_idx ON log_data_201706 USING btree (app_id, run_id);


--
-- Name: log_data_201706_created_at_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201706_created_at_idx ON log_data_201706 USING btree (created_at);


--
-- Name: log_data_201707_created_app_run_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201707_created_app_run_idx ON log_data_201707 USING btree (app_id, run_id);


--
-- Name: log_data_201707_created_at_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201707_created_at_idx ON log_data_201707 USING btree (created_at);


--
-- Name: log_data_201708_created_app_run_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201708_created_app_run_idx ON log_data_201708 USING btree (app_id, run_id);


--
-- Name: log_data_201708_created_at_idx; Type: INDEX; Schema: docdb; Owner: -
--

CREATE INDEX log_data_201708_created_at_idx ON log_data_201708 USING btree (created_at);


SET default_tablespace = rpx_user_default;

--
-- Name: log_data__app_id__run_id_idx; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX log_data__app_id__run_id_idx ON log_data USING btree (app_id, run_id);


--
-- Name: log_data__app_name_idx; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX log_data__app_name_idx ON log_data USING btree (app_name);


--
-- Name: log_data__log_level_id__created_at_idx; Type: INDEX; Schema: docdb; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX log_data__log_level_id__created_at_idx ON log_data USING btree (log_level_id, created_at);


SET search_path = ptab, pg_catalog;

SET default_tablespace = '';

--
-- Name: idx_ptab_case_stripped_patnum_country; Type: INDEX; Schema: ptab; Owner: -
--

CREATE INDEX idx_ptab_case_stripped_patnum_country ON ptab_cases USING btree (stripped_patnum, country_code);


SET default_tablespace = rpx_user_default;

--
-- Name: idx_ptab_cases_case_num; Type: INDEX; Schema: ptab; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_ptab_cases_case_num ON ptab_cases USING btree (case_num);


--
-- Name: idx_ptab_parties_alias_and_type; Type: INDEX; Schema: ptab; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX idx_ptab_parties_alias_and_type ON ptab_parties USING btree (alias_id, ptab_party_type_id);


SET default_tablespace = '';

--
-- Name: ptab_case_details_ptab_case_id_idx; Type: INDEX; Schema: ptab; Owner: -
--

CREATE INDEX ptab_case_details_ptab_case_id_idx ON ptab_case_details USING btree (ptab_case_id);


SET default_tablespace = rpx_user_default;

--
-- Name: ptab_cases__created_at_idx; Type: INDEX; Schema: ptab; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX ptab_cases__created_at_idx ON ptab_cases USING btree (created_at);


--
-- Name: ptab_cases__updated_at_idx; Type: INDEX; Schema: ptab; Owner: -; Tablespace: rpx_user_default
--

CREATE INDEX ptab_cases__updated_at_idx ON ptab_cases USING btree (updated_at);


--
-- Name: ptab_parties_id_unique_idx; Type: INDEX; Schema: ptab; Owner: -; Tablespace: rpx_user_default
--

CREATE UNIQUE INDEX ptab_parties_id_unique_idx ON ptab_parties USING btree (ptab_case_id, alias_id, ptab_party_type_id);


SET search_path = public, pg_catalog;

SET default_tablespace = '';

--
-- Name: unique_schema_migrations; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX unique_schema_migrations ON schema_migrations USING btree (version);


SET search_path = ptab, pg_catalog;

--
-- Name: ipr_vw _RETURN; Type: RULE; Schema: ptab; Owner: -
--

CREATE RULE "_RETURN" AS
    ON SELECT TO ipr_vw DO INSTEAD  SELECT (ipr.stripped_patnum)::character varying(255) AS stripped_patnum,
    pats.patnum AS full_patnum,
    pats.country_code,
    pats.id AS pat_id,
    pfp.pat_family_id AS patent_family_id,
    (ipr.case_num)::character varying(255) AS case_number,
    (case_types.case_type_desc)::character varying(255) AS review_type,
    ipr.filing_date,
    ipr.institution_decision_date AS institution_date,
        CASE
            WHEN (ipr.institution_decision_date IS NULL) THEN 0
            ELSE 1
        END AS go_no_go,
    (ipr.application_num)::character varying(255) AS application_num,
    (a1.name)::character varying(255) AS petitioner_entry_name,
    e1.id AS petitioner_ent_id,
    e1.name AS petitioner_ent_name,
    ultp.name AS petitioner_ult_parent,
    sfpet.typex AS petitioner_ult_parent_sf_type,
        CASE
            WHEN (npes1.core_ent_id IS NULL) THEN 0
            ELSE 1
        END AS petitioner_npe_check,
    (a2.name)::character varying(255) AS patent_owner_name,
    e2.id AS patent_owner_ent_id,
    e2.name AS patent_owner_ent_name,
    ultpo.name AS patent_owner_ult_parent,
    sfpo.typex AS patent_owner_ult_parent_owner_sf_type,
        CASE
            WHEN (npes2.core_ent_id IS NULL) THEN 0
            ELSE 1
        END AS patent_owner_npe_check,
    (ipr.status)::character varying(255) AS status,
    (ipr.tech_center)::character varying(255) AS tech_center,
    pats.us_class_current,
    pats.field_of_search,
    array_agg(DISTINCT cpat.campaign_id) AS campaign_id,
    array_agg(DISTINCT camps.campaign_name) AS campaign_names
   FROM (((((((((((((((((ptab_cases ipr
     LEFT JOIN ptab_parties petitioner ON (((ipr.id = petitioner.ptab_case_id) AND (petitioner.ptab_party_type_id = 1))))
     LEFT JOIN ptab_parties patent_owner ON (((ipr.id = patent_owner.ptab_case_id) AND (patent_owner.ptab_party_type_id = 2))))
     LEFT JOIN ptab_case_types case_types ON ((ipr.ptab_case_type_id = case_types.id)))
     LEFT JOIN core.aliases a1 ON ((a1.id = petitioner.alias_id)))
     LEFT JOIN core.ents e1 ON ((e1.id = a1.ent_id)))
     LEFT JOIN core.ents ultp ON ((ultp.id = e1.ultimate_parent_id)))
     LEFT JOIN sf.accountx sfpet ON ((sfpet.entity_id__c = (ultp.id)::numeric)))
     LEFT JOIN core.aliases a2 ON ((a2.id = patent_owner.alias_id)))
     LEFT JOIN core.ents e2 ON ((e2.id = a2.ent_id)))
     LEFT JOIN core.ents ultpo ON ((ultpo.id = e2.ultimate_parent_id)))
     LEFT JOIN sf.accountx sfpo ON ((sfpo.entity_id__c = (ultpo.id)::numeric)))
     LEFT JOIN ( SELECT esm.ent_id AS core_ent_id
           FROM (core.ent_subtypes_map esm
             JOIN core.ent_subtypes es ON (((esm.ent_subtype_id = es.id) AND ((es.name)::text = 'NPE'::text) AND ((now() >= COALESCE(esm.start_date, '1970-01-01'::date)) AND (now() <= COALESCE(esm.end_date, '9999-12-31'::date))))))) npes1 ON ((npes1.core_ent_id = e1.id)))
     LEFT JOIN ( SELECT esm.ent_id AS core_ent_id
           FROM (core.ent_subtypes_map esm
             JOIN core.ent_subtypes es ON (((esm.ent_subtype_id = es.id) AND ((es.name)::text = 'NPE'::text) AND ((now() >= COALESCE(esm.start_date, '1970-01-01'::date)) AND (now() <= COALESCE(esm.end_date, '9999-12-31'::date))))))) npes2 ON ((npes2.core_ent_id = e2.id)))
     LEFT JOIN core.pats pats ON (((pats.stripped_patnum)::text = (ipr.stripped_patnum)::text)))
     LEFT JOIN docdb_families.pat_family_pats pfp ON ((((pfp.stripped_patnum)::text = (pats.stripped_patnum)::text) AND ((pfp.country_code)::text = 'US'::text))))
     LEFT JOIN lit_campaigns.campaign_patents cpat ON (((cpat.stripped_patnum)::text = (ipr.stripped_patnum)::text)))
     LEFT JOIN ( SELECT DISTINCT pname.campaign_id,
            (((pname.name)::text || ' '::text) || pnum.patent) AS campaign_name
           FROM (( SELECT DISTINCT ON (cam.campaign_id) cam.campaign_id,
                    ents.name
                   FROM ((((core.lits lits
                     JOIN core.lit_parties party ON ((party.lit_id = lits.id)))
                     JOIN lit_campaigns.campaign_lits cam ON ((cam.lit_id = lits.id)))
                     JOIN core.aliases aliases ON ((aliases.id = party.alias_id)))
                     JOIN core.ents ents ON ((ents.id = aliases.ent_id)))
                  WHERE (party.lit_party_type_id = ANY (ARRAY[75, 82, 98, 99, 121, 125, 132, 146, 151, 174]))
                  GROUP BY cam.campaign_id, ents.name) pname
             JOIN ( SELECT cam1.campaign_id,
                    min((lmap.patnum)::text) AS patent
                   FROM (lit_campaigns.campaign_lits cam1
                     JOIN core.lits_pats_map lmap ON ((lmap.lit_id = cam1.lit_id)))
                  GROUP BY cam1.campaign_id) pnum ON ((pnum.campaign_id = pname.campaign_id)))) camps ON ((camps.campaign_id = cpat.campaign_id)))
  GROUP BY ipr.stripped_patnum, pats.patnum, pats.id, pfp.pat_family_id, ipr.case_num, case_types.case_type_desc, ipr.filing_date, ipr.institution_decision_date,
        CASE
            WHEN (ipr.institution_decision_date IS NULL) THEN 0
            ELSE 1
        END, ipr.application_num, a1.name, e1.id, e1.name, ultp.name, sfpet.typex,
        CASE
            WHEN (npes1.core_ent_id IS NULL) THEN 0
            ELSE 1
        END, a2.name, e2.id, e2.name, ultpo.name, sfpo.typex,
        CASE
            WHEN (npes2.core_ent_id IS NULL) THEN 0
            ELSE 1
        END, ipr.status, ipr.tech_center, pats.us_class_current, pats.field_of_search;


--
-- Name: v_ptab_details _RETURN; Type: RULE; Schema: ptab; Owner: -
--

CREATE RULE "_RETURN" AS
    ON SELECT TO v_ptab_details DO INSTEAD  SELECT ipr.id AS ptab_case_id,
    (ipr.stripped_patnum)::character varying(255) AS stripped_patnum,
    pats.patnum AS full_patnum,
    pats.country_code,
    pats.id AS pat_id,
    pfp.pat_family_id AS patent_family_id,
    (ipr.case_num)::character varying(255) AS case_number,
    (case_types.case_type_desc)::character varying(255) AS review_type,
    ipr.filing_date,
    ipr.institution_decision_date AS institution_date,
        CASE
            WHEN (ipr.institution_decision_date IS NULL) THEN 0
            ELSE 1
        END AS go_no_go,
    (ipr.application_num)::character varying(255) AS application_num,
    (a1.name)::character varying(255) AS petitioner_alias_name,
    a1.id AS petitioner_alias_id,
    e1.id AS petitioner_ent_id,
    e1.name AS petitioner_ent_name,
    ultp.name AS petitioner_ult_parent_name,
    ultp.id AS petitioner_ult_parent_id,
    sfpet.typex AS petitioner_ult_parent_sf_type,
        CASE
            WHEN (npes1.core_ent_id IS NULL) THEN 0
            ELSE 1
        END AS petitioner_ent_npe_check,
    (a2.name)::character varying(255) AS patent_owner_alias_name,
    a2.id AS patent_owner_alias_id,
    e2.id AS patent_owner_ent_id,
    e2.name AS patent_owner_ent_name,
    ultpo.name AS patent_owner_ult_parent_name,
    ultpo.id AS patent_owner_ult_parent_id,
    sfpo.typex AS patent_owner_ult_parent_owner_sf_type,
        CASE
            WHEN (npes2.core_ent_id IS NULL) THEN 0
            ELSE 1
        END AS patent_owner_ent_npe_check,
    (ipr.status)::character varying(255) AS status,
    (ipr.tech_center)::character varying(255) AS tech_center,
    pats.us_class_current,
    pats.field_of_search,
    array_agg(DISTINCT cpat.campaign_id) AS campaign_id,
    array_agg(DISTINCT camps.campaign_name) AS campaign_names
   FROM (((((((((((((((((ptab_cases ipr
     LEFT JOIN ptab_parties petitioner ON (((petitioner.is_primary = true) AND (ipr.id = petitioner.ptab_case_id) AND (petitioner.ptab_party_type_id = 1))))
     LEFT JOIN ptab_parties patent_owner ON (((patent_owner.is_primary = true) AND (ipr.id = patent_owner.ptab_case_id) AND (patent_owner.ptab_party_type_id = 2))))
     LEFT JOIN ptab_case_types case_types ON ((ipr.ptab_case_type_id = case_types.id)))
     LEFT JOIN core.aliases a1 ON ((a1.id = petitioner.alias_id)))
     LEFT JOIN core.ents e1 ON ((e1.id = a1.ent_id)))
     LEFT JOIN core.ents ultp ON ((ultp.id = e1.ultimate_parent_id)))
     LEFT JOIN sf.accountx sfpet ON ((sfpet.entity_id__c = (ultp.id)::numeric)))
     LEFT JOIN core.aliases a2 ON ((a2.id = patent_owner.alias_id)))
     LEFT JOIN core.ents e2 ON ((e2.id = a2.ent_id)))
     LEFT JOIN core.ents ultpo ON ((ultpo.id = e2.ultimate_parent_id)))
     LEFT JOIN sf.accountx sfpo ON ((sfpo.entity_id__c = (ultpo.id)::numeric)))
     LEFT JOIN ( SELECT esm.ent_id AS core_ent_id
           FROM (core.ent_subtypes_map esm
             JOIN core.ent_subtypes es ON (((esm.ent_subtype_id = es.id) AND ((es.name)::text = 'NPE'::text) AND ((now() >= COALESCE(esm.start_date, '1970-01-01'::date)) AND (now() <= COALESCE(esm.end_date, '9999-12-31'::date))))))) npes1 ON ((npes1.core_ent_id = e1.id)))
     LEFT JOIN ( SELECT esm.ent_id AS core_ent_id
           FROM (core.ent_subtypes_map esm
             JOIN core.ent_subtypes es ON (((esm.ent_subtype_id = es.id) AND ((es.name)::text = 'NPE'::text) AND ((now() >= COALESCE(esm.start_date, '1970-01-01'::date)) AND (now() <= COALESCE(esm.end_date, '9999-12-31'::date))))))) npes2 ON ((npes2.core_ent_id = e2.id)))
     LEFT JOIN core.pats pats ON (((pats.stripped_patnum)::text = (ipr.stripped_patnum)::text)))
     LEFT JOIN docdb_families.pat_family_pats pfp ON ((((pfp.stripped_patnum)::text = (pats.stripped_patnum)::text) AND ((pfp.country_code)::text = 'US'::text))))
     LEFT JOIN lit_campaigns.campaign_patents cpat ON (((cpat.stripped_patnum)::text = (ipr.stripped_patnum)::text)))
     LEFT JOIN ( SELECT DISTINCT pname.campaign_id,
            (((pname.name)::text || ' '::text) || pnum.patent) AS campaign_name
           FROM (( SELECT DISTINCT ON (cam.campaign_id) cam.campaign_id,
                    ents.name
                   FROM ((((core.lits lits
                     JOIN core.lit_parties party ON ((party.lit_id = lits.id)))
                     JOIN lit_campaigns.campaign_lits cam ON ((cam.lit_id = lits.id)))
                     JOIN core.aliases aliases ON ((aliases.id = party.alias_id)))
                     JOIN core.ents ents ON ((ents.id = aliases.ent_id)))
                  WHERE (party.lit_party_type_id = ANY (ARRAY[75, 82, 98, 99, 121, 125, 132, 146, 151, 174]))
                  GROUP BY cam.campaign_id, ents.name) pname
             JOIN ( SELECT cam1.campaign_id,
                    min((lmap.patnum)::text) AS patent
                   FROM (lit_campaigns.campaign_lits cam1
                     JOIN core.lits_pats_map lmap ON ((lmap.lit_id = cam1.lit_id)))
                  GROUP BY cam1.campaign_id) pnum ON ((pnum.campaign_id = pname.campaign_id)))) camps ON ((camps.campaign_id = cpat.campaign_id)))
  GROUP BY ipr.id, ipr.stripped_patnum, pats.patnum, pats.id, pfp.pat_family_id, ipr.case_num, case_types.case_type_desc, ipr.filing_date, ipr.institution_decision_date,
        CASE
            WHEN (ipr.institution_decision_date IS NULL) THEN 0
            ELSE 1
        END, ipr.application_num, a1.name, a1.id, e1.id, e1.name, ultp.name, ultp.id, sfpet.typex,
        CASE
            WHEN (npes1.core_ent_id IS NULL) THEN 0
            ELSE 1
        END, a2.name, a2.id, e2.id, e2.name, ultpo.name, ultpo.id, sfpo.typex,
        CASE
            WHEN (npes2.core_ent_id IS NULL) THEN 0
            ELSE 1
        END, ipr.status, ipr.tech_center, pats.us_class_current, pats.field_of_search
  ORDER BY ipr.filing_date;


SET search_path = acquiflow, pg_catalog;

--
-- Name: acquisition_agreements acquisition_agreements_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER acquisition_agreements_audit BEFORE INSERT OR DELETE OR UPDATE ON acquisition_agreements FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.acquisition_agreements_aud_tr_func();


--
-- Name: acquisition_encumbrances acquisition_encumbrances_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER acquisition_encumbrances_audit BEFORE INSERT OR DELETE OR UPDATE ON acquisition_encumbrances FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.acquisition_encumbrances_aud_tr_func();


--
-- Name: acquisition_options acquisition_options_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER acquisition_options_audit BEFORE INSERT OR DELETE OR UPDATE ON acquisition_options FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.acquisition_options_aud_tr_func();


--
-- Name: acquisition_patent_attributes acquisition_patent_attributes_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER acquisition_patent_attributes_audit BEFORE INSERT OR DELETE OR UPDATE ON acquisition_patent_attributes FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.acquisition_patent_attributes_aud_tr_func();


--
-- Name: acquisition_patent_attributes_dcl acquisition_patent_attributes_dcl_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER acquisition_patent_attributes_dcl_audit BEFORE INSERT OR DELETE OR UPDATE ON acquisition_patent_attributes_dcl FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.acquisition_patent_attributes_dcl_aud_tr_func();


--
-- Name: acquisition_patents acquisition_patents_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER acquisition_patents_audit BEFORE INSERT OR DELETE OR UPDATE ON acquisition_patents FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.acquisition_patents_aud_tr_func();


--
-- Name: acquisition_patents_dcl acquisition_patents_dcl_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER acquisition_patents_dcl_audit BEFORE INSERT OR DELETE OR UPDATE ON acquisition_patents_dcl FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.acquisition_patents_dcl_aud_tr_func();


--
-- Name: acquisition_restrictions acquisition_restrictions_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER acquisition_restrictions_audit BEFORE INSERT OR DELETE OR UPDATE ON acquisition_restrictions FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.acquisition_restrictions_aud_tr_func();


--
-- Name: acquisition_syndications acquisition_syndications_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER acquisition_syndications_audit BEFORE INSERT OR DELETE OR UPDATE ON acquisition_syndications FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.acquisition_syndications_aud_tr_func();


--
-- Name: acquisition_types acquisition_types_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER acquisition_types_audit BEFORE INSERT OR DELETE OR UPDATE ON acquisition_types FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.acquisition_types_aud_tr_func();


--
-- Name: acquisitions acquisitions_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER acquisitions_audit BEFORE INSERT OR DELETE OR UPDATE ON acquisitions FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.acquisitions_aud_tr_func();


--
-- Name: agreement_terms agreement_terms_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER agreement_terms_audit BEFORE INSERT OR DELETE OR UPDATE ON agreement_terms FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.agreement_terms_aud_tr_func();


--
-- Name: agreement_types agreement_types_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER agreement_types_audit BEFORE INSERT OR DELETE OR UPDATE ON agreement_types FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.agreement_types_aud_tr_func();


--
-- Name: asset_inventory_cpi asset_inventory_cpi_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER asset_inventory_cpi_audit BEFORE INSERT OR DELETE OR UPDATE ON asset_inventory_cpi FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.asset_inventory_cpi_aud_tr_func();


--
-- Name: asset_status_types asset_status_types_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER asset_status_types_audit BEFORE INSERT OR DELETE OR UPDATE ON asset_status_types FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.asset_status_types_aud_tr_func();


--
-- Name: batch_generated_option_ents batch_generated_option_ents_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER batch_generated_option_ents_audit BEFORE INSERT OR DELETE OR UPDATE ON batch_generated_option_ents FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.batch_generated_option_ents_aud_tr_func();


--
-- Name: case_types case_types_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER case_types_audit BEFORE INSERT OR DELETE OR UPDATE ON case_types FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.case_types_aud_tr_func();


--
-- Name: cpi_only_assets cpi_only_assets_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER cpi_only_assets_audit BEFORE INSERT OR DELETE OR UPDATE ON cpi_only_assets FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.cpi_only_assets_aud_tr_func();


--
-- Name: cpi_tracking_status cpi_tracking_status_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER cpi_tracking_status_audit BEFORE INSERT OR DELETE OR UPDATE ON cpi_tracking_status FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.cpi_tracking_status_aud_tr_func();


--
-- Name: encumbrance_types encumbrance_types_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER encumbrance_types_audit BEFORE INSERT OR DELETE OR UPDATE ON encumbrance_types FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.encumbrance_types_aud_tr_func();


--
-- Name: manual_assets manual_assets_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER manual_assets_audit BEFORE INSERT OR DELETE OR UPDATE ON manual_assets FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.manual_assets_aud_tr_func();


--
-- Name: option_types option_types_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER option_types_audit BEFORE INSERT OR DELETE OR UPDATE ON option_types FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.option_types_aud_tr_func();


--
-- Name: portfolios portfolios_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER portfolios_audit BEFORE INSERT OR DELETE OR UPDATE ON portfolios FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.portfolios_aud_tr_func();


--
-- Name: restriction_types restriction_types_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER restriction_types_audit BEFORE INSERT OR DELETE OR UPDATE ON restriction_types FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.restriction_types_aud_tr_func();


--
-- Name: rpx_cpi_asset_tracking_log rpx_cpi_asset_tracking_log_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER rpx_cpi_asset_tracking_log_audit BEFORE INSERT OR DELETE OR UPDATE ON rpx_cpi_asset_tracking_log FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.rpx_cpi_asset_tracking_log_aud_tr_func();


--
-- Name: rpx_ownership_rights rpx_ownership_rights_audit; Type: TRIGGER; Schema: acquiflow; Owner: -
--

CREATE TRIGGER rpx_ownership_rights_audit BEFORE INSERT OR DELETE OR UPDATE ON rpx_ownership_rights FOR EACH ROW EXECUTE PROCEDURE acquiflow_audit.rpx_ownership_rights_aud_tr_func();


SET search_path = core, pg_catalog;

--
-- Name: alias_contacts alias_contacts_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER alias_contacts_audit BEFORE INSERT OR DELETE OR UPDATE ON alias_contacts FOR EACH ROW EXECUTE PROCEDURE core_audit.alias_contacts_aud_tr_func();


--
-- Name: alias_contacts alias_contacts_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER alias_contacts_insert_timestamps BEFORE INSERT ON alias_contacts FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE alias_contacts DISABLE TRIGGER alias_contacts_insert_timestamps;


--
-- Name: alias_contacts alias_contacts_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER alias_contacts_update_timestamp BEFORE UPDATE ON alias_contacts FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE alias_contacts DISABLE TRIGGER alias_contacts_update_timestamp;


--
-- Name: alias_ent_details alias_ent_details_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER alias_ent_details_audit BEFORE INSERT OR DELETE OR UPDATE ON alias_ent_details FOR EACH ROW EXECUTE PROCEDURE core_audit.alias_ent_details_aud_tr_func();


--
-- Name: aliases aliases_alias_ent_details_trig; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER aliases_alias_ent_details_trig BEFORE INSERT OR DELETE OR UPDATE ON aliases FOR EACH ROW EXECUTE PROCEDURE aliases_alias_ent_details_trig_func();


--
-- Name: aliases aliases_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER aliases_audit BEFORE INSERT OR DELETE OR UPDATE ON aliases FOR EACH ROW EXECUTE PROCEDURE core_audit.aliases_aud_tr_func();


--
-- Name: aliases aliases_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER aliases_insert_timestamps BEFORE INSERT ON aliases FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE aliases DISABLE TRIGGER aliases_insert_timestamps;


--
-- Name: aliases aliases_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER aliases_update_timestamp BEFORE UPDATE ON aliases FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE aliases DISABLE TRIGGER aliases_update_timestamp;


--
-- Name: assignees_aliases_map assignees_aliases_map_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER assignees_aliases_map_audit BEFORE INSERT OR DELETE OR UPDATE ON assignees_aliases_map FOR EACH ROW EXECUTE PROCEDURE core_audit.assignees_aliases_map_aud_tr_func();


--
-- Name: assignees_aliases_map assignees_aliases_map_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER assignees_aliases_map_insert_timestamps BEFORE INSERT ON assignees_aliases_map FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE assignees_aliases_map DISABLE TRIGGER assignees_aliases_map_insert_timestamps;


--
-- Name: assignees_aliases_map assignees_aliases_map_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER assignees_aliases_map_update_timestamp BEFORE UPDATE ON assignees_aliases_map FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE assignees_aliases_map DISABLE TRIGGER assignees_aliases_map_update_timestamp;


--
-- Name: assignors_aliases_map assignors_aliases_map_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER assignors_aliases_map_audit BEFORE INSERT OR DELETE OR UPDATE ON assignors_aliases_map FOR EACH ROW EXECUTE PROCEDURE core_audit.assignors_aliases_map_aud_tr_func();


--
-- Name: assignors_aliases_map assignors_aliases_map_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER assignors_aliases_map_insert_timestamps BEFORE INSERT ON assignors_aliases_map FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE assignors_aliases_map DISABLE TRIGGER assignors_aliases_map_insert_timestamps;


--
-- Name: assignors_aliases_map assignors_aliases_map_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER assignors_aliases_map_update_timestamp BEFORE UPDATE ON assignors_aliases_map FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE assignors_aliases_map DISABLE TRIGGER assignors_aliases_map_update_timestamp;


--
-- Name: alias_contacts core_alias_contacts_md5_trigger; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER core_alias_contacts_md5_trigger BEFORE INSERT ON alias_contacts FOR EACH ROW EXECUTE PROCEDURE alias_contacts_md5_trig_func();


--
-- Name: court_details court_details_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER court_details_audit BEFORE INSERT OR DELETE OR UPDATE ON court_details FOR EACH ROW EXECUTE PROCEDURE core_audit.court_details_aud_tr_func();


--
-- Name: court_details court_details_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER court_details_insert_timestamps BEFORE INSERT ON court_details FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE court_details DISABLE TRIGGER court_details_insert_timestamps;


--
-- Name: court_details court_details_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER court_details_update_timestamp BEFORE UPDATE ON court_details FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE court_details DISABLE TRIGGER court_details_update_timestamp;


--
-- Name: lit_courts district_court_court_alias_role_trig; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER district_court_court_alias_role_trig AFTER INSERT OR DELETE OR UPDATE ON lit_courts FOR EACH ROW EXECUTE PROCEDURE district_court_court_alias_role_trig_func();


--
-- Name: lit_judges_map district_court_judge_alias_role_trig; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER district_court_judge_alias_role_trig AFTER INSERT OR DELETE OR UPDATE ON lit_judges_map FOR EACH ROW EXECUTE PROCEDURE district_court_judge_alias_role_trig_func();


--
-- Name: lit_parties_representations district_court_lawfirm_alias_role_trig; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER district_court_lawfirm_alias_role_trig AFTER INSERT OR DELETE OR UPDATE ON lit_parties_representations FOR EACH ROW EXECUTE PROCEDURE district_court_lawfirm_alias_role_trig_func();


--
-- Name: lit_parties_representations district_court_lawyer_alias_role_trig; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER district_court_lawyer_alias_role_trig AFTER INSERT OR DELETE OR UPDATE ON lit_parties_representations FOR EACH ROW EXECUTE PROCEDURE district_court_lawyer_alias_role_trig_func();


--
-- Name: lit_parties district_court_party_alias_role_trig; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER district_court_party_alias_role_trig AFTER INSERT OR DELETE OR UPDATE ON lit_parties FOR EACH ROW EXECUTE PROCEDURE district_court_party_alias_role_trig_func();


--
-- Name: dma_lit_annotations dma_lit_annotations_all_before_trig; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER dma_lit_annotations_all_before_trig BEFORE INSERT OR DELETE OR UPDATE ON dma_lit_annotations FOR EACH ROW EXECUTE PROCEDURE dma_lit_annotations_before_tr();


--
-- Name: dma_lit_annotations dma_lit_annotations_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER dma_lit_annotations_audit BEFORE INSERT OR DELETE OR UPDATE ON dma_lit_annotations FOR EACH ROW EXECUTE PROCEDURE core_audit.dma_lit_annotations_aud_tr_func();


--
-- Name: dma_lits_pats_map dma_lits_pats_map_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER dma_lits_pats_map_audit BEFORE INSERT OR DELETE OR UPDATE ON dma_lits_pats_map FOR EACH ROW EXECUTE PROCEDURE core_audit.dma_lits_pats_map_aud_tr_func();


--
-- Name: docket_entries docket_entries_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER docket_entries_audit BEFORE INSERT OR DELETE OR UPDATE ON docket_entries FOR EACH ROW EXECUTE PROCEDURE core_audit.docket_entries_aud_tr_func();


--
-- Name: docket_entries docket_entries_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER docket_entries_insert_timestamps BEFORE INSERT ON docket_entries FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE docket_entries DISABLE TRIGGER docket_entries_insert_timestamps;


--
-- Name: docket_entries docket_entries_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER docket_entries_update_timestamp BEFORE UPDATE ON docket_entries FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE docket_entries DISABLE TRIGGER docket_entries_update_timestamp;


--
-- Name: docket_entry_documents_map docket_entry_documents_map_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER docket_entry_documents_map_audit BEFORE INSERT OR DELETE OR UPDATE ON docket_entry_documents_map FOR EACH ROW EXECUTE PROCEDURE core_audit.docket_entry_documents_map_aud_tr_func();


--
-- Name: docket_entry_documents_map docket_entry_documents_map_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER docket_entry_documents_map_insert_timestamps BEFORE INSERT ON docket_entry_documents_map FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: docket_entry_documents_map docket_entry_documents_map_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER docket_entry_documents_map_update_timestamp BEFORE UPDATE ON docket_entry_documents_map FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: ent_advanced_relationship_types ent_advanced_relationship_types_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_advanced_relationship_types_audit BEFORE INSERT OR DELETE OR UPDATE ON ent_advanced_relationship_types FOR EACH ROW EXECUTE PROCEDURE core_audit.ent_advanced_relationship_types_aud_tr_func();


--
-- Name: ent_advanced_relationship_types ent_advanced_relationship_types_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_advanced_relationship_types_insert_timestamps BEFORE INSERT ON ent_advanced_relationship_types FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: ent_advanced_relationship_types ent_advanced_relationship_types_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_advanced_relationship_types_update_timestamp BEFORE UPDATE ON ent_advanced_relationship_types FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: ent_advanced_relationships ent_advanced_relationships_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_advanced_relationships_audit BEFORE INSERT OR DELETE OR UPDATE ON ent_advanced_relationships FOR EACH ROW EXECUTE PROCEDURE core_audit.ent_advanced_relationships_aud_tr_func();


--
-- Name: ent_advanced_relationships ent_advanced_relationships_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_advanced_relationships_insert_timestamps BEFORE INSERT ON ent_advanced_relationships FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: ent_advanced_relationships ent_advanced_relationships_insert_users; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_advanced_relationships_insert_users BEFORE INSERT ON ent_advanced_relationships FOR EACH ROW EXECUTE PROCEDURE insert_users();

ALTER TABLE ent_advanced_relationships DISABLE TRIGGER ent_advanced_relationships_insert_users;


--
-- Name: ent_advanced_relationships_temporal ent_advanced_relationships_temporal_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_advanced_relationships_temporal_audit BEFORE INSERT OR DELETE OR UPDATE ON ent_advanced_relationships_temporal FOR EACH ROW EXECUTE PROCEDURE core_audit.ent_advanced_relationships_temporal_aud_tr_func();


--
-- Name: ent_advanced_relationships_temporal ent_advanced_relationships_temporal_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_advanced_relationships_temporal_insert_timestamps BEFORE INSERT ON ent_advanced_relationships_temporal FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: ent_advanced_relationships_temporal ent_advanced_relationships_temporal_insert_users; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_advanced_relationships_temporal_insert_users BEFORE INSERT ON ent_advanced_relationships_temporal FOR EACH ROW EXECUTE PROCEDURE insert_users();


--
-- Name: ent_advanced_relationships_temporal ent_advanced_relationships_temporal_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_advanced_relationships_temporal_update_timestamp BEFORE UPDATE ON ent_advanced_relationships_temporal FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: ent_advanced_relationships_temporal ent_advanced_relationships_temporal_update_user; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_advanced_relationships_temporal_update_user BEFORE UPDATE ON ent_advanced_relationships_temporal FOR EACH ROW EXECUTE PROCEDURE update_user();


--
-- Name: ent_advanced_relationships ent_advanced_relationships_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_advanced_relationships_update_timestamp BEFORE UPDATE ON ent_advanced_relationships FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: ent_advanced_relationships ent_advanced_relationships_update_updated_by; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_advanced_relationships_update_updated_by BEFORE UPDATE OF updated_by ON ent_advanced_relationships FOR EACH ROW EXECUTE PROCEDURE update_updated_by();


--
-- Name: ent_advanced_relationships ent_advanced_relationships_update_user; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_advanced_relationships_update_user BEFORE UPDATE ON ent_advanced_relationships FOR EACH ROW EXECUTE PROCEDURE update_user();

ALTER TABLE ent_advanced_relationships DISABLE TRIGGER ent_advanced_relationships_update_user;


--
-- Name: ent_relationship_types ent_relationship_types_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_relationship_types_audit BEFORE INSERT OR DELETE OR UPDATE ON ent_relationship_types FOR EACH ROW EXECUTE PROCEDURE core_audit.ent_relationship_types_aud_tr_func();


--
-- Name: ent_relationship_types ent_relationship_types_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_relationship_types_insert_timestamps BEFORE INSERT ON ent_relationship_types FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE ent_relationship_types DISABLE TRIGGER ent_relationship_types_insert_timestamps;


--
-- Name: ent_relationship_types ent_relationship_types_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_relationship_types_update_timestamp BEFORE UPDATE ON ent_relationship_types FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE ent_relationship_types DISABLE TRIGGER ent_relationship_types_update_timestamp;


--
-- Name: ent_relationships ent_relationships_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_relationships_audit BEFORE INSERT OR DELETE OR UPDATE ON ent_relationships FOR EACH ROW EXECUTE PROCEDURE core_audit.ent_relationships_aud_tr_func();


--
-- Name: ent_relationships ent_relationships_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_relationships_insert_timestamps BEFORE INSERT ON ent_relationships FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE ent_relationships DISABLE TRIGGER ent_relationships_insert_timestamps;


--
-- Name: ent_relationships_temporal ent_relationships_temporal_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_relationships_temporal_audit BEFORE INSERT OR DELETE OR UPDATE ON ent_relationships_temporal FOR EACH ROW EXECUTE PROCEDURE core_audit.ent_relationships_temporal_aud_tr_func();


--
-- Name: ent_relationships ent_relationships_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_relationships_update_timestamp BEFORE UPDATE ON ent_relationships FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE ent_relationships DISABLE TRIGGER ent_relationships_update_timestamp;


--
-- Name: ent_subtypes ent_subtypes_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_subtypes_audit BEFORE INSERT OR DELETE OR UPDATE ON ent_subtypes FOR EACH ROW EXECUTE PROCEDURE core_audit.ent_subtypes_aud_tr_func();


--
-- Name: ent_subtypes ent_subtypes_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_subtypes_insert_timestamps BEFORE INSERT ON ent_subtypes FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: ent_subtypes_map ent_subtypes_map_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_subtypes_map_audit BEFORE INSERT OR DELETE OR UPDATE ON ent_subtypes_map FOR EACH ROW EXECUTE PROCEDURE core_audit.ent_subtypes_map_aud_tr_func();


--
-- Name: ent_subtypes_map ent_subtypes_map_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_subtypes_map_insert_timestamps BEFORE INSERT ON ent_subtypes_map FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: ent_subtypes_map ent_subtypes_map_insert_users; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_subtypes_map_insert_users BEFORE INSERT ON ent_subtypes_map FOR EACH ROW EXECUTE PROCEDURE insert_users();


--
-- Name: ent_subtypes_map ent_subtypes_map_update_alias_ent_details_boolean_flds; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_subtypes_map_update_alias_ent_details_boolean_flds BEFORE INSERT OR UPDATE ON ent_subtypes_map FOR EACH ROW EXECUTE PROCEDURE ent_subtypes_map_update_alias_ent_details_boolean_flds_tr_func();


--
-- Name: ent_subtypes_map ent_subtypes_map_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_subtypes_map_update_timestamp BEFORE UPDATE ON ent_subtypes_map FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: ent_subtypes_map ent_subtypes_map_update_updated_by; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_subtypes_map_update_updated_by BEFORE UPDATE OF updated_by ON ent_subtypes_map FOR EACH ROW EXECUTE PROCEDURE update_updated_by();


--
-- Name: ent_subtypes_map ent_subtypes_map_update_user; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_subtypes_map_update_user BEFORE UPDATE ON ent_subtypes_map FOR EACH ROW EXECUTE PROCEDURE update_user();


--
-- Name: ent_subtypes ent_subtypes_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_subtypes_update_timestamp BEFORE UPDATE ON ent_subtypes FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: ent_types ent_types_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_types_audit BEFORE INSERT OR DELETE OR UPDATE ON ent_types FOR EACH ROW EXECUTE PROCEDURE core_audit.ent_types_aud_tr_func();


--
-- Name: ent_types ent_types_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_types_insert_timestamps BEFORE INSERT ON ent_types FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE ent_types DISABLE TRIGGER ent_types_insert_timestamps;


--
-- Name: ent_types ent_types_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ent_types_update_timestamp BEFORE UPDATE ON ent_types FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE ent_types DISABLE TRIGGER ent_types_update_timestamp;


--
-- Name: entity_contacts entity_contacts_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER entity_contacts_audit BEFORE INSERT OR DELETE OR UPDATE ON entity_contacts FOR EACH ROW EXECUTE PROCEDURE core_audit.entity_contacts_aud_tr_func();


--
-- Name: entity_contacts entity_contacts_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER entity_contacts_insert_timestamps BEFORE INSERT ON entity_contacts FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: entity_contacts entity_contacts_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER entity_contacts_update_timestamp BEFORE UPDATE ON entity_contacts FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: ents ents_alias_ent_details_trig; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ents_alias_ent_details_trig BEFORE INSERT OR DELETE OR UPDATE ON ents FOR EACH ROW EXECUTE PROCEDURE ents_alias_ent_details_trig_func();


--
-- Name: ents ents_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ents_audit BEFORE INSERT OR DELETE OR UPDATE ON ents FOR EACH ROW EXECUTE PROCEDURE core_audit.ents_aud_tr_func();


--
-- Name: ents ents_default_parent; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ents_default_parent AFTER INSERT ON ents FOR EACH ROW EXECUTE PROCEDURE ents_default_parent_tr();


--
-- Name: ents ents_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ents_insert_timestamps BEFORE INSERT ON ents FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE ents DISABLE TRIGGER ents_insert_timestamps;


--
-- Name: ents_market_sector_types ents_market_sector_types_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ents_market_sector_types_audit BEFORE INSERT OR DELETE OR UPDATE ON ents_market_sector_types FOR EACH ROW EXECUTE PROCEDURE core_audit.ents_market_sector_types_aud_tr_func();


--
-- Name: ents_market_sector_types ents_market_sector_types_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ents_market_sector_types_insert_timestamps BEFORE INSERT ON ents_market_sector_types FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE ents_market_sector_types DISABLE TRIGGER ents_market_sector_types_insert_timestamps;


--
-- Name: ents_market_sector_types ents_market_sector_types_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ents_market_sector_types_update_timestamp BEFORE UPDATE ON ents_market_sector_types FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE ents_market_sector_types DISABLE TRIGGER ents_market_sector_types_update_timestamp;


--
-- Name: ents ents_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ents_update_timestamp BEFORE UPDATE ON ents FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE ents DISABLE TRIGGER ents_update_timestamp;


--
-- Name: file_types file_types_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER file_types_audit BEFORE INSERT OR DELETE OR UPDATE ON file_types FOR EACH ROW EXECUTE PROCEDURE core_audit.file_types_aud_tr_func();


--
-- Name: foreign_application_priority_docs foreign_application_priority_docs_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER foreign_application_priority_docs_audit BEFORE INSERT OR DELETE OR UPDATE ON foreign_application_priority_docs FOR EACH ROW EXECUTE PROCEDURE core_audit.foreign_application_priority_docs_aud_tr_func();


--
-- Name: foreign_application_priority_docs foreign_application_priority_docs_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER foreign_application_priority_docs_insert_timestamps BEFORE INSERT ON foreign_application_priority_docs FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: foreign_application_priority_docs foreign_application_priority_docs_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER foreign_application_priority_docs_update_timestamp BEFORE UPDATE ON foreign_application_priority_docs FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: invention_owners invention_owners_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER invention_owners_audit BEFORE INSERT OR DELETE OR UPDATE ON invention_owners FOR EACH ROW EXECUTE PROCEDURE core_audit.invention_owners_aud_tr_func();


--
-- Name: ipc_classes ipc_classes_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ipc_classes_audit BEFORE INSERT OR DELETE OR UPDATE ON ipc_classes FOR EACH ROW EXECUTE PROCEDURE core_audit.ipc_classes_aud_tr_func();


--
-- Name: ipc_groups ipc_groups_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ipc_groups_audit BEFORE INSERT OR DELETE OR UPDATE ON ipc_groups FOR EACH ROW EXECUTE PROCEDURE core_audit.ipc_groups_aud_tr_func();


--
-- Name: ipc_sections ipc_sections_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ipc_sections_audit BEFORE INSERT OR DELETE OR UPDATE ON ipc_sections FOR EACH ROW EXECUTE PROCEDURE core_audit.ipc_sections_aud_tr_func();


--
-- Name: ipc_subclasses ipc_subclasses_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ipc_subclasses_audit BEFORE INSERT OR DELETE OR UPDATE ON ipc_subclasses FOR EACH ROW EXECUTE PROCEDURE core_audit.ipc_subclasses_aud_tr_func();


--
-- Name: ipc_subgroups ipc_subgroups_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ipc_subgroups_audit BEFORE INSERT OR DELETE OR UPDATE ON ipc_subgroups FOR EACH ROW EXECUTE PROCEDURE core_audit.ipc_subgroups_aud_tr_func();


--
-- Name: lit_annotations is_dj_update_lit_parties; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER is_dj_update_lit_parties AFTER INSERT OR DELETE OR UPDATE OF is_dj ON lit_annotations FOR EACH ROW EXECUTE PROCEDURE lit_annotation_is_dj_update_lit_parties_tr_func();


--
-- Name: lits is_lits_original_filed_date; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER is_lits_original_filed_date BEFORE INSERT OR UPDATE ON lits FOR EACH ROW EXECUTE PROCEDURE lits_orig_filed_date_tr();


--
-- Name: judge_assignment_types judge_assignment_types_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER judge_assignment_types_audit BEFORE INSERT OR DELETE OR UPDATE ON judge_assignment_types FOR EACH ROW EXECUTE PROCEDURE core_audit.judge_assignment_types_aud_tr_func();


--
-- Name: judge_assignment_types judge_assignment_types_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER judge_assignment_types_insert_timestamps BEFORE INSERT ON judge_assignment_types FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE judge_assignment_types DISABLE TRIGGER judge_assignment_types_insert_timestamps;


--
-- Name: judge_assignment_types judge_assignment_types_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER judge_assignment_types_update_timestamp BEFORE UPDATE ON judge_assignment_types FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE judge_assignment_types DISABLE TRIGGER judge_assignment_types_update_timestamp;


--
-- Name: lit_annotations la_portal_display_trigger; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER la_portal_display_trigger BEFORE INSERT OR UPDATE ON lit_annotations FOR EACH ROW EXECUTE PROCEDURE lit_annotations_portal_display_func();


--
-- Name: lit_annotations lit_annotations_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_annotations_audit BEFORE INSERT OR DELETE OR UPDATE ON lit_annotations FOR EACH ROW EXECUTE PROCEDURE core_audit.lit_annotations_aud_tr_func();


--
-- Name: lit_annotations lit_annotations_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_annotations_insert_timestamps BEFORE INSERT ON lit_annotations FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE lit_annotations DISABLE TRIGGER lit_annotations_insert_timestamps;


--
-- Name: lit_annotations lit_annotations_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_annotations_update_timestamp BEFORE UPDATE ON lit_annotations FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE lit_annotations DISABLE TRIGGER lit_annotations_update_timestamp;


--
-- Name: lit_case_stages lit_case_stages_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_case_stages_audit BEFORE INSERT OR DELETE OR UPDATE ON lit_case_stages FOR EACH ROW EXECUTE PROCEDURE core_audit.lit_case_stages_aud_tr_func();


--
-- Name: lit_cause_types lit_cause_types_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_cause_types_audit BEFORE INSERT OR DELETE OR UPDATE ON lit_cause_types FOR EACH ROW EXECUTE PROCEDURE core_audit.lit_cause_types_aud_tr_func();


--
-- Name: lit_cause_types lit_cause_types_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_cause_types_insert_timestamps BEFORE INSERT ON lit_cause_types FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE lit_cause_types DISABLE TRIGGER lit_cause_types_insert_timestamps;


--
-- Name: lit_cause_types lit_cause_types_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_cause_types_update_timestamp BEFORE UPDATE ON lit_cause_types FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE lit_cause_types DISABLE TRIGGER lit_cause_types_update_timestamp;


--
-- Name: lit_classification_types lit_classification_types_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_classification_types_audit BEFORE INSERT OR DELETE OR UPDATE ON lit_classification_types FOR EACH ROW EXECUTE PROCEDURE core_audit.lit_classification_types_aud_tr_func();


--
-- Name: lit_classification_types lit_classification_types_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_classification_types_insert_timestamps BEFORE INSERT ON lit_classification_types FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE lit_classification_types DISABLE TRIGGER lit_classification_types_insert_timestamps;


--
-- Name: lit_classification_types lit_classification_types_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_classification_types_update_timestamp BEFORE UPDATE ON lit_classification_types FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE lit_classification_types DISABLE TRIGGER lit_classification_types_update_timestamp;


--
-- Name: lit_courts lit_courts_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_courts_audit BEFORE INSERT OR DELETE OR UPDATE ON lit_courts FOR EACH ROW EXECUTE PROCEDURE core_audit.lit_courts_aud_tr_func();


--
-- Name: lit_courts lit_courts_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_courts_insert_timestamps BEFORE INSERT ON lit_courts FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE lit_courts DISABLE TRIGGER lit_courts_insert_timestamps;


--
-- Name: lit_courts lit_courts_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_courts_update_timestamp BEFORE UPDATE ON lit_courts FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE lit_courts DISABLE TRIGGER lit_courts_update_timestamp;


--
-- Name: lit_curated_cause_types lit_curated_cause_types_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_curated_cause_types_audit BEFORE INSERT OR DELETE OR UPDATE ON lit_curated_cause_types FOR EACH ROW EXECUTE PROCEDURE core_audit.lit_curated_cause_types_aud_tr_func();


--
-- Name: lit_curated_cause_types lit_curated_cause_types_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_curated_cause_types_insert_timestamps BEFORE INSERT ON lit_curated_cause_types FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE lit_curated_cause_types DISABLE TRIGGER lit_curated_cause_types_insert_timestamps;


--
-- Name: lit_curated_cause_types lit_curated_cause_types_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_curated_cause_types_update_timestamp BEFORE UPDATE ON lit_curated_cause_types FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE lit_curated_cause_types DISABLE TRIGGER lit_curated_cause_types_update_timestamp;


--
-- Name: lit_document_orphans lit_document_orphans_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_document_orphans_audit BEFORE INSERT OR DELETE OR UPDATE ON lit_document_orphans FOR EACH ROW EXECUTE PROCEDURE core_audit.lit_document_orphans_aud_tr_func();


--
-- Name: lit_document_orphans lit_document_orphans_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_document_orphans_insert_timestamps BEFORE INSERT ON lit_document_orphans FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: lit_document_orphans lit_document_orphans_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_document_orphans_update_timestamp BEFORE UPDATE ON lit_document_orphans FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: lit_document_statuses lit_document_statuses_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_document_statuses_audit BEFORE INSERT OR DELETE OR UPDATE ON lit_document_statuses FOR EACH ROW EXECUTE PROCEDURE core_audit.lit_document_statuses_aud_tr_func();


--
-- Name: lit_document_types lit_document_types_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_document_types_audit BEFORE INSERT OR DELETE OR UPDATE ON lit_document_types FOR EACH ROW EXECUTE PROCEDURE core_audit.lit_document_types_aud_tr_func();


--
-- Name: lit_documents lit_documents_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_documents_audit BEFORE INSERT OR DELETE OR UPDATE ON lit_documents FOR EACH ROW EXECUTE PROCEDURE core_audit.lit_documents_aud_tr_func();


--
-- Name: lit_documents lit_documents_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_documents_insert_timestamps BEFORE INSERT ON lit_documents FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: lit_documents lit_documents_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_documents_update_timestamp BEFORE UPDATE ON lit_documents FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: lit_families lit_families_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_families_audit BEFORE INSERT OR DELETE OR UPDATE ON lit_families FOR EACH ROW EXECUTE PROCEDURE core_audit.lit_families_aud_tr_func();


--
-- Name: lit_judges_map lit_judges_map_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_judges_map_audit BEFORE INSERT OR DELETE OR UPDATE ON lit_judges_map FOR EACH ROW EXECUTE PROCEDURE core_audit.lit_judges_map_aud_tr_func();


--
-- Name: lit_judges_map lit_judges_map_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_judges_map_insert_timestamps BEFORE INSERT ON lit_judges_map FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE lit_judges_map DISABLE TRIGGER lit_judges_map_insert_timestamps;


--
-- Name: lit_judges_map lit_judges_map_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_judges_map_update_timestamp BEFORE UPDATE ON lit_judges_map FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE lit_judges_map DISABLE TRIGGER lit_judges_map_update_timestamp;


--
-- Name: lit_parties lit_parties_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_parties_audit BEFORE INSERT OR DELETE OR UPDATE ON lit_parties FOR EACH ROW EXECUTE PROCEDURE core_audit.lit_parties_aud_tr_func();


--
-- Name: lit_parties lit_parties_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_parties_insert_timestamps BEFORE INSERT ON lit_parties FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE lit_parties DISABLE TRIGGER lit_parties_insert_timestamps;


--
-- Name: lit_parties_representations lit_parties_representations_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_parties_representations_audit BEFORE INSERT OR DELETE OR UPDATE ON lit_parties_representations FOR EACH ROW EXECUTE PROCEDURE core_audit.lit_parties_representations_aud_tr_func();


--
-- Name: lit_parties_representations lit_parties_representations_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_parties_representations_insert_timestamps BEFORE INSERT ON lit_parties_representations FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE lit_parties_representations DISABLE TRIGGER lit_parties_representations_insert_timestamps;


--
-- Name: lit_parties_representations lit_parties_representations_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_parties_representations_update_timestamp BEFORE UPDATE ON lit_parties_representations FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE lit_parties_representations DISABLE TRIGGER lit_parties_representations_update_timestamp;


--
-- Name: lit_parties lit_parties_trig; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_parties_trig BEFORE UPDATE ON lit_parties FOR EACH ROW EXECUTE PROCEDURE lit_parties_trig_func();


--
-- Name: lit_parties lit_parties_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_parties_update_timestamp BEFORE UPDATE ON lit_parties FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE lit_parties DISABLE TRIGGER lit_parties_update_timestamp;


--
-- Name: lit_party_normalized_types lit_party_normalized_types_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_party_normalized_types_audit BEFORE INSERT OR DELETE OR UPDATE ON lit_party_normalized_types FOR EACH ROW EXECUTE PROCEDURE core_audit.lit_party_normalized_types_aud_tr_func();


--
-- Name: lit_party_normalized_types lit_party_normalized_types_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_party_normalized_types_insert_timestamps BEFORE INSERT ON lit_party_normalized_types FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE lit_party_normalized_types DISABLE TRIGGER lit_party_normalized_types_insert_timestamps;


--
-- Name: lit_party_normalized_types lit_party_normalized_types_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_party_normalized_types_update_timestamp BEFORE UPDATE ON lit_party_normalized_types FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE lit_party_normalized_types DISABLE TRIGGER lit_party_normalized_types_update_timestamp;


--
-- Name: lit_party_types lit_party_types_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_party_types_audit BEFORE INSERT OR DELETE OR UPDATE ON lit_party_types FOR EACH ROW EXECUTE PROCEDURE core_audit.lit_party_types_aud_tr_func();


--
-- Name: lit_party_types lit_party_types_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_party_types_insert_timestamps BEFORE INSERT ON lit_party_types FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE lit_party_types DISABLE TRIGGER lit_party_types_insert_timestamps;


--
-- Name: lit_party_types lit_party_types_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_party_types_update_timestamp BEFORE UPDATE ON lit_party_types FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE lit_party_types DISABLE TRIGGER lit_party_types_update_timestamp;


--
-- Name: lit_relationship_types lit_relationship_types_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_relationship_types_audit BEFORE INSERT OR DELETE OR UPDATE ON lit_relationship_types FOR EACH ROW EXECUTE PROCEDURE core_audit.lit_relationship_types_aud_tr_func();


--
-- Name: lit_relationship_types lit_relationship_types_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_relationship_types_insert_timestamps BEFORE INSERT ON lit_relationship_types FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE lit_relationship_types DISABLE TRIGGER lit_relationship_types_insert_timestamps;


--
-- Name: lit_relationship_types lit_relationship_types_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_relationship_types_update_timestamp BEFORE UPDATE ON lit_relationship_types FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE lit_relationship_types DISABLE TRIGGER lit_relationship_types_update_timestamp;


--
-- Name: lit_relationships lit_relationships_after_change; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_relationships_after_change AFTER INSERT OR DELETE OR UPDATE ON lit_relationships FOR EACH ROW EXECUTE PROCEDURE after_lit_relationship_change();


--
-- Name: lit_relationships lit_relationships_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_relationships_audit BEFORE INSERT OR DELETE OR UPDATE ON lit_relationships FOR EACH ROW EXECUTE PROCEDURE core_audit.lit_relationships_aud_tr_func();


--
-- Name: lit_relationships lit_relationships_before_change; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_relationships_before_change BEFORE INSERT OR DELETE OR UPDATE ON lit_relationships FOR EACH ROW EXECUTE PROCEDURE before_lit_relationship_change();


--
-- Name: lit_relationships lit_relationships_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_relationships_insert_timestamps BEFORE INSERT ON lit_relationships FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE lit_relationships DISABLE TRIGGER lit_relationships_insert_timestamps;


--
-- Name: lit_relationships lit_relationships_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_relationships_update_timestamp BEFORE UPDATE ON lit_relationships FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE lit_relationships DISABLE TRIGGER lit_relationships_update_timestamp;


--
-- Name: lit_stages lit_stages_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_stages_audit BEFORE INSERT OR DELETE OR UPDATE ON lit_stages FOR EACH ROW EXECUTE PROCEDURE core_audit.lit_stages_aud_tr_func();


--
-- Name: lit_stages lit_stages_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_stages_insert_timestamps BEFORE INSERT ON lit_stages FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE lit_stages DISABLE TRIGGER lit_stages_insert_timestamps;


--
-- Name: lit_stages lit_stages_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_stages_update_timestamp BEFORE UPDATE ON lit_stages FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE lit_stages DISABLE TRIGGER lit_stages_update_timestamp;


--
-- Name: lit_types lit_types_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_types_audit BEFORE INSERT OR DELETE OR UPDATE ON lit_types FOR EACH ROW EXECUTE PROCEDURE core_audit.lit_types_aud_tr_func();


--
-- Name: lit_types lit_types_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_types_insert_timestamps BEFORE INSERT ON lit_types FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE lit_types DISABLE TRIGGER lit_types_insert_timestamps;


--
-- Name: lit_types lit_types_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lit_types_update_timestamp BEFORE UPDATE ON lit_types FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE lit_types DISABLE TRIGGER lit_types_update_timestamp;


--
-- Name: lits lits_after_insert; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lits_after_insert AFTER INSERT ON lits FOR EACH ROW EXECUTE PROCEDURE after_lit_add();


--
-- Name: lits lits_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lits_audit BEFORE INSERT OR DELETE OR UPDATE ON lits FOR EACH ROW EXECUTE PROCEDURE core_audit.lits_aud_tr_func();


--
-- Name: lits lits_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lits_insert_timestamps BEFORE INSERT ON lits FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE lits DISABLE TRIGGER lits_insert_timestamps;


--
-- Name: lits_pats_map lits_pats_map_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lits_pats_map_audit BEFORE INSERT OR DELETE OR UPDATE ON lits_pats_map FOR EACH ROW EXECUTE PROCEDURE core_audit.lits_pats_map_aud_tr_func();


--
-- Name: lits_pats_map lits_pats_map_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lits_pats_map_insert_timestamps BEFORE INSERT ON lits_pats_map FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE lits_pats_map DISABLE TRIGGER lits_pats_map_insert_timestamps;


--
-- Name: lits_pats_map lits_pats_map_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lits_pats_map_update_timestamp BEFORE UPDATE ON lits_pats_map FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE lits_pats_map DISABLE TRIGGER lits_pats_map_update_timestamp;


--
-- Name: lits_pats_other lits_pats_other_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lits_pats_other_insert_timestamps BEFORE INSERT ON lits_pats_other FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: lits_pats_other lits_pats_other_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lits_pats_other_update_timestamp BEFORE UPDATE ON lits_pats_other FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: lits_pats_tmp lits_pats_tmp_replacement_trigger; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lits_pats_tmp_replacement_trigger INSTEAD OF INSERT OR DELETE OR UPDATE ON lits_pats_tmp FOR EACH ROW EXECUTE PROCEDURE replace_lits_pats_tmp();


--
-- Name: lits lits_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER lits_update_timestamp BEFORE UPDATE ON lits FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE lits DISABLE TRIGGER lits_update_timestamp;


--
-- Name: market_sector_types market_sector_types_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER market_sector_types_audit BEFORE INSERT OR DELETE OR UPDATE ON market_sector_types FOR EACH ROW EXECUTE PROCEDURE core_audit.market_sector_types_aud_tr_func();


--
-- Name: market_sector_types market_sector_types_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER market_sector_types_insert_timestamps BEFORE INSERT ON market_sector_types FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE market_sector_types DISABLE TRIGGER market_sector_types_insert_timestamps;


--
-- Name: market_sector_types market_sector_types_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER market_sector_types_update_timestamp BEFORE UPDATE ON market_sector_types FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE market_sector_types DISABLE TRIGGER market_sector_types_update_timestamp;


--
-- Name: pat_abstracts pat_abstracts_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_abstracts_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_abstracts FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_abstracts_aud_tr_func();


--
-- Name: pat_abstracts pat_abstracts_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_abstracts_insert_timestamps BEFORE INSERT ON pat_abstracts FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE pat_abstracts DISABLE TRIGGER pat_abstracts_insert_timestamps;


--
-- Name: pat_abstracts pat_abstracts_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_abstracts_update_timestamp BEFORE UPDATE ON pat_abstracts FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE pat_abstracts DISABLE TRIGGER pat_abstracts_update_timestamp;


--
-- Name: pat_assignments_assoc_r_f pat_assignments_assoc_r_f_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_assignments_assoc_r_f_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_assignments_assoc_r_f FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_assignments_assoc_r_f_aud_tr_func();


--
-- Name: pat_assignments pat_assignments_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_assignments_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_assignments FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_assignments_aud_tr_func();


--
-- Name: pat_assignments pat_assignments_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_assignments_insert_timestamps BEFORE INSERT ON pat_assignments FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE pat_assignments DISABLE TRIGGER pat_assignments_insert_timestamps;


--
-- Name: pat_assignments pat_assignments_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_assignments_update_timestamp BEFORE UPDATE ON pat_assignments FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE pat_assignments DISABLE TRIGGER pat_assignments_update_timestamp;


--
-- Name: pat_claim_relationships pat_claim_relationships_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_claim_relationships_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_claim_relationships FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_claim_relationships_aud_tr_func();


--
-- Name: pat_claim_relationships pat_claim_relationships_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_claim_relationships_insert_timestamps BEFORE INSERT ON pat_claim_relationships FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: pat_claim_relationships pat_claim_relationships_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_claim_relationships_update_timestamp BEFORE UPDATE ON pat_claim_relationships FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: pat_claims pat_claims_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_claims_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_claims FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_claims_aud_tr_func();


--
-- Name: pat_claims pat_claims_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_claims_insert_timestamps BEFORE INSERT ON pat_claims FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE pat_claims DISABLE TRIGGER pat_claims_insert_timestamps;


--
-- Name: pat_claims pat_claims_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_claims_update_timestamp BEFORE UPDATE ON pat_claims FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE pat_claims DISABLE TRIGGER pat_claims_update_timestamp;


--
-- Name: pat_cross_ref_classes pat_cross_ref_classes_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_cross_ref_classes_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_cross_ref_classes FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_cross_ref_classes_aud_tr_func();


--
-- Name: pat_cross_ref_classes pat_cross_ref_classes_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_cross_ref_classes_insert_timestamps BEFORE INSERT ON pat_cross_ref_classes FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: pat_cross_ref_classes pat_cross_ref_classes_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_cross_ref_classes_update_timestamp BEFORE UPDATE ON pat_cross_ref_classes FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: pat_current pat_current_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_current_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_current FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_current_aud_tr_func();


--
-- Name: pat_descriptions pat_descriptions_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_descriptions_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_descriptions FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_descriptions_aud_tr_func();


--
-- Name: pat_descriptions pat_descriptions_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_descriptions_insert_timestamps BEFORE INSERT ON pat_descriptions FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE pat_descriptions DISABLE TRIGGER pat_descriptions_insert_timestamps;


--
-- Name: pat_descriptions pat_descriptions_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_descriptions_update_timestamp BEFORE UPDATE ON pat_descriptions FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE pat_descriptions DISABLE TRIGGER pat_descriptions_update_timestamp;


--
-- Name: pat_document_types pat_document_types_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_document_types_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_document_types FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_document_types_aud_tr_func();


--
-- Name: pat_documents pat_documents_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_documents_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_documents FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_documents_aud_tr_func();


--
-- Name: pat_documents pat_documents_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_documents_insert_timestamps BEFORE INSERT ON pat_documents FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: pat_documents pat_documents_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_documents_update_timestamp BEFORE UPDATE ON pat_documents FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: pat_drawings pat_drawings_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_drawings_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_drawings FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_drawings_aud_tr_func();


--
-- Name: pat_drawings pat_drawings_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_drawings_insert_timestamps BEFORE INSERT ON pat_drawings FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: pat_drawings pat_drawings_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_drawings_update_timestamp BEFORE UPDATE ON pat_drawings FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: pat_ent_relationships pat_ent_relationships_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_ent_relationships_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_ent_relationships FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_ent_relationships_aud_tr_func();


--
-- Name: pat_family_pats_details pat_family_pats_details_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_family_pats_details_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_family_pats_details FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_family_pats_details_aud_tr_func();


--
-- Name: pat_ipc_classes pat_ipc_classes_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_ipc_classes_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_ipc_classes FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_ipc_classes_aud_tr_func();


--
-- Name: pat_ipc_classes pat_ipc_classes_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_ipc_classes_insert_timestamps BEFORE INSERT ON pat_ipc_classes FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: pat_ipc_classes pat_ipc_classes_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_ipc_classes_update_timestamp BEFORE UPDATE ON pat_ipc_classes FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: pat_maintenance_fee_entity_types pat_maintenance_fee_entity_types_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_maintenance_fee_entity_types_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_maintenance_fee_entity_types FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_maintenance_fee_entity_types_aud_tr_func();


--
-- Name: pat_maintenance_fee_event_types pat_maintenance_fee_event_types_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_maintenance_fee_event_types_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_maintenance_fee_event_types FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_maintenance_fee_event_types_aud_tr_func();


--
-- Name: pat_maintenance_fee_events pat_maintenance_fee_events_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_maintenance_fee_events_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_maintenance_fee_events FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_maintenance_fee_events_aud_tr_func();


--
-- Name: pat_orig_app_num_country pat_orig_app_num_country_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_orig_app_num_country_insert_timestamps BEFORE INSERT ON pat_orig_app_num_country FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: pat_orig_app_num_country pat_orig_app_num_country_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_orig_app_num_country_update_timestamp BEFORE UPDATE ON pat_orig_app_num_country FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: pat_other_references pat_other_references_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_other_references_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_other_references FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_other_references_aud_tr_func();


--
-- Name: pat_other_references pat_other_references_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_other_references_insert_timestamps BEFORE INSERT ON pat_other_references FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: pat_other_references pat_other_references_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_other_references_update_timestamp BEFORE UPDATE ON pat_other_references FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: pat_primary_conveyance_types pat_primary_conveyance_types_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_primary_conveyance_types_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_primary_conveyance_types FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_primary_conveyance_types_aud_tr_func();


--
-- Name: pat_priority_claims pat_priority_claims_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_priority_claims_insert_timestamps BEFORE INSERT ON pat_priority_claims FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: pat_priority_claims pat_priority_claims_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_priority_claims_update_timestamp BEFORE UPDATE ON pat_priority_claims FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: pat_references pat_references_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_references_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_references FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_references_aud_tr_func();


--
-- Name: pat_references pat_references_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_references_insert_timestamps BEFORE INSERT ON pat_references FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: pat_references pat_references_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_references_update_timestamp BEFORE UPDATE ON pat_references FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: pat_related_documents pat_related_documents_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_related_documents_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_related_documents FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_related_documents_aud_tr_func();


--
-- Name: pat_related_documents pat_related_documents_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_related_documents_insert_timestamps BEFORE INSERT ON pat_related_documents FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: pat_related_documents pat_related_documents_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_related_documents_update_timestamp BEFORE UPDATE ON pat_related_documents FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: pat_secondary_conveyance pat_secondary_conveyance_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_secondary_conveyance_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_secondary_conveyance FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_secondary_conveyance_aud_tr_func();


--
-- Name: pat_secondary_conveyance_types pat_secondary_conveyance_types_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_secondary_conveyance_types_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_secondary_conveyance_types FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_secondary_conveyance_types_aud_tr_func();


--
-- Name: pat_stats_all_assignees pat_stats_all_assignees_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_stats_all_assignees_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_stats_all_assignees FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_stats_all_assignees_aud_tr_func();


--
-- Name: pat_stats pat_stats_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_stats_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_stats FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_stats_aud_tr_func();


--
-- Name: pat_stats_continuances pat_stats_continuances_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_stats_continuances_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_stats_continuances FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_stats_continuances_aud_tr_func();

ALTER TABLE pat_stats_continuances DISABLE TRIGGER pat_stats_continuances_audit;


--
-- Name: pat_stats_continuances pat_stats_continuances_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_stats_continuances_insert_timestamps BEFORE INSERT ON pat_stats_continuances FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE pat_stats_continuances DISABLE TRIGGER pat_stats_continuances_insert_timestamps;


--
-- Name: pat_stats_continuances pat_stats_continuances_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_stats_continuances_update_timestamp BEFORE UPDATE ON pat_stats_continuances FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE pat_stats_continuances DISABLE TRIGGER pat_stats_continuances_update_timestamp;


--
-- Name: pat_stats_current_assignees pat_stats_current_assignees_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_stats_current_assignees_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_stats_current_assignees FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_stats_current_assignees_aud_tr_func();


--
-- Name: pat_stats_current_assignees pat_stats_current_assignees_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_stats_current_assignees_insert_timestamps BEFORE INSERT ON pat_stats_current_assignees FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE pat_stats_current_assignees DISABLE TRIGGER pat_stats_current_assignees_insert_timestamps;


--
-- Name: pat_stats_current_assignees pat_stats_current_assignees_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_stats_current_assignees_update_timestamp BEFORE UPDATE ON pat_stats_current_assignees FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE pat_stats_current_assignees DISABLE TRIGGER pat_stats_current_assignees_update_timestamp;


--
-- Name: pat_stats_current_assignors pat_stats_current_assignors_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_stats_current_assignors_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_stats_current_assignors FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_stats_current_assignors_aud_tr_func();


--
-- Name: pat_stats pat_stats_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_stats_insert_timestamps BEFORE INSERT ON pat_stats FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: pat_stats_inventors pat_stats_inventors_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_stats_inventors_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_stats_inventors FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_stats_inventors_aud_tr_func();


--
-- Name: pat_stats_sponsoring_parties pat_stats_sponsoring_parties_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_stats_sponsoring_parties_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_stats_sponsoring_parties FOR EACH ROW EXECUTE PROCEDURE core_audit.pat_stats_sponsoring_parties_aud_tr_func();


--
-- Name: pat_stats_sponsoring_parties pat_stats_sponsoring_parties_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_stats_sponsoring_parties_insert_timestamps BEFORE INSERT ON pat_stats_sponsoring_parties FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE pat_stats_sponsoring_parties DISABLE TRIGGER pat_stats_sponsoring_parties_insert_timestamps;


--
-- Name: pat_stats_sponsoring_parties pat_stats_sponsoring_parties_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_stats_sponsoring_parties_update_timestamp BEFORE UPDATE ON pat_stats_sponsoring_parties FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE pat_stats_sponsoring_parties DISABLE TRIGGER pat_stats_sponsoring_parties_update_timestamp;


--
-- Name: pat_stats pat_stats_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pat_stats_update_timestamp BEFORE UPDATE ON pat_stats FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: pats_aliases_map patent_aliases_map_alias_role_trig; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER patent_aliases_map_alias_role_trig AFTER INSERT OR DELETE OR UPDATE ON pats_aliases_map FOR EACH ROW EXECUTE PROCEDURE patent_aliases_map_alias_role_trig_func();


--
-- Name: assignees_aliases_map patent_assignee_alias_role_trig; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER patent_assignee_alias_role_trig AFTER INSERT OR DELETE OR UPDATE ON assignees_aliases_map FOR EACH ROW EXECUTE PROCEDURE patent_assignee_alias_role_trig_func();


--
-- Name: assignors_aliases_map patent_assignor_alias_role_trig; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER patent_assignor_alias_role_trig AFTER INSERT OR DELETE OR UPDATE ON assignors_aliases_map FOR EACH ROW EXECUTE PROCEDURE patent_assignor_alias_role_trig_func();


--
-- Name: pat_assignments patent_correspondent_alias_role_trig; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER patent_correspondent_alias_role_trig AFTER INSERT OR DELETE OR UPDATE ON pat_assignments FOR EACH ROW EXECUTE PROCEDURE patent_correspondent_alias_role_trig_func();


--
-- Name: pat_stats_current_assignees patent_current_assignee_alias_role_trig; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER patent_current_assignee_alias_role_trig AFTER INSERT OR DELETE OR UPDATE ON pat_stats_current_assignees FOR EACH ROW EXECUTE PROCEDURE patent_current_assignee_alias_role_trig_func();


--
-- Name: patent_owners patent_owners_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER patent_owners_audit BEFORE INSERT OR DELETE OR UPDATE ON patent_owners FOR EACH ROW EXECUTE PROCEDURE core_audit.patent_owners_aud_tr_func();


--
-- Name: pat_stats_sponsoring_parties patent_sponsoring_party_alias_role_trig; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER patent_sponsoring_party_alias_role_trig AFTER INSERT OR DELETE OR UPDATE ON pat_stats_sponsoring_parties FOR EACH ROW EXECUTE PROCEDURE patent_sponsoring_party_alias_role_trig_func();


--
-- Name: pats_aliases_map pats_aliases_map_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pats_aliases_map_audit BEFORE INSERT OR DELETE OR UPDATE ON pats_aliases_map FOR EACH ROW EXECUTE PROCEDURE core_audit.pats_aliases_map_aud_tr_func();


--
-- Name: pats_aliases_relationship_types pats_aliases_relationship_types_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pats_aliases_relationship_types_audit BEFORE INSERT OR DELETE OR UPDATE ON pats_aliases_relationship_types FOR EACH ROW EXECUTE PROCEDURE core_audit.pats_aliases_relationship_types_aud_tr_func();


--
-- Name: pats_aliases_relationship_types pats_aliases_relationship_types_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pats_aliases_relationship_types_insert_timestamps BEFORE INSERT ON pats_aliases_relationship_types FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: pats_aliases_relationship_types pats_aliases_relationship_types_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pats_aliases_relationship_types_update_timestamp BEFORE UPDATE ON pats_aliases_relationship_types FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: pats_assignments_map pats_assignments_map_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pats_assignments_map_audit BEFORE INSERT OR DELETE OR UPDATE ON pats_assignments_map FOR EACH ROW EXECUTE PROCEDURE core_audit.pats_assignments_map_aud_tr_func();


--
-- Name: pats_assignments_map pats_assignments_map_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pats_assignments_map_insert_timestamps BEFORE INSERT ON pats_assignments_map FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();

ALTER TABLE pats_assignments_map DISABLE TRIGGER pats_assignments_map_insert_timestamps;


--
-- Name: pats_assignments_map pats_assignments_map_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pats_assignments_map_update_timestamp BEFORE UPDATE ON pats_assignments_map FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

ALTER TABLE pats_assignments_map DISABLE TRIGGER pats_assignments_map_update_timestamp;


--
-- Name: pats pats_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pats_audit BEFORE INSERT OR DELETE OR UPDATE ON pats FOR EACH ROW EXECUTE PROCEDURE core_audit.pats_aud_tr_func();


--
-- Name: pats_field_of_search pats_field_of_search_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pats_field_of_search_insert_timestamps BEFORE INSERT ON pats_field_of_search FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: pats_field_of_search pats_field_of_search_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pats_field_of_search_update_timestamp BEFORE UPDATE ON pats_field_of_search FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: pats pats_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pats_insert_timestamps BEFORE INSERT ON pats FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: pats_invention pats_invention_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pats_invention_audit BEFORE INSERT OR DELETE OR UPDATE ON pats_invention FOR EACH ROW EXECUTE PROCEDURE core_audit.pats_invention_aud_tr_func();


--
-- Name: pats_invention pats_invention_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pats_invention_insert_timestamps BEFORE INSERT ON pats_invention FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: pats_invention_link pats_invention_link_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pats_invention_link_audit BEFORE INSERT OR DELETE OR UPDATE ON pats_invention_link FOR EACH ROW EXECUTE PROCEDURE core_audit.pats_invention_link_aud_tr_func();


--
-- Name: pats_invention_link pats_invention_link_insert_timestamps; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pats_invention_link_insert_timestamps BEFORE INSERT ON pats_invention_link FOR EACH ROW EXECUTE PROCEDURE insert_timestamps();


--
-- Name: pats_invention_link pats_invention_link_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pats_invention_link_update_timestamp BEFORE UPDATE ON pats_invention_link FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: pats_invention pats_invention_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pats_invention_update_timestamp BEFORE UPDATE ON pats_invention FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: pats pats_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pats_update_timestamp BEFORE UPDATE ON pats FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: pat_primary_conveyance_types pats_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pats_update_timestamp BEFORE UPDATE ON pat_primary_conveyance_types FOR EACH ROW EXECUTE PROCEDURE patent_conveyance_normalization.update_timestamp_trg_func();

ALTER TABLE pat_primary_conveyance_types DISABLE TRIGGER pats_update_timestamp;


--
-- Name: pat_secondary_conveyance pats_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pats_update_timestamp BEFORE UPDATE ON pat_secondary_conveyance FOR EACH ROW EXECUTE PROCEDURE patent_conveyance_normalization.update_timestamp_trg_func();

ALTER TABLE pat_secondary_conveyance DISABLE TRIGGER pats_update_timestamp;


--
-- Name: pat_assignments_assoc_r_f pats_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pats_update_timestamp BEFORE UPDATE ON pat_assignments_assoc_r_f FOR EACH ROW EXECUTE PROCEDURE patent_conveyance_normalization.update_timestamp_trg_func();

ALTER TABLE pat_assignments_assoc_r_f DISABLE TRIGGER pats_update_timestamp;


--
-- Name: pat_secondary_conveyance_types pats_update_timestamp; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER pats_update_timestamp BEFORE UPDATE ON pat_secondary_conveyance_types FOR EACH ROW EXECUTE PROCEDURE patent_conveyance_normalization.update_timestamp_trg_func();

ALTER TABLE pat_secondary_conveyance_types DISABLE TRIGGER pats_update_timestamp;


--
-- Name: ravel_judges ravel_judges_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER ravel_judges_audit BEFORE INSERT OR DELETE OR UPDATE ON ravel_judges FOR EACH ROW EXECUTE PROCEDURE core_audit.ravel_judges_aud_tr_func();


--
-- Name: ent_relationships sync_ent_subs_trig; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER sync_ent_subs_trig AFTER INSERT OR DELETE OR UPDATE ON ent_relationships FOR EACH ROW EXECUTE PROCEDURE sync_ent_subss_trig_func();


--
-- Name: lit_relationships sync_original_filed_date; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER sync_original_filed_date AFTER INSERT OR DELETE OR UPDATE ON lit_relationships FOR EACH ROW EXECUTE PROCEDURE sync_original_filed_date_tr();


--
-- Name: ent_relationships sync_ultimate_parent; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER sync_ultimate_parent AFTER INSERT OR DELETE OR UPDATE ON ent_relationships FOR EACH ROW EXECUTE PROCEDURE sync_ultimate_parent_tr();


--
-- Name: users users_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER users_audit BEFORE INSERT OR DELETE OR UPDATE ON users FOR EACH ROW EXECUTE PROCEDURE core_audit.users_aud_tr_func();


--
-- Name: uspcs_classes uspcs_classes_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER uspcs_classes_audit BEFORE INSERT OR DELETE OR UPDATE ON uspcs_classes FOR EACH ROW EXECUTE PROCEDURE core_audit.uspcs_classes_aud_tr_func();


--
-- Name: uspcs_subclasses uspcs_subclasses_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER uspcs_subclasses_audit BEFORE INSERT OR DELETE OR UPDATE ON uspcs_subclasses FOR EACH ROW EXECUTE PROCEDURE core_audit.uspcs_subclasses_aud_tr_func();


--
-- Name: uspto_practitioner_roster uspto_practitioner_roster_alias_role_trig; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER uspto_practitioner_roster_alias_role_trig AFTER INSERT OR DELETE OR UPDATE ON uspto_practitioner_roster FOR EACH ROW EXECUTE PROCEDURE uspto_practitioner_roster_alias_role_trig_func();


--
-- Name: uspto_practitioner_roster uspto_practitioner_roster_audit; Type: TRIGGER; Schema: core; Owner: -
--

CREATE TRIGGER uspto_practitioner_roster_audit BEFORE INSERT OR DELETE OR UPDATE ON uspto_practitioner_roster FOR EACH ROW EXECUTE PROCEDURE core_audit.uspto_practitioner_roster_aud_tr_func();


SET search_path = docdb, pg_catalog;

--
-- Name: docdb_ipcs docdb_ipcs_audit; Type: TRIGGER; Schema: docdb; Owner: -
--

CREATE TRIGGER docdb_ipcs_audit BEFORE INSERT OR DELETE OR UPDATE ON docdb_ipcs FOR EACH ROW EXECUTE PROCEDURE docdb_audit.docdb_ipcs_aud_tr_func();


--
-- Name: docdb_pats docdb_pats_audit; Type: TRIGGER; Schema: docdb; Owner: -
--

CREATE TRIGGER docdb_pats_audit BEFORE INSERT OR DELETE OR UPDATE ON docdb_pats FOR EACH ROW EXECUTE PROCEDURE docdb_audit.docdb_pats_aud_tr_func();


--
-- Name: docdb_priority_claims docdb_priority_claim_delete_trig; Type: TRIGGER; Schema: docdb; Owner: -
--

CREATE TRIGGER docdb_priority_claim_delete_trig AFTER DELETE ON docdb_priority_claims FOR EACH ROW EXECUTE PROCEDURE docdb_priority_claim_delete_trig_func();


--
-- Name: docdb_priority_claims docdb_priority_claims_audit; Type: TRIGGER; Schema: docdb; Owner: -
--

CREATE TRIGGER docdb_priority_claims_audit BEFORE INSERT OR DELETE OR UPDATE ON docdb_priority_claims FOR EACH ROW EXECUTE PROCEDURE docdb_audit.docdb_priority_claims_aud_tr_func();


--
-- Name: log_data partition_log_data_trigger; Type: TRIGGER; Schema: docdb; Owner: -
--

CREATE TRIGGER partition_log_data_trigger BEFORE INSERT ON log_data FOR EACH ROW EXECUTE PROCEDURE log_data_partition_trigger();


--
-- Name: pat_normalized_family_relationships pat_normalized_family_relationships_audit; Type: TRIGGER; Schema: docdb; Owner: -
--

CREATE TRIGGER pat_normalized_family_relationships_audit BEFORE INSERT OR DELETE OR UPDATE ON pat_normalized_family_relationships FOR EACH ROW EXECUTE PROCEDURE docdb_audit.pat_normalized_family_relationships_aud_tr_func();


SET search_path = ptab, pg_catalog;

--
-- Name: ptab_annotations ptab_annotations_audit; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER ptab_annotations_audit BEFORE INSERT OR DELETE OR UPDATE ON ptab_annotations FOR EACH ROW EXECUTE PROCEDURE ptab_audit.ptab_annotations_aud_tr_func();


--
-- Name: ptab_attorney ptab_attorney_audit; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER ptab_attorney_audit BEFORE INSERT OR DELETE OR UPDATE ON ptab_attorney FOR EACH ROW EXECUTE PROCEDURE ptab_audit.ptab_attorney_aud_tr_func();

ALTER TABLE ptab_attorney DISABLE TRIGGER ptab_attorney_audit;


--
-- Name: ptab_case_detail_party_types ptab_case_detail_party_types_audit; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER ptab_case_detail_party_types_audit BEFORE INSERT OR DELETE OR UPDATE ON ptab_case_detail_party_types FOR EACH ROW EXECUTE PROCEDURE ptab_audit.ptab_case_detail_party_types_aud_tr_func();


--
-- Name: ptab_case_detail_party_types ptab_case_detail_pary_types_update_timestamp; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER ptab_case_detail_pary_types_update_timestamp BEFORE UPDATE ON ptab_case_detail_party_types FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: ptab_case_details ptab_case_details_audit; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER ptab_case_details_audit BEFORE INSERT OR DELETE OR UPDATE ON ptab_case_details FOR EACH ROW EXECUTE PROCEDURE ptab_audit.ptab_case_details_aud_tr_func();


--
-- Name: ptab_case_details ptab_case_details_update_timestamp; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER ptab_case_details_update_timestamp BEFORE UPDATE ON ptab_case_details FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: ptab_cases ptab_case_status_change; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER ptab_case_status_change BEFORE INSERT OR UPDATE ON ptab_cases FOR EACH ROW EXECUTE PROCEDURE case_status_change_tr_function();


--
-- Name: ptab_case_types ptab_case_types_audit; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER ptab_case_types_audit BEFORE INSERT OR DELETE OR UPDATE ON ptab_case_types FOR EACH ROW EXECUTE PROCEDURE ptab_audit.ptab_case_types_aud_tr_func();


--
-- Name: ptab_cases ptab_cases_audit; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER ptab_cases_audit BEFORE INSERT OR DELETE OR UPDATE ON ptab_cases FOR EACH ROW EXECUTE PROCEDURE ptab_audit.ptab_cases_aud_tr_func();


--
-- Name: ptab_cases ptab_cases_update_campaign; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER ptab_cases_update_campaign AFTER INSERT OR UPDATE ON ptab_cases FOR EACH ROW EXECUTE PROCEDURE update_campaign_tr_function();


--
-- Name: ptab_cases ptab_cases_update_timestamp; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER ptab_cases_update_timestamp BEFORE UPDATE ON ptab_cases FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: ptab_expert_info ptab_expert_alias_role_trig; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER ptab_expert_alias_role_trig AFTER INSERT OR DELETE OR UPDATE ON ptab_expert_info FOR EACH ROW EXECUTE PROCEDURE ptab_expert_alias_role_trig_func();


--
-- Name: ptab_expert_info ptab_expert_info_audit; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER ptab_expert_info_audit BEFORE INSERT OR DELETE OR UPDATE ON ptab_expert_info FOR EACH ROW EXECUTE PROCEDURE ptab_audit.ptab_expert_info_aud_tr_func();


--
-- Name: ptab_judges_map ptab_judge_alias_role_trig; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER ptab_judge_alias_role_trig AFTER INSERT OR DELETE OR UPDATE ON ptab_judges_map FOR EACH ROW EXECUTE PROCEDURE ptab_judge_alias_role_trig_func();


--
-- Name: ptab_judges_map ptab_judges_map_audit; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER ptab_judges_map_audit BEFORE INSERT OR DELETE OR UPDATE ON ptab_judges_map FOR EACH ROW EXECUTE PROCEDURE ptab_audit.ptab_judges_map_aud_tr_func();


--
-- Name: ptab_parties ptab_parties_audit; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER ptab_parties_audit BEFORE INSERT OR DELETE OR UPDATE ON ptab_parties FOR EACH ROW EXECUTE PROCEDURE ptab_audit.ptab_parties_aud_tr_func();


--
-- Name: ptab_parties_representations ptab_parties_representations_audit; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER ptab_parties_representations_audit BEFORE INSERT OR DELETE OR UPDATE ON ptab_parties_representations FOR EACH ROW EXECUTE PROCEDURE ptab_audit.ptab_parties_representations_aud_tr_func();


--
-- Name: ptab_parties ptab_parties_update_campaign; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER ptab_parties_update_campaign AFTER INSERT OR UPDATE ON ptab_parties FOR EACH ROW EXECUTE PROCEDURE ptab_parties_update_campaign_tr_function();


--
-- Name: ptab_parties ptab_parties_update_timestamp; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER ptab_parties_update_timestamp BEFORE UPDATE ON ptab_parties FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: ptab_parties ptab_party_alias_role_trig; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER ptab_party_alias_role_trig AFTER INSERT OR DELETE OR UPDATE ON ptab_parties FOR EACH ROW EXECUTE PROCEDURE ptab_party_alias_role_trig_func();


--
-- Name: ptab_party_types ptab_party_types_audit; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER ptab_party_types_audit BEFORE INSERT OR DELETE OR UPDATE ON ptab_party_types FOR EACH ROW EXECUTE PROCEDURE ptab_audit.ptab_party_types_aud_tr_func();


--
-- Name: ptab_party_types ptab_pary_types_update_timestamp; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER ptab_pary_types_update_timestamp BEFORE UPDATE ON ptab_party_types FOR EACH ROW EXECUTE PROCEDURE update_timestamp();


--
-- Name: technology_centers technology_centers_audit; Type: TRIGGER; Schema: ptab; Owner: -
--

CREATE TRIGGER technology_centers_audit BEFORE INSERT OR DELETE OR UPDATE ON technology_centers FOR EACH ROW EXECUTE PROCEDURE ptab_audit.technology_centers_aud_tr_func();


SET search_path = acquiflow, pg_catalog;

--
-- Name: acquisition_agreements acquisition_acquisition_agreement_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_agreements
    ADD CONSTRAINT acquisition_acquisition_agreement_fk FOREIGN KEY (acquisition_id) REFERENCES acquisitions(id);


--
-- Name: acquisition_patents acquisition_acquisition_patent_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patents
    ADD CONSTRAINT acquisition_acquisition_patent_fk FOREIGN KEY (acquisition_id) REFERENCES acquisitions(id);


--
-- Name: acquisition_agreements acquisition_agreements_account_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_agreements
    ADD CONSTRAINT acquisition_agreements_account_id_fk FOREIGN KEY (seller_sf_account_id) REFERENCES sf.all_accounts(id);


--
-- Name: acquisition_encumbrances acquisition_encumbrance_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_encumbrances
    ADD CONSTRAINT acquisition_encumbrance_fk FOREIGN KEY (acquisition_id) REFERENCES acquisitions(id);


--
-- Name: acquisition_encumbrance_patents acquisition_encumbrance_patents_acquisition_encumbrance_id_fkey; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_encumbrance_patents
    ADD CONSTRAINT acquisition_encumbrance_patents_acquisition_encumbrance_id_fkey FOREIGN KEY (acquisition_encumbrance_id) REFERENCES acquisition_encumbrances(id);


--
-- Name: acquisition_encumbrance_patents acquisition_encumbrance_patents_acquisition_patent_id_fkey; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_encumbrance_patents
    ADD CONSTRAINT acquisition_encumbrance_patents_acquisition_patent_id_fkey FOREIGN KEY (acquisition_patent_id) REFERENCES acquisition_patents(id);


--
-- Name: acquisition_encumbrances acquisition_encumbrances_account_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_encumbrances
    ADD CONSTRAINT acquisition_encumbrances_account_id_fk FOREIGN KEY (entity_sf_account_id) REFERENCES sf.all_accounts(id);


--
-- Name: acquisition_opportunities_portfolios acquisition_opportunities_portfolios_acquisition_sf_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_opportunities_portfolios
    ADD CONSTRAINT acquisition_opportunities_portfolios_acquisition_sf_id_fk FOREIGN KEY (acquisition_sf_id) REFERENCES sf.acquisition_opportunity__c(id);


--
-- Name: acquisition_opportunities_portfolios acquisition_opportunities_portfolios_portfolio_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_opportunities_portfolios
    ADD CONSTRAINT acquisition_opportunities_portfolios_portfolio_id_fk FOREIGN KEY (portfolio_id) REFERENCES portfolios(id);


--
-- Name: acquisition_options acquisition_option_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_options
    ADD CONSTRAINT acquisition_option_fk FOREIGN KEY (acquisition_id) REFERENCES acquisitions(id);


--
-- Name: acquisition_option_patents acquisition_option_patents_acquisition_option_id_fkey; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_option_patents
    ADD CONSTRAINT acquisition_option_patents_acquisition_option_id_fkey FOREIGN KEY (acquisition_option_id) REFERENCES acquisition_options(id);


--
-- Name: acquisition_option_patents acquisition_option_patents_acquisition_patent_id_fkey; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_option_patents
    ADD CONSTRAINT acquisition_option_patents_acquisition_patent_id_fkey FOREIGN KEY (acquisition_patent_id) REFERENCES acquisition_patents(id);


--
-- Name: acquisition_options acquisition_options_account_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_options
    ADD CONSTRAINT acquisition_options_account_id_fk FOREIGN KEY (entity_sf_account_id) REFERENCES sf.all_accounts(id);


--
-- Name: acquisition_options acquisition_options_divestiture_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_options
    ADD CONSTRAINT acquisition_options_divestiture_id_fk FOREIGN KEY (divestiture_id) REFERENCES divestitures(id);


--
-- Name: acquisition_patent_attributes_dcl acquisition_pat_attribs_dcl_acq_pat_attr_id_fkey; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patent_attributes_dcl
    ADD CONSTRAINT acquisition_pat_attribs_dcl_acq_pat_attr_id_fkey FOREIGN KEY (acquisition_patent_attribute_id) REFERENCES acquisition_patent_attributes(id) ON DELETE CASCADE;


--
-- Name: acquisition_patent_attributes acquisition_patent_attributes_acq_pat_id_fkey; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patent_attributes
    ADD CONSTRAINT acquisition_patent_attributes_acq_pat_id_fkey FOREIGN KEY (acquisition_patent_id) REFERENCES acquisition_patents(id);


--
-- Name: acquisition_patent_attributes acquisition_patent_attributes_case_type_id_fkey; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patent_attributes
    ADD CONSTRAINT acquisition_patent_attributes_case_type_id_fkey FOREIGN KEY (case_type_id) REFERENCES case_types(id);


--
-- Name: acquisition_patent_attributes_dcl acquisition_patent_attributes_dcl_case_type_id_fkey; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patent_attributes_dcl
    ADD CONSTRAINT acquisition_patent_attributes_dcl_case_type_id_fkey FOREIGN KEY (case_type_id) REFERENCES case_types(id);


--
-- Name: acquisition_patents_dcl acquisition_patent_dcl_acq_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patents_dcl
    ADD CONSTRAINT acquisition_patent_dcl_acq_fk FOREIGN KEY (acquisition_id) REFERENCES acquisitions(id);


--
-- Name: acquisition_patents_dcl_rpx_ownership_rights acquisition_patent_rpx_ownership_right_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patents_dcl_rpx_ownership_rights
    ADD CONSTRAINT acquisition_patent_rpx_ownership_right_fk FOREIGN KEY (rpx_ownership_right_id) REFERENCES rpx_ownership_rights(id);


--
-- Name: acquisition_patents acquisition_patent_trck_cpi_options_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patents
    ADD CONSTRAINT acquisition_patent_trck_cpi_options_fk FOREIGN KEY (cpi_tracking_status_id) REFERENCES cpi_tracking_status(id);


--
-- Name: acquisition_patents acquisition_patents_asset_status_type_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patents
    ADD CONSTRAINT acquisition_patents_asset_status_type_fk FOREIGN KEY (asset_status_type_id) REFERENCES asset_status_types(id);


--
-- Name: acquisition_patents_current_assignee_aliases acquisition_patents_current_assignee_aliases_fk1; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patents_current_assignee_aliases
    ADD CONSTRAINT acquisition_patents_current_assignee_aliases_fk1 FOREIGN KEY (acquisition_patent_id) REFERENCES acquisition_patents(id);


--
-- Name: acquisition_patents_current_assignee_aliases acquisition_patents_current_assignee_aliases_fk2; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patents_current_assignee_aliases
    ADD CONSTRAINT acquisition_patents_current_assignee_aliases_fk2 FOREIGN KEY (alias_id) REFERENCES core.aliases(id);


--
-- Name: acquisition_patents_dcl acquisition_patents_dcl_asset_status_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patents_dcl
    ADD CONSTRAINT acquisition_patents_dcl_asset_status_fk FOREIGN KEY (asset_status_type_id) REFERENCES asset_status_types(id);


--
-- Name: acquisition_patents_dcl_current_assignee_aliases acquisition_patents_dcl_current_assignee_aliases_fk1; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patents_dcl_current_assignee_aliases
    ADD CONSTRAINT acquisition_patents_dcl_current_assignee_aliases_fk1 FOREIGN KEY (acquisition_patent_dcl_id) REFERENCES acquisition_patents_dcl(id);


--
-- Name: acquisition_patents_dcl_current_assignee_aliases acquisition_patents_dcl_current_assignee_aliases_fk2; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patents_dcl_current_assignee_aliases
    ADD CONSTRAINT acquisition_patents_dcl_current_assignee_aliases_fk2 FOREIGN KEY (alias_id) REFERENCES core.aliases(id);


--
-- Name: acquisition_patents acquisition_patents_portfolio_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patents
    ADD CONSTRAINT acquisition_patents_portfolio_id_fk FOREIGN KEY (portfolio_id) REFERENCES portfolios(id);


--
-- Name: acquisition_patents_dcl acquisition_patents_portfolio_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patents_dcl
    ADD CONSTRAINT acquisition_patents_portfolio_id_fk FOREIGN KEY (portfolio_id) REFERENCES portfolios(id);


--
-- Name: acquisition_patents_dcl acquisition_pats_dcl_acq_pat_id_fkey; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_patents_dcl
    ADD CONSTRAINT acquisition_pats_dcl_acq_pat_id_fkey FOREIGN KEY (acquisition_patent_id) REFERENCES acquisition_patents(id) ON DELETE CASCADE;


--
-- Name: portfolios acquisition_portfolio_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY portfolios
    ADD CONSTRAINT acquisition_portfolio_fk FOREIGN KEY (acquisition_id) REFERENCES acquisitions(id);


--
-- Name: acquisition_restrictions acquisition_restriction_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_restrictions
    ADD CONSTRAINT acquisition_restriction_fk FOREIGN KEY (acquisition_id) REFERENCES acquisitions(id);


--
-- Name: acquisition_restriction_patents acquisition_restriction_patents_acquisition_patent_id_fkey; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_restriction_patents
    ADD CONSTRAINT acquisition_restriction_patents_acquisition_patent_id_fkey FOREIGN KEY (acquisition_patent_id) REFERENCES acquisition_patents(id);


--
-- Name: acquisition_restriction_patents acquisition_restriction_patents_acquisition_restriction_id_fkey; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_restriction_patents
    ADD CONSTRAINT acquisition_restriction_patents_acquisition_restriction_id_fkey FOREIGN KEY (acquisition_restriction_id) REFERENCES acquisition_restrictions(id);


--
-- Name: acquisition_restrictions acquisition_restrictions_account_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_restrictions
    ADD CONSTRAINT acquisition_restrictions_account_id_fk FOREIGN KEY (entity_sf_account_id) REFERENCES sf.all_accounts(id);


--
-- Name: acquisition_syndications acquisition_syndication_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_syndications
    ADD CONSTRAINT acquisition_syndication_fk FOREIGN KEY (acquisition_id) REFERENCES acquisitions(id);


--
-- Name: acquisition_syndications acquisition_syndications_account_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_syndications
    ADD CONSTRAINT acquisition_syndications_account_id_fk FOREIGN KEY (entity_sf_account_id) REFERENCES sf.all_accounts(id);


--
-- Name: acquisitions acquisition_type_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisitions
    ADD CONSTRAINT acquisition_type_fk FOREIGN KEY (acquisition_type_id) REFERENCES acquisition_types(id);


--
-- Name: acquisitions acquisitions_counter_party_type_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisitions
    ADD CONSTRAINT acquisitions_counter_party_type_id_fk FOREIGN KEY (counter_party_type_id) REFERENCES counter_party_types(id) ON DELETE SET NULL;


--
-- Name: acquisition_agreements agreement_term_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_agreements
    ADD CONSTRAINT agreement_term_fk FOREIGN KEY (agreement_term_id) REFERENCES agreement_terms(id);


--
-- Name: batch_generated_option_ents batch_generated_option_ents_account_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY batch_generated_option_ents
    ADD CONSTRAINT batch_generated_option_ents_account_id_fk FOREIGN KEY (account_id) REFERENCES sf.all_accounts(id);


--
-- Name: batch_generated_option_ents batch_generated_option_ents_bgo_status_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY batch_generated_option_ents
    ADD CONSTRAINT batch_generated_option_ents_bgo_status_id_fk FOREIGN KEY (bgo_status_id) REFERENCES batch_generated_option_statuses(id);


--
-- Name: batch_generated_option_ents batch_generated_option_ents_bgo_type_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY batch_generated_option_ents
    ADD CONSTRAINT batch_generated_option_ents_bgo_type_id_fk FOREIGN KEY (bgo_type_id) REFERENCES batch_generated_option_types(id);


--
-- Name: batch_generated_option_ents batch_generated_option_ents_option_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY batch_generated_option_ents
    ADD CONSTRAINT batch_generated_option_ents_option_id_fk FOREIGN KEY (option_id) REFERENCES acquisition_options(id);


--
-- Name: divestiture_patents divestiture_patents_acquisition_patents_dcl_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY divestiture_patents
    ADD CONSTRAINT divestiture_patents_acquisition_patents_dcl_id_fk FOREIGN KEY (acquisition_patents_dcl_id) REFERENCES acquisition_patents_dcl(id);


--
-- Name: divestiture_patents divestiture_patents_divestiture_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY divestiture_patents
    ADD CONSTRAINT divestiture_patents_divestiture_id_fk FOREIGN KEY (divestiture_id) REFERENCES divestitures(id);


--
-- Name: divestitures divestitures_counter_party_type_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY divestitures
    ADD CONSTRAINT divestitures_counter_party_type_id_fk FOREIGN KEY (counter_party_type_id) REFERENCES counter_party_types(id);


--
-- Name: divestitures divestitures_legal_lead_sf_userx_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY divestitures
    ADD CONSTRAINT divestitures_legal_lead_sf_userx_id_fk FOREIGN KEY (legal_lead_sf_userx_id) REFERENCES sf.userx(id);


--
-- Name: divestitures divestitures_seller_sf_account_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY divestitures
    ADD CONSTRAINT divestitures_seller_sf_account_id_fk FOREIGN KEY (seller_sf_account_id) REFERENCES sf.accountx(id);


--
-- Name: acquisition_encumbrances encrumbance_type_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_encumbrances
    ADD CONSTRAINT encrumbance_type_fk FOREIGN KEY (encumbrance_type_id) REFERENCES encumbrance_types(id);


--
-- Name: exercised_batch_options exercised_batch_options_entity_sf_account_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY exercised_batch_options
    ADD CONSTRAINT exercised_batch_options_entity_sf_account_id_fk FOREIGN KEY (entity_sf_account_id) REFERENCES sf.accountx(id);


--
-- Name: exercised_batch_options exercised_batch_options_option_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY exercised_batch_options
    ADD CONSTRAINT exercised_batch_options_option_id_fk FOREIGN KEY (option_id) REFERENCES acquisition_options(id);


--
-- Name: acquisition_options option_type_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_options
    ADD CONSTRAINT option_type_fk FOREIGN KEY (option_type_id) REFERENCES option_types(id);


--
-- Name: acquisition_restrictions restriction_type_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY acquisition_restrictions
    ADD CONSTRAINT restriction_type_fk FOREIGN KEY (restriction_type_id) REFERENCES restriction_types(id);


--
-- Name: rpx_cpi_asset_tracking_log rpx_cpi_asset_tracking_log__log_levels_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY rpx_cpi_asset_tracking_log
    ADD CONSTRAINT rpx_cpi_asset_tracking_log__log_levels_fk FOREIGN KEY (log_level_id) REFERENCES logging.log_levels(id);


--
-- Name: selected_batch_generated_option_types selected_batch_generated_option_types_batch_generated_option_ty; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY selected_batch_generated_option_types
    ADD CONSTRAINT selected_batch_generated_option_types_batch_generated_option_ty FOREIGN KEY (batch_generated_option_type_id) REFERENCES batch_generated_option_types(id);


--
-- Name: selected_batch_generated_option_types selected_batch_generated_option_types_option_id_fk; Type: FK CONSTRAINT; Schema: acquiflow; Owner: -
--

ALTER TABLE ONLY selected_batch_generated_option_types
    ADD CONSTRAINT selected_batch_generated_option_types_option_id_fk FOREIGN KEY (option_id) REFERENCES acquisition_options(id);


SET search_path = core, pg_catalog;

--
-- Name: assignees_aliases_map alias_contact_bk_assignees_aliases_map_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY assignees_aliases_map
    ADD CONSTRAINT alias_contact_bk_assignees_aliases_map_fk FOREIGN KEY (alias_contact_id) REFERENCES alias_contacts(id) MATCH FULL;


--
-- Name: assignees_aliases_map alias_contacts_assignees_aliases_map_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY assignees_aliases_map
    ADD CONSTRAINT alias_contacts_assignees_aliases_map_fk FOREIGN KEY (alias_contact_id) REFERENCES alias_contacts(id) MATCH FULL;


--
-- Name: assignors_aliases_map alias_contacts_assignors_aliases_map_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY assignors_aliases_map
    ADD CONSTRAINT alias_contacts_assignors_aliases_map_fk FOREIGN KEY (alias_contact_id) REFERENCES alias_contacts(id) MATCH FULL;


--
-- Name: lit_parties alias_contacts_lit_parties_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_parties
    ADD CONSTRAINT alias_contacts_lit_parties_fk FOREIGN KEY (alias_contact_id) REFERENCES alias_contacts(id);


--
-- Name: lit_parties_representations alias_contacts_lit_parties_representations_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_parties_representations
    ADD CONSTRAINT alias_contacts_lit_parties_representations_fk FOREIGN KEY (lawyer_alias_contact_id) REFERENCES alias_contacts(id);


--
-- Name: lit_parties_representations alias_contacts_lit_parties_representations_fk1; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_parties_representations
    ADD CONSTRAINT alias_contacts_lit_parties_representations_fk1 FOREIGN KEY (lawfirm_alias_contact_id) REFERENCES alias_contacts(id);


--
-- Name: pat_assignments alias_contacts_pat_assignments_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_assignments
    ADD CONSTRAINT alias_contacts_pat_assignments_fk FOREIGN KEY (correspondent_alias_contact_id) REFERENCES alias_contacts(id);


--
-- Name: pats_aliases_map alias_contacts_pats_aliases_map_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pats_aliases_map
    ADD CONSTRAINT alias_contacts_pats_aliases_map_fk FOREIGN KEY (alias_contact_id) REFERENCES alias_contacts(id) MATCH FULL;


--
-- Name: pat_stats_sponsoring_parties alias_id_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_stats_sponsoring_parties
    ADD CONSTRAINT alias_id_fk FOREIGN KEY (alias_id) REFERENCES aliases(id);


--
-- Name: alias_contacts aliases_alias_addresses_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY alias_contacts
    ADD CONSTRAINT aliases_alias_addresses_fk FOREIGN KEY (alias_id) REFERENCES aliases(id);


--
-- Name: assignees_aliases_map aliases_assignees_aliases_map_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY assignees_aliases_map
    ADD CONSTRAINT aliases_assignees_aliases_map_fk FOREIGN KEY (alias_id) REFERENCES aliases(id);


--
-- Name: assignors_aliases_map aliases_assignment_alias_map_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY assignors_aliases_map
    ADD CONSTRAINT aliases_assignment_alias_map_fk FOREIGN KEY (alias_id) REFERENCES aliases(id);


--
-- Name: pat_assignments aliases_assignments_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_assignments
    ADD CONSTRAINT aliases_assignments_fk FOREIGN KEY (correspondent_alias_id) REFERENCES aliases(id);


--
-- Name: aliases aliases_fkey_ent_id; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY aliases
    ADD CONSTRAINT aliases_fkey_ent_id FOREIGN KEY (ent_id) REFERENCES ents(id);


--
-- Name: lit_courts aliases_lit_courts_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_courts
    ADD CONSTRAINT aliases_lit_courts_fk FOREIGN KEY (alias_id) REFERENCES aliases(id);


--
-- Name: pat_stats_current_assignees aliases_pat_stats_current_assignees_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_stats_current_assignees
    ADD CONSTRAINT aliases_pat_stats_current_assignees_fk FOREIGN KEY (alias_id) REFERENCES aliases(id);


--
-- Name: pats_aliases_map aliases_pats_aliases_map_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pats_aliases_map
    ADD CONSTRAINT aliases_pats_aliases_map_fk FOREIGN KEY (alias_id) REFERENCES aliases(id);


--
-- Name: lit_judges_map assgnment_types_lit_judges_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_judges_map
    ADD CONSTRAINT assgnment_types_lit_judges_fk FOREIGN KEY (assignment_type_id) REFERENCES judge_assignment_types(id);


--
-- Name: assignees_aliases_map assignments_assignees_aliases_map_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY assignees_aliases_map
    ADD CONSTRAINT assignments_assignees_aliases_map_fk FOREIGN KEY (assignment_id) REFERENCES pat_assignments(id);


--
-- Name: assignors_aliases_map assignments_assignment_ent_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY assignors_aliases_map
    ADD CONSTRAINT assignments_assignment_ent_fk FOREIGN KEY (assignment_id) REFERENCES pat_assignments(id);


--
-- Name: dma_lit_annotations dma_annotations_lit_classification_type_id_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY dma_lit_annotations
    ADD CONSTRAINT dma_annotations_lit_classification_type_id_fk FOREIGN KEY (lit_classification_type_id) REFERENCES lit_classification_types(id);


--
-- Name: dma_lit_annotations dma_annotations_lit_curated_cause_type_id_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY dma_lit_annotations
    ADD CONSTRAINT dma_annotations_lit_curated_cause_type_id_fk FOREIGN KEY (lit_curated_cause_type_id) REFERENCES lit_curated_cause_types(id);


--
-- Name: dma_lit_annotations dma_annotations_lit_id_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY dma_lit_annotations
    ADD CONSTRAINT dma_annotations_lit_id_fk FOREIGN KEY (lit_id) REFERENCES lits(id);


--
-- Name: dma_lit_annotations dma_annotations_lit_stage_id_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY dma_lit_annotations
    ADD CONSTRAINT dma_annotations_lit_stage_id_fk FOREIGN KEY (lit_stage_id) REFERENCES lit_stages(id);


--
-- Name: dma_lit_annotations dma_annotations_lit_type_id_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY dma_lit_annotations
    ADD CONSTRAINT dma_annotations_lit_type_id_fk FOREIGN KEY (lit_type_id) REFERENCES lit_types(id);


--
-- Name: dma_lit_annotations dma_annotations_market_sector_type_id_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY dma_lit_annotations
    ADD CONSTRAINT dma_annotations_market_sector_type_id_fk FOREIGN KEY (market_sector_type_id) REFERENCES market_sector_types(id);


--
-- Name: dma_lits_pats_map dma_lits_pats_map_lit_id_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY dma_lits_pats_map
    ADD CONSTRAINT dma_lits_pats_map_lit_id_fk FOREIGN KEY (lit_id) REFERENCES lits(id);


--
-- Name: docket_entry_documents_map docket_entries_docket_entry_documents_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY docket_entry_documents_map
    ADD CONSTRAINT docket_entries_docket_entry_documents_fk FOREIGN KEY (docket_entry_id) REFERENCES docket_entries(id);


--
-- Name: docket_entry_documents_map documents_docket_entry_documents_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY docket_entry_documents_map
    ADD CONSTRAINT documents_docket_entry_documents_fk FOREIGN KEY (lit_document_id) REFERENCES lit_documents(id);


--
-- Name: ent_advanced_relationships ent_advanced_relationship_types_ent_advanced_relationships_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ent_advanced_relationships
    ADD CONSTRAINT ent_advanced_relationship_types_ent_advanced_relationships_fk FOREIGN KEY (ent_advanced_relationship_type_id) REFERENCES ent_advanced_relationship_types(id);


--
-- Name: ent_advanced_relationships_temporal ent_advanced_relationship_types_ent_advanced_relationships_temp; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ent_advanced_relationships_temporal
    ADD CONSTRAINT ent_advanced_relationship_types_ent_advanced_relationships_temp FOREIGN KEY (ent_advanced_relationship_type_id) REFERENCES ent_advanced_relationship_types(id);


--
-- Name: lit_judges_map ent_aliases_lit_judges_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_judges_map
    ADD CONSTRAINT ent_aliases_lit_judges_fk FOREIGN KEY (alias_id) REFERENCES aliases(id);


--
-- Name: lit_parties ent_aliases_lit_parties_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_parties
    ADD CONSTRAINT ent_aliases_lit_parties_fk FOREIGN KEY (alias_id) REFERENCES aliases(id);


--
-- Name: lit_parties_representations ent_aliases_lit_parties_representations_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_parties_representations
    ADD CONSTRAINT ent_aliases_lit_parties_representations_fk FOREIGN KEY (lawyer_alias_id) REFERENCES aliases(id);


--
-- Name: lit_parties_representations ent_aliases_lit_parties_representations_fk1; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_parties_representations
    ADD CONSTRAINT ent_aliases_lit_parties_representations_fk1 FOREIGN KEY (lawfirm_alias_id) REFERENCES aliases(id);


--
-- Name: ent_relationships ent_relationship_types_ent_relationships_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ent_relationships
    ADD CONSTRAINT ent_relationship_types_ent_relationships_fk FOREIGN KEY (ent_relationship_type_id) REFERENCES ent_relationship_types(id);


--
-- Name: ent_relationships_temporal ent_relationship_types_ent_relationships_temporal_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ent_relationships_temporal
    ADD CONSTRAINT ent_relationship_types_ent_relationships_temporal_fk FOREIGN KEY (ent_relationship_type_id) REFERENCES ent_relationship_types(id);


--
-- Name: ent_subtypes_map ent_subtypes_ent_subtypes_map_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ent_subtypes_map
    ADD CONSTRAINT ent_subtypes_ent_subtypes_map_fk FOREIGN KEY (ent_subtype_id) REFERENCES ent_subtypes(id);


--
-- Name: court_details ents_court_detail_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY court_details
    ADD CONSTRAINT ents_court_detail_fk FOREIGN KEY (ent_id) REFERENCES ents(id);


--
-- Name: ent_advanced_relationships ents_ent_advanced_relationships_fk1; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ent_advanced_relationships
    ADD CONSTRAINT ents_ent_advanced_relationships_fk1 FOREIGN KEY (ent_id) REFERENCES ents(id);


--
-- Name: ent_advanced_relationships ents_ent_advanced_relationships_fk2; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ent_advanced_relationships
    ADD CONSTRAINT ents_ent_advanced_relationships_fk2 FOREIGN KEY (related_ent_id) REFERENCES ents(id);


--
-- Name: ent_advanced_relationships_temporal ents_ent_advanced_relationships_temporal_fk1; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ent_advanced_relationships_temporal
    ADD CONSTRAINT ents_ent_advanced_relationships_temporal_fk1 FOREIGN KEY (ent_id) REFERENCES ents(id);


--
-- Name: ent_advanced_relationships_temporal ents_ent_advanced_relationships_temporal_fk2; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ent_advanced_relationships_temporal
    ADD CONSTRAINT ents_ent_advanced_relationships_temporal_fk2 FOREIGN KEY (related_ent_id) REFERENCES ents(id);


--
-- Name: ent_relationships ents_ent_relationships_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ent_relationships
    ADD CONSTRAINT ents_ent_relationships_fk FOREIGN KEY (ent_id) REFERENCES ents(id);


--
-- Name: ent_relationships ents_ent_relationships_fk1; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ent_relationships
    ADD CONSTRAINT ents_ent_relationships_fk1 FOREIGN KEY (related_ent_id) REFERENCES ents(id);


--
-- Name: ent_relationships_temporal ents_ent_relationships_temporal_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ent_relationships_temporal
    ADD CONSTRAINT ents_ent_relationships_temporal_fk FOREIGN KEY (ent_id) REFERENCES ents(id);


--
-- Name: ent_relationships_temporal ents_ent_relationships_temporal_fk1; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ent_relationships_temporal
    ADD CONSTRAINT ents_ent_relationships_temporal_fk1 FOREIGN KEY (related_ent_id) REFERENCES ents(id);


--
-- Name: entity_contacts ents_entity_contacts_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY entity_contacts
    ADD CONSTRAINT ents_entity_contacts_fk FOREIGN KEY (ent_id) REFERENCES ents(id);


--
-- Name: ents_market_sector_types ents_ents_market_sector_types_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ents_market_sector_types
    ADD CONSTRAINT ents_ents_market_sector_types_fk FOREIGN KEY (ent_id) REFERENCES ents(id);


--
-- Name: ents fk_ents_ent_type_id; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ents
    ADD CONSTRAINT fk_ents_ent_type_id FOREIGN KEY (ent_type_id) REFERENCES ent_types(id);


--
-- Name: pat_secondary_conveyance fk_par_assignamnts; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_secondary_conveyance
    ADD CONSTRAINT fk_par_assignamnts FOREIGN KEY (pat_assignment_id) REFERENCES pat_assignments(id);


--
-- Name: pat_assignments_assoc_r_f fk_pat_assignment_id; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_assignments_assoc_r_f
    ADD CONSTRAINT fk_pat_assignment_id FOREIGN KEY (pat_assignment_id) REFERENCES pat_assignments(id);


--
-- Name: pat_secondary_conveyance fk_pat_secondary_conveyance_types; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_secondary_conveyance
    ADD CONSTRAINT fk_pat_secondary_conveyance_types FOREIGN KEY (pat_secondary_conveyance_type_id) REFERENCES pat_secondary_conveyance_types(id);


--
-- Name: pat_assignments fk_primary_conveyance_logic_id; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_assignments
    ADD CONSTRAINT fk_primary_conveyance_logic_id FOREIGN KEY (primary_conveyance_logic_id) REFERENCES patent_conveyance_normalization.primary_conveyance_logic(id);


--
-- Name: ipc_groups ipc_classes_ipc_groups_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_groups
    ADD CONSTRAINT ipc_classes_ipc_groups_fk FOREIGN KEY (ipc_class_id) REFERENCES ipc_classes(id);


--
-- Name: ipc_subclasses ipc_classes_ipc_subclasses_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_subclasses
    ADD CONSTRAINT ipc_classes_ipc_subclasses_fk FOREIGN KEY (ipc_class_id) REFERENCES ipc_classes(id);


--
-- Name: ipc_subgroups ipc_classes_ipc_subgroups_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_subgroups
    ADD CONSTRAINT ipc_classes_ipc_subgroups_fk FOREIGN KEY (ipc_class_id) REFERENCES ipc_classes(id);


--
-- Name: ipc_subgroups ipc_groups_ipc_subgroups_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_subgroups
    ADD CONSTRAINT ipc_groups_ipc_subgroups_fk FOREIGN KEY (ipc_group_id) REFERENCES ipc_groups(id);


--
-- Name: ipc_classes ipc_sections_ipc_classes_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_classes
    ADD CONSTRAINT ipc_sections_ipc_classes_fk FOREIGN KEY (ipc_section_id) REFERENCES ipc_sections(id);


--
-- Name: ipc_groups ipc_sections_ipc_groups_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_groups
    ADD CONSTRAINT ipc_sections_ipc_groups_fk FOREIGN KEY (ipc_section_id) REFERENCES ipc_sections(id);


--
-- Name: ipc_subclasses ipc_sections_ipc_subclasses_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_subclasses
    ADD CONSTRAINT ipc_sections_ipc_subclasses_fk FOREIGN KEY (ipc_section_id) REFERENCES ipc_sections(id);


--
-- Name: ipc_subgroups ipc_sections_ipc_subgroups_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_subgroups
    ADD CONSTRAINT ipc_sections_ipc_subgroups_fk FOREIGN KEY (ipc_section_id) REFERENCES ipc_sections(id);


--
-- Name: ipc_groups ipc_subclasses_ipc_groups_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_groups
    ADD CONSTRAINT ipc_subclasses_ipc_groups_fk FOREIGN KEY (ipc_subclass_id) REFERENCES ipc_subclasses(id);


--
-- Name: ipc_subgroups ipc_subclasses_ipc_subgroups_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_subgroups
    ADD CONSTRAINT ipc_subclasses_ipc_subgroups_fk FOREIGN KEY (ipc_subclass_id) REFERENCES ipc_subclasses(id);


--
-- Name: ipc_subgroups ipc_subgroups_ipc_subgroups_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ipc_subgroups
    ADD CONSTRAINT ipc_subgroups_ipc_subgroups_fk FOREIGN KEY (parent_subgroup_id) REFERENCES ipc_subgroups(id);


--
-- Name: lit_case_stages lit_case_stages_lit_id_fkey; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_case_stages
    ADD CONSTRAINT lit_case_stages_lit_id_fkey FOREIGN KEY (lit_id) REFERENCES lits(id);


--
-- Name: lit_case_stages lit_case_stages_lit_stage_id_fkey; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_case_stages
    ADD CONSTRAINT lit_case_stages_lit_stage_id_fkey FOREIGN KEY (lit_stage_id) REFERENCES lit_stages(id);


--
-- Name: lits lit_causes_lits_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lits
    ADD CONSTRAINT lit_causes_lits_fk FOREIGN KEY (lit_cause_id) REFERENCES lit_cause_types(id);


--
-- Name: lit_annotations lit_classification_type_lit_annotations_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_annotations
    ADD CONSTRAINT lit_classification_type_lit_annotations_fk FOREIGN KEY (lit_classification_type_id) REFERENCES lit_classification_types(id);


--
-- Name: lit_annotations lit_currated_cause_types_lit_annotations_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_annotations
    ADD CONSTRAINT lit_currated_cause_types_lit_annotations_fk FOREIGN KEY (lit_curated_cause_type_id) REFERENCES lit_curated_cause_types(id);


--
-- Name: lit_documents lit_documents_document_status_id_fkey; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_documents
    ADD CONSTRAINT lit_documents_document_status_id_fkey FOREIGN KEY (document_status_id) REFERENCES lit_document_statuses(id);


--
-- Name: lit_documents lit_documents_file_type_id_fkey; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_documents
    ADD CONSTRAINT lit_documents_file_type_id_fkey FOREIGN KEY (file_type_id) REFERENCES file_types(id);


--
-- Name: lit_document_orphans lit_documents_lit_document_orphans_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_document_orphans
    ADD CONSTRAINT lit_documents_lit_document_orphans_fk FOREIGN KEY (lit_document_id) REFERENCES lit_documents(id);


--
-- Name: lit_documents lit_documents_lit_document_type_id_fkey; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_documents
    ADD CONSTRAINT lit_documents_lit_document_type_id_fkey FOREIGN KEY (lit_document_type_id) REFERENCES lit_document_types(id);


--
-- Name: lit_party_outcomes lit_parties_lit_party_outcomes_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_party_outcomes
    ADD CONSTRAINT lit_parties_lit_party_outcomes_fk FOREIGN KEY (lit_parties_id) REFERENCES lit_parties(id);


--
-- Name: lit_party_outcomes lit_parties_lit_party_outcomes_fk1; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_party_outcomes
    ADD CONSTRAINT lit_parties_lit_party_outcomes_fk1 FOREIGN KEY (lit_party_outcome_type_id, lit_party_outcome_subtype_id) REFERENCES lit_party_outcome_type_subtype_map(lit_party_outcome_type_id, lit_party_outcome_subtype_id);


--
-- Name: lit_parties_representations lit_parties_lit_party_representations_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_parties_representations
    ADD CONSTRAINT lit_parties_lit_party_representations_fk FOREIGN KEY (lit_parties_id) REFERENCES lit_parties(id);


--
-- Name: lit_party_types lit_party_normalized_types_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_party_types
    ADD CONSTRAINT lit_party_normalized_types_fk FOREIGN KEY (lit_party_normalized_type) REFERENCES lit_party_normalized_types(name) MATCH FULL;


--
-- Name: lit_parties lit_party_types_lit_parties_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_parties
    ADD CONSTRAINT lit_party_types_lit_parties_fk FOREIGN KEY (lit_party_type_id) REFERENCES lit_party_types(id);


--
-- Name: lit_relationships lit_relationship_types_lit_relationships_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_relationships
    ADD CONSTRAINT lit_relationship_types_lit_relationships_fk FOREIGN KEY (lit_relationship_type_id) REFERENCES lit_relationship_types(id);


--
-- Name: lit_relationships lit_relationships_lit_families_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_relationships
    ADD CONSTRAINT lit_relationships_lit_families_fk FOREIGN KEY (lit_family_id) REFERENCES lit_families(id);


--
-- Name: lit_annotations lit_stage_lit_annotations_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_annotations
    ADD CONSTRAINT lit_stage_lit_annotations_fk FOREIGN KEY (lit_stage_id) REFERENCES lit_stages(id);


--
-- Name: lit_annotations lit_types_lit_annotations_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_annotations
    ADD CONSTRAINT lit_types_lit_annotations_fk FOREIGN KEY (lit_type_id) REFERENCES lit_types(id);


--
-- Name: docket_entries lits_docket_entries_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY docket_entries
    ADD CONSTRAINT lits_docket_entries_fk FOREIGN KEY (lit_id) REFERENCES lits(id);


--
-- Name: lit_courts lits_lit_court_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_courts
    ADD CONSTRAINT lits_lit_court_fk FOREIGN KEY (lit_id) REFERENCES lits(id);


--
-- Name: lit_judges_map lits_lit_judges_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_judges_map
    ADD CONSTRAINT lits_lit_judges_fk FOREIGN KEY (lit_id) REFERENCES lits(id);


--
-- Name: lit_parties lits_lit_parties_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_parties
    ADD CONSTRAINT lits_lit_parties_fk FOREIGN KEY (lit_id) REFERENCES lits(id);


--
-- Name: lit_relationships lits_lit_relationships_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_relationships
    ADD CONSTRAINT lits_lit_relationships_fk FOREIGN KEY (from_lit_id) REFERENCES lits(id);


--
-- Name: lit_relationships lits_lit_relationships_fk1; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_relationships
    ADD CONSTRAINT lits_lit_relationships_fk1 FOREIGN KEY (to_lit_id) REFERENCES lits(id);


--
-- Name: lits_pats_map lits_lits_pats_map_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lits_pats_map
    ADD CONSTRAINT lits_lits_pats_map_fk FOREIGN KEY (lit_id) REFERENCES lits(id) MATCH FULL;


--
-- Name: lit_annotations lits_rpx_casedata_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_annotations
    ADD CONSTRAINT lits_rpx_casedata_fk FOREIGN KEY (lit_id) REFERENCES lits(id);


--
-- Name: ents_market_sector_types market_sector_types_ents_market_sector_types_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY ents_market_sector_types
    ADD CONSTRAINT market_sector_types_ents_market_sector_types_fk FOREIGN KEY (market_sector_type_id) REFERENCES market_sector_types(id);


--
-- Name: lit_annotations market_sectors_lits_annotations_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY lit_annotations
    ADD CONSTRAINT market_sectors_lits_annotations_fk FOREIGN KEY (market_sector_type_id) REFERENCES market_sector_types(id);


--
-- Name: pats_assignments_map pat_assignments_pats_assignments_map_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pats_assignments_map
    ADD CONSTRAINT pat_assignments_pats_assignments_map_fk FOREIGN KEY (pat_assignment_id) REFERENCES pat_assignments(id);


--
-- Name: pat_claim_relationships pat_claims_pat_claim_relationships_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_claim_relationships
    ADD CONSTRAINT pat_claims_pat_claim_relationships_fk FOREIGN KEY (pat_claims_id) REFERENCES pat_claims(id);


--
-- Name: pats_assignments_map pat_document_types_pats_assignments_map_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pats_assignments_map
    ADD CONSTRAINT pat_document_types_pats_assignments_map_fk FOREIGN KEY (document_type_id) REFERENCES pat_document_types(id);


--
-- Name: pat_current pat_maint_code_pat_current_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_current
    ADD CONSTRAINT pat_maint_code_pat_current_fk FOREIGN KEY (maintenance_code_id) REFERENCES pat_maintenance_code(id);


--
-- Name: pat_maintenance_fee_events pat_maintenance_fee_events_pat_maintenance_fee_entity_type__fke; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_maintenance_fee_events
    ADD CONSTRAINT pat_maintenance_fee_events_pat_maintenance_fee_entity_type__fke FOREIGN KEY (pat_maintenance_fee_entity_type_id) REFERENCES pat_maintenance_fee_entity_types(id);


--
-- Name: pat_maintenance_fee_events pat_maintenance_fee_events_pat_maintenance_fee_event_type__fkey; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_maintenance_fee_events
    ADD CONSTRAINT pat_maintenance_fee_events_pat_maintenance_fee_event_type__fkey FOREIGN KEY (pat_maintenance_fee_event_type_id) REFERENCES pat_maintenance_fee_event_types(id);


--
-- Name: pat_reissue_number pat_reissue_number_pat_id_fkey; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_reissue_number
    ADD CONSTRAINT pat_reissue_number_pat_id_fkey FOREIGN KEY (pat_id) REFERENCES pats(id);


--
-- Name: pat_stats_continuances pat_stats_pat_stats_continuances_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_stats_continuances
    ADD CONSTRAINT pat_stats_pat_stats_continuances_fk FOREIGN KEY (pat_stats_id) REFERENCES pat_stats(id);


--
-- Name: pat_stats_current_assignees pat_stats_pat_stats_current_assignees_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_stats_current_assignees
    ADD CONSTRAINT pat_stats_pat_stats_current_assignees_fk FOREIGN KEY (pat_stats_id) REFERENCES pat_stats(id);


--
-- Name: pat_stats_sponsoring_parties pat_stats_pat_stats_sponsoring_parties_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_stats_sponsoring_parties
    ADD CONSTRAINT pat_stats_pat_stats_sponsoring_parties_fk FOREIGN KEY (pat_stats_id) REFERENCES pat_stats(id);


--
-- Name: pat_claims patents_claims_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_claims
    ADD CONSTRAINT patents_claims_fk FOREIGN KEY (pat_id) REFERENCES pats(id);


--
-- Name: pat_drawings patents_drawings_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_drawings
    ADD CONSTRAINT patents_drawings_fk FOREIGN KEY (pat_id) REFERENCES pats(id);


--
-- Name: pat_documents patents_pat_documents_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_documents
    ADD CONSTRAINT patents_pat_documents_fk FOREIGN KEY (pat_id) REFERENCES pats(id);


--
-- Name: pat_abstracts pats_abst_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_abstracts
    ADD CONSTRAINT pats_abst_fk FOREIGN KEY (pat_id) REFERENCES pats(id);


--
-- Name: pats_aliases_map pats_aliases_relationship_types_pats_aliases_map_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pats_aliases_map
    ADD CONSTRAINT pats_aliases_relationship_types_pats_aliases_map_fk FOREIGN KEY (pats_aliases_relationship_type_id) REFERENCES pats_aliases_relationship_types(id);


--
-- Name: pat_descriptions pats_descr_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_descriptions
    ADD CONSTRAINT pats_descr_fk FOREIGN KEY (pat_id) REFERENCES pats(id);


--
-- Name: foreign_application_priority_docs pats_foreign_application_priority_docs_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY foreign_application_priority_docs
    ADD CONSTRAINT pats_foreign_application_priority_docs_fk FOREIGN KEY (pat_id) REFERENCES pats(id);


--
-- Name: pat_other_references pats_orfs_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_other_references
    ADD CONSTRAINT pats_orfs_fk FOREIGN KEY (pat_id) REFERENCES pats(id);


--
-- Name: pat_ipc_classes pats_pat_ipc_classes_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_ipc_classes
    ADD CONSTRAINT pats_pat_ipc_classes_fk FOREIGN KEY (pat_id) REFERENCES pats(id);


--
-- Name: pat_maintenance_fee_events pats_pat_maintenance_fee_events_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_maintenance_fee_events
    ADD CONSTRAINT pats_pat_maintenance_fee_events_fk FOREIGN KEY (pat_id) REFERENCES pats(id);


--
-- Name: pats_aliases_map pats_pats_aliases_map_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pats_aliases_map
    ADD CONSTRAINT pats_pats_aliases_map_fk FOREIGN KEY (pat_id) REFERENCES pats(id);


--
-- Name: pat_cross_ref_classes pats_pats_cross_ref_classes_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_cross_ref_classes
    ADD CONSTRAINT pats_pats_cross_ref_classes_fk FOREIGN KEY (pat_id) REFERENCES pats(id);


--
-- Name: pat_related_documents pats_rupd_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY pat_related_documents
    ADD CONSTRAINT pats_rupd_fk FOREIGN KEY (pat_id) REFERENCES pats(id);


--
-- Name: uspcs_subclasses uspcs_classes_uspcs_subclasses_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY uspcs_subclasses
    ADD CONSTRAINT uspcs_classes_uspcs_subclasses_fk FOREIGN KEY (uspcs_class_id) REFERENCES uspcs_classes(id);


--
-- Name: uspcs_subclasses uspcs_subclasses_uspcs_subclasses_fk; Type: FK CONSTRAINT; Schema: core; Owner: -
--

ALTER TABLE ONLY uspcs_subclasses
    ADD CONSTRAINT uspcs_subclasses_uspcs_subclasses_fk FOREIGN KEY (parent_uspcs_subclass_id) REFERENCES uspcs_subclasses(id);


SET search_path = docdb, pg_catalog;

--
-- Name: docdb_logs docdb_logs_fk; Type: FK CONSTRAINT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY docdb_logs
    ADD CONSTRAINT docdb_logs_fk FOREIGN KEY (batch_id) REFERENCES docdb_batch(id);


--
-- Name: docdb_abstracts docdb_pats_docdb_abstracts_fk; Type: FK CONSTRAINT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY docdb_abstracts
    ADD CONSTRAINT docdb_pats_docdb_abstracts_fk FOREIGN KEY (pat_id) REFERENCES docdb_pats(id);


--
-- Name: docdb_applicants docdb_pats_docdb_applicants_fk; Type: FK CONSTRAINT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY docdb_applicants
    ADD CONSTRAINT docdb_pats_docdb_applicants_fk FOREIGN KEY (pat_id) REFERENCES docdb_pats(id);


--
-- Name: docdb_citations docdb_pats_docdb_citations_fk; Type: FK CONSTRAINT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY docdb_citations
    ADD CONSTRAINT docdb_pats_docdb_citations_fk FOREIGN KEY (pat_id) REFERENCES docdb_pats(id);


--
-- Name: docdb_classifications docdb_pats_docdb_classifications_fk; Type: FK CONSTRAINT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY docdb_classifications
    ADD CONSTRAINT docdb_pats_docdb_classifications_fk FOREIGN KEY (pat_id) REFERENCES docdb_pats(id);


--
-- Name: docdb_inventors docdb_pats_docdb_inventors_fk; Type: FK CONSTRAINT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY docdb_inventors
    ADD CONSTRAINT docdb_pats_docdb_inventors_fk FOREIGN KEY (pat_id) REFERENCES docdb_pats(id);


--
-- Name: docdb_ipcs docdb_pats_docdb_ipcs_fk; Type: FK CONSTRAINT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY docdb_ipcs
    ADD CONSTRAINT docdb_pats_docdb_ipcs_fk FOREIGN KEY (pat_id) REFERENCES docdb_pats(id);


--
-- Name: docdb_national_classifications docdb_pats_docdb_national_classifications_fk; Type: FK CONSTRAINT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY docdb_national_classifications
    ADD CONSTRAINT docdb_pats_docdb_national_classifications_fk FOREIGN KEY (pat_id) REFERENCES docdb_pats(id);


--
-- Name: docdb_priority_claims docdb_pats_docdb_priority_claims_fk; Type: FK CONSTRAINT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY docdb_priority_claims
    ADD CONSTRAINT docdb_pats_docdb_priority_claims_fk FOREIGN KEY (pat_id) REFERENCES docdb_pats(id);


--
-- Name: docdb_titles docdb_pats_docdb_titles_fk; Type: FK CONSTRAINT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY docdb_titles
    ADD CONSTRAINT docdb_pats_docdb_titles_fk FOREIGN KEY (pat_id) REFERENCES docdb_pats(id);


--
-- Name: log_data log_data__log_levels_fk; Type: FK CONSTRAINT; Schema: docdb; Owner: -
--

ALTER TABLE ONLY log_data
    ADD CONSTRAINT log_data__log_levels_fk FOREIGN KEY (log_level_id) REFERENCES logging.log_levels(id);


SET search_path = ptab, pg_catalog;

--
-- Name: ptab_case_details case_details_party_types_ptab_case_details_fk; Type: FK CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_case_details
    ADD CONSTRAINT case_details_party_types_ptab_case_details_fk FOREIGN KEY (ptab_case_detail_party_type_id) REFERENCES ptab_case_detail_party_types(id);


--
-- Name: ptab_case_details cases_case_details_fk; Type: FK CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_case_details
    ADD CONSTRAINT cases_case_details_fk FOREIGN KEY (ptab_case_id) REFERENCES ptab_cases(id);


--
-- Name: ptab_parties core_aliases_parties_fk; Type: FK CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_parties
    ADD CONSTRAINT core_aliases_parties_fk FOREIGN KEY (alias_id) REFERENCES core.aliases(id);


--
-- Name: ptab_parties party_types_parties_fk; Type: FK CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_parties
    ADD CONSTRAINT party_types_parties_fk FOREIGN KEY (ptab_party_type_id) REFERENCES ptab_party_types(id);


--
-- Name: ptab_annotations ptab_annotations_case_type_id_fkey; Type: FK CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_annotations
    ADD CONSTRAINT ptab_annotations_case_type_id_fkey FOREIGN KEY (case_type_id) REFERENCES core.lit_types(id);


--
-- Name: ptab_annotations ptab_annotations_ptab_case_id_fkey; Type: FK CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_annotations
    ADD CONSTRAINT ptab_annotations_ptab_case_id_fkey FOREIGN KEY (ptab_case_id) REFERENCES ptab_cases(id);


--
-- Name: ptab_case_relationships ptab_case_relationships_joined_case_id_fkey; Type: FK CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_case_relationships
    ADD CONSTRAINT ptab_case_relationships_joined_case_id_fkey FOREIGN KEY (joined_case_id) REFERENCES ptab_cases(id);


--
-- Name: ptab_case_relationships ptab_case_relationships_lead_case_id_fkey; Type: FK CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_case_relationships
    ADD CONSTRAINT ptab_case_relationships_lead_case_id_fkey FOREIGN KEY (lead_case_id) REFERENCES ptab_cases(id);


--
-- Name: ptab_cases ptab_cases_case_types_fk; Type: FK CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_cases
    ADD CONSTRAINT ptab_cases_case_types_fk FOREIGN KEY (ptab_case_type_id) REFERENCES ptab_case_types(id);


--
-- Name: ptab_parties ptab_cases_parties_fk; Type: FK CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_parties
    ADD CONSTRAINT ptab_cases_parties_fk FOREIGN KEY (ptab_case_id) REFERENCES ptab_cases(id);


--
-- Name: ptab_judges_map ptab_judges_map_judge_alias_id_fkey; Type: FK CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_judges_map
    ADD CONSTRAINT ptab_judges_map_judge_alias_id_fkey FOREIGN KEY (judge_alias_id) REFERENCES core.aliases(id);


--
-- Name: ptab_judges_map ptab_judges_map_ptab_case_id_fkey; Type: FK CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_judges_map
    ADD CONSTRAINT ptab_judges_map_ptab_case_id_fkey FOREIGN KEY (ptab_case_id) REFERENCES ptab_cases(id);


--
-- Name: ptab_cases technology_centers_cases_fk; Type: FK CONSTRAINT; Schema: ptab; Owner: -
--

ALTER TABLE ONLY ptab_cases
    ADD CONSTRAINT technology_centers_cases_fk FOREIGN KEY (tech_center) REFERENCES technology_centers(tech_center_number);


SET search_path = public, pg_catalog;

--
-- Name: patents fk_rails_e62b251a38; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY patents
    ADD CONSTRAINT fk_rails_e62b251a38 FOREIGN KEY (document_id) REFERENCES documents(id);


--
-- PostgreSQL database dump complete
--
